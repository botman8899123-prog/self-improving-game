<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NEON SURVIVE ‚Äî Self-Improving Game v59 ü•à Iteration #59</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéÆ</text></svg>">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0f;
            color: #00ff88;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none; user-select: none;
        }
        #gameCanvas { display: block; background: #000; cursor: none; touch-action: none; }
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .hud { position: absolute; top: 20px; left: 20px; font-size: 18px; text-shadow: 0 0 10px #00ff88; pointer-events: none; }
        .hud-right { position: absolute; top: 20px; right: 20px; text-align: right; font-size: 14px; opacity: 0.7; }
        .hud-bottom { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 13px; opacity: 0.6; text-align: center; pointer-events: none; }
        #menu {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: all;
        }
        #menu.hidden { display: none; }
        .title {
            font-size: 72px; font-weight: bold;
            text-shadow: 0 0 20px #00ff88, 0 0 40px #00ff88;
            margin-bottom: 20px; animation: pulse 2s infinite;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .subtitle { font-size: 18px; opacity: 0.8; margin-bottom: 40px; }
        .high-score { font-size: 24px; margin-bottom: 30px; }
        .start-btn {
            padding: 15px 40px; font-size: 24px; font-family: 'Courier New', monospace;
            background: transparent; color: #00ff88; border: 2px solid #00ff88;
            cursor: pointer; transition: all 0.3s; text-shadow: 0 0 10px #00ff88;
            pointer-events: all;
        }
        .start-btn:hover { background: #00ff88; color: #000; box-shadow: 0 0 20px #00ff88; }
        .start-btn { touch-action: manipulation; min-height: 48px; }
        .controls { margin-top: 30px; font-size: 14px; opacity: 0.6; text-align: center; }
        #gameOver {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: all;
        }
        #gameOver.show { display: flex; }
        .game-over-title { font-size: 64px; color: #ff0044; text-shadow: 0 0 20px #ff0044; margin-bottom: 30px; }
        .final-score { font-size: 32px; margin-bottom: 40px; text-align: center; line-height: 1.6; }
        .info-section { max-width: 800px; margin: 40px auto; padding: 20px; background: rgba(0,255,136,0.05); border: 1px solid #00ff88; width: calc(100% - 30px); position: relative; z-index: 1; }
        #menu:not(.hidden) ~ .info-section, #menu:not(.hidden) ~ .footer { display: none; }
        .info-section h2 { margin-bottom: 15px; text-shadow: 0 0 10px #00ff88; }
        .info-section p { line-height: 1.6; opacity: 0.8; }
        .footer { text-align: center; padding: 20px; opacity: 0.5; font-size: 12px; }
        #pauseOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100; pointer-events: all;
        }
        #pauseOverlay.show { display: flex; }
        .pause-title { font-size: 64px; color: #00ff88; text-shadow: 0 0 30px #00ff88; margin-bottom: 20px; }
        .pause-hint { font-size: 16px; opacity: 0.6; margin-top: 20px; }
        #pauseBtn {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            font-family: 'Courier New', monospace; font-size: 18px;
            background: transparent; color: #00ff88; border: 1px solid rgba(0,255,136,0.3);
            padding: 5px 15px; cursor: pointer; z-index: 50; display: none; opacity: 0.5;
            transition: opacity 0.2s;
        }
        #pauseBtn:hover { opacity: 1; }
        #settingsPanel {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            background: rgba(0,0,0,0.95); border: 1px solid #00ff88; padding: 30px;
            z-index: 200; display: none; min-width: 280px; max-width: 340px;
            box-shadow: 0 0 30px rgba(0,255,136,0.3);
        }
        #settingsPanel.show { display: block; }
        #settingsPanel h2 { color: #00ff88; text-shadow: 0 0 10px #00ff88; margin-bottom: 20px; font-size: 24px; text-align: center; }
        .setting-row { display: flex; justify-content: space-between; align-items: center; margin: 14px 0; font-size: 14px; }
        .setting-row label { opacity: 0.8; }
        .setting-toggle {
            width: 44px; height: 24px; background: rgba(255,255,255,0.1); border: 1px solid #00ff88;
            border-radius: 12px; cursor: pointer; position: relative; transition: background 0.2s;
        }
        .setting-toggle.on { background: rgba(0,255,136,0.3); }
        .setting-toggle::after {
            content: ''; position: absolute; top: 2px; left: 2px; width: 18px; height: 18px;
            background: #00ff88; border-radius: 50%; transition: transform 0.2s;
        }
        .setting-toggle.on::after { transform: translateX(20px); }
        .settings-close {
            display: block; margin: 20px auto 0; padding: 8px 24px; font-family: 'Courier New', monospace;
            font-size: 16px; background: transparent; color: #00ff88; border: 1px solid #00ff88;
            cursor: pointer; transition: all 0.2s;
        }
        .settings-close:hover { background: #00ff88; color: #000; }
        #perkChoice {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none; flex-direction: column;
            justify-content: center; align-items: center; z-index: 90; pointer-events: all;
        }
        #perkChoice.show { display: flex; }
        .perk-title { font-size: 28px; color: #ffdd00; text-shadow: 0 0 20px #ffdd00; margin-bottom: 25px; }
        .perk-cards { display: flex; gap: 20px; }
        .perk-card {
            width: 180px; padding: 20px 15px; background: rgba(0,255,136,0.05);
            border: 2px solid rgba(0,255,136,0.3); cursor: pointer; text-align: center;
            transition: all 0.2s; position: relative; overflow: hidden;
        }
        .perk-card:hover, .perk-card:active {
            border-color: #00ff88; background: rgba(0,255,136,0.15);
            box-shadow: 0 0 25px rgba(0,255,136,0.3); transform: translateY(-4px);
        }
        .perk-icon { font-size: 36px; margin-bottom: 10px; }
        .perk-name { font-size: 16px; font-weight: bold; color: #00ff88; margin-bottom: 6px; }
        .perk-desc { font-size: 12px; opacity: 0.7; line-height: 1.4; }
        @media (max-width: 420px) {
            .perk-cards { gap: 12px; }
            .perk-card { width: 140px; padding: 15px 10px; }
            .perk-icon { font-size: 28px; }
            .perk-name { font-size: 14px; }
            .perk-desc { font-size: 11px; }
            .perk-title { font-size: 22px; }
        }
        @media (max-width: 768px) {
            .title { font-size: 42px; }
            .game-over-title { font-size: 42px; }
            .hud { font-size: 14px; top: 10px; left: 10px; }
            .hud-right { font-size: 12px; top: 10px; right: 10px; }
        }
        @media (max-width: 420px) {
            .title { font-size: 32px; }
            .subtitle { font-size: 14px; }
            .game-over-title { font-size: 32px; }
            .high-score { font-size: 18px; }
            .start-btn { font-size: 20px; padding: 12px 30px; }
            .hud { font-size: 12px; top: 8px; left: 8px; max-width: 60%; }
            .hud-right { font-size: 10px; top: 8px; right: 8px; }
            .hud-bottom { font-size: 11px; bottom: 12px; }
            .controls { font-size: 12px; margin-top: 20px; }
            .info-section { padding: 15px; font-size: 13px; }
            .info-section h2 { font-size: 18px; }
            #pauseBtn { font-size: 14px; padding: 4px 10px; top: 10px; left: auto; right: 60px; transform: none; }
            #muteBtn { right: 10px !important; font-size: 14px !important; padding: 4px 8px !important; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="overlay">
        <div class="hud"><div id="scoreDisplay">TIME: 0.0s | GRAZE: 0</div></div>
        <div class="hud-right"><div>Iteration #59 ü•à</div><div>Grade: 99/100</div></div>
        <div class="hud-bottom" id="powerupHud"></div>
    </div>
    <div id="menu">
        <div class="title">NEON SURVIVE</div>
        <div class="subtitle">Self-Improving Game v59 ü•à Silver Milestone!</div>
        <div class="high-score" id="highScoreDisplay">HIGH SCORE: 0</div>
        <button class="start-btn" id="startBtn">START</button>
        <div class="controls">
            MOUSE / WASD / ARROW KEYS / TOUCH<br>
            SPACE / DOUBLE-TAP to DASH | F / THREE-TAP to BLAST<br>
            Dodge enemies. Graze for bonus points. Collect power-ups. Survive.
        </div>
        <button class="start-btn" id="dailyBtn" style="margin-top:12px;font-size:16px;padding:8px 20px;background:rgba(255,221,0,0.08);border-color:#ffdd00;color:#ffdd00;text-shadow:0 0 10px #ffdd00;" onclick="startDailyChallenge()">üéØ DAILY CHALLENGE</button>
        <div id="dailyInfo" style="font-size:12px;opacity:0.7;margin-top:6px;color:#ffdd00;text-align:center;line-height:1.5;"></div>
        <button class="start-btn" style="margin-top:12px;font-size:16px;padding:8px 20px;opacity:0.7" onclick="openSettings()">‚öô SETTINGS</button>
        <div style="margin-top:15px;font-size:28px;animation:pulse 2s infinite;text-shadow:0 0 20px #c0c0c0,0 0 40px #c0c0c0;color:#c0c0c0;">ü•à SILVER MILESTONE ‚Äî 59 Iterations!</div>
        <div style="margin-top:8px;font-size:14px;opacity:0.7;color:#ffd700;animation:pulse 3s infinite;">ü•á Gold at 100 ‚Äî <span style="color:#fff;font-weight:bold;">41 iterations to go!</span></div>
        <div id="pilotRank" style="margin-top:20px;font-size:14px;text-align:center;line-height:1.6;"></div>
        <div id="lifetimeStats" style="margin-top:10px;font-size:12px;opacity:0.5;text-align:center;line-height:1.8;"></div>
        <div id="achievementCount" style="margin-top:8px;font-size:12px;opacity:0.6;color:#ffdd00;text-align:center;"></div>
    </div>
    <button id="pauseBtn" onclick="togglePause()">‚ùö‚ùö PAUSE</button>
    <button id="muteBtn" onclick="toggleMute()" style="position:fixed;top:20px;right:120px;font-family:'Courier New',monospace;font-size:18px;background:transparent;color:#00ff88;border:1px solid rgba(0,255,136,0.3);padding:5px 10px;cursor:pointer;z-index:50;display:none;opacity:0.5;transition:opacity 0.2s;">üîä</button>
    <div id="pauseOverlay">
        <div class="pause-title">PAUSED</div>
        <button class="start-btn" onclick="togglePause()">RESUME</button>
        <button class="start-btn" style="margin-top:10px;font-size:16px;padding:8px 20px;opacity:0.7" onclick="openSettings()">‚öô SETTINGS</button>
        <div class="pause-hint">Press P or ESC to resume</div>
    </div>
    <div id="gameOver">
        <div class="game-over-title">GAME OVER</div>
        <div class="final-score" id="finalScore">SCORE: 0</div>
        <button class="start-btn" id="restartBtn">PLAY AGAIN</button>
        <div style="margin-top:12px;font-size:12px;opacity:0.4;">Press R / ENTER / SPACE to retry</div>
    </div>
    <div id="perkChoice">
        <div class="perk-title">‚¨Ü CHOOSE A PERK</div>
        <div class="perk-cards" id="perkCards"></div>
    </div>
    <div id="settingsPanel">
        <h2>‚öô SETTINGS</h2>
        <div class="setting-row"><label>CRT Scanlines</label><div class="setting-toggle on" id="toggleCRT" onclick="toggleSetting('crt')"></div></div>
        <div class="setting-row"><label>Screen Shake</label><div class="setting-toggle on" id="toggleShake" onclick="toggleSetting('shake')"></div></div>
        <div class="setting-row"><label>Particles</label><div class="setting-toggle on" id="toggleParticles" onclick="toggleSetting('particles')"></div></div>
        <div class="setting-row"><label>Volume</label><input type="range" min="0" max="100" id="volumeSlider" style="width:100px;accent-color:#00ff88;cursor:pointer;" oninput="setVolume(this.value)"><span id="volumeLabel" style="font-size:12px;opacity:0.6;min-width:30px;text-align:right;">80%</span></div>
        <button class="settings-close" onclick="closeSettings()">DONE</button>
    </div>
    <div class="info-section">
        <h2>About This Game</h2>
        <p>This is a <strong>self-improving autonomous game</strong>. Every 7 minutes, an AI agent evaluates the current version, grades it, and automatically generates improvements. The game evolves itself over time.</p>
        <p style="margin-top:10px;">You are playing <strong>Iteration #59</strong> ü•à <em>Silver Milestone!</em> Check back regularly to see how it transforms itself.</p>
        <p style="margin-top:10px;"><a href="https://game.theselfimprovingpage.com" target="_blank" style="color:#00ffff;">üï∞Ô∏è Explore the Time Machine</a> ‚Äî browse every version and see the evolution history.</p>
    </div>
    <div class="footer">
        Iteration #59 ü•à | Grade: 99/100 | Last Updated: <span id="timestamp"></span>
        <br><a href="https://game.theselfimprovingpage.com" target="_blank" style="color:#00ff88;opacity:0.7;text-decoration:underline;">üï∞Ô∏è Time Machine ‚Äî See how this game evolved</a>
    </div>
    <script>
    // ============================================
    // NEON SURVIVE ‚Äî Iteration 46 (Performance Audit)
    // ============================================
    // In-place array compaction ‚Äî avoids GC from .filter() in hot paths
    function compactInPlace(arr, predicate) {
        let write = 0;
        for (let i = 0; i < arr.length; i++) {
            if (predicate(arr[i])) { arr[write++] = arr[i]; }
        }
        arr.length = write;
    }
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    let WIDTH, HEIGHT;
    // Settings
    let settings = JSON.parse(localStorage.getItem('neonSurviveSettings') || '{"crt":true,"shake":true,"particles":true,"volume":80}');
    if (settings.volume === undefined) settings.volume = 80;
    let masterVolume = settings.volume / 100;
    function saveSettings() { localStorage.setItem('neonSurviveSettings', JSON.stringify(settings)); }
    function toggleSetting(key) {
        settings[key] = !settings[key]; saveSettings();
        document.getElementById('toggle' + key.charAt(0).toUpperCase() + key.slice(1)).classList.toggle('on', settings[key]);
    }
    function setVolume(val) { settings.volume = parseInt(val); masterVolume = settings.volume / 100; saveSettings(); document.getElementById('volumeLabel').textContent = val + '%'; }
    function openSettings() { document.getElementById('settingsPanel').classList.add('show'); document.getElementById('volumeSlider').value = settings.volume; document.getElementById('volumeLabel').textContent = settings.volume + '%'; }
    function closeSettings() { document.getElementById('settingsPanel').classList.remove('show'); }
    // Init toggles on load
    setTimeout(() => {
        ['crt','shake','particles'].forEach(k => {
            const el = document.getElementById('toggle' + k.charAt(0).toUpperCase() + k.slice(1));
            if (el) el.classList.toggle('on', settings[k]);
        });
    }, 0);

    // ============================================
    // DAILY CHALLENGE SYSTEM (Iteration 46)
    // ============================================
    function getDailySeed() {
        const d = new Date();
        return d.getFullYear() * 10000 + (d.getMonth() + 1) * 100 + d.getDate();
    }
    function seededRandom(seed) {
        let s = seed;
        return function() { s = (s * 1664525 + 1013904223) & 0xffffffff; return (s >>> 0) / 0xffffffff; };
    }
    const DAILY_MODIFIERS = [
        { id: 'speed_demons', name: '‚ö° Speed Demons', desc: 'Enemies move 50% faster', scoreBonus: 1.5,
          apply: () => { dailyMods.enemySpeedMult = 1.5; } },
        { id: 'glass_cannon', name: 'üíé Glass Cannon', desc: '3x score, tiny hitbox, faster enemies', scoreBonus: 3.0,
          apply: () => { dailyMods.scoreMult = 3.0; dailyMods.playerRadiusMult = 0.6; dailyMods.enemySpeedMult = 1.2; } },
        { id: 'swarm', name: 'üêù The Swarm', desc: '2x enemy count, smaller enemies', scoreBonus: 2.0,
          apply: () => { dailyMods.spawnRateMult = 2.0; dailyMods.enemyRadiusMult = 0.7; } },
        { id: 'giants', name: 'ü¶ï Giants', desc: 'Enemies are huge but slower', scoreBonus: 1.3,
          apply: () => { dailyMods.enemyRadiusMult = 1.8; dailyMods.enemySpeedMult = 0.7; } },
        { id: 'graze_frenzy', name: '‚ú® Graze Frenzy', desc: 'Graze zone 2x bigger, 2x graze points', scoreBonus: 1.2,
          apply: () => { dailyMods.grazeRangeMult = 2.0; dailyMods.grazePointsMult = 2.0; } },
        { id: 'no_powerups', name: 'üö´ Purist', desc: 'No power-ups spawn. Pure skill.', scoreBonus: 2.0,
          apply: () => { dailyMods.noPowerups = true; } },
        { id: 'bullet_hell', name: 'üî¥ Bullet Hell', desc: 'More burst enemies, tighter graze', scoreBonus: 2.5,
          apply: () => { dailyMods.burstChance = 0.6; dailyMods.grazeRangeMult = 0.7; } },
        { id: 'zen_mode', name: 'üßò Zen Mode', desc: 'Slower enemies, double combo timer', scoreBonus: 0.8,
          apply: () => { dailyMods.enemySpeedMult = 0.6; dailyMods.comboTimerMult = 2.0; } },
    ];
    let dailyChallengeActive = false;
    let dailyMods = {};
    function resetDailyMods() {
        dailyMods = { enemySpeedMult: 1, playerRadiusMult: 1, enemyRadiusMult: 1,
            spawnRateMult: 1, scoreMult: 1, grazeRangeMult: 1, grazePointsMult: 1,
            noPowerups: false, burstChance: -1, comboTimerMult: 1 };
    }
    resetDailyMods();
    function getTodaysChallenge() {
        const seed = getDailySeed();
        const rng = seededRandom(seed);
        const idx = Math.floor(rng() * DAILY_MODIFIERS.length);
        return DAILY_MODIFIERS[idx];
    }
    function getDailyChallengeKey() { return 'neonSurviveDaily_' + getDailySeed(); }
    function getDailyBest() { return parseInt(localStorage.getItem(getDailyChallengeKey()) || '0'); }
    function saveDailyBest(score) {
        const key = getDailyChallengeKey();
        if (score > getDailyBest()) localStorage.setItem(key, Math.floor(score));
    }
    function startDailyChallenge() {
        const challenge = getTodaysChallenge();
        resetDailyMods();
        dailyChallengeActive = true;
        challenge.apply();
        startGame();
    }

    // Perfect wave tracking
    let perfectWaveEligible = true; // reset each wave, lost if hit (but we don't have HP, so it's about grazes)

    let gameState = 'menu';
    let paused = false;
    let killCount = 0;
    let score = 0, grazeCount = 0, gameTime = 0, difficulty = 1;
    let highScore = localStorage.getItem('neonSurviveHighScore') || 0;
    let newHighScore = false;

    // Lifetime stats
    let lifetime = JSON.parse(localStorage.getItem('neonSurviveLifetime') || '{"games":0,"bestWave":0,"totalKills":0,"totalGrazes":0,"totalTime":0,"bestCombo":0}');
    function saveLifetime() { localStorage.setItem('neonSurviveLifetime', JSON.stringify(lifetime)); }

    // Hit freeze (game feel juice)
    let hitFreezeTimer = 0;

    // Wave progress bar
    // (rendered in render(), uses waveTimer/waveDuration)

    // Orb collection chain
    let orbChainCount = 0, orbChainTimer = 0;

    // Edge warnings
    let edgeWarnings = [];

    // Ambient beat
    let beatInterval = null, beatOsc = null, beatGain = null;

    // Cached vignette
    let cachedVignette = null, vignetteW = 0, vignetteH = 0;

    // Cached background gradient
    let cachedBgGrad = null, bgGradWave = -1, bgGradW = 0, bgGradH = 0, bgGradDying = false, bgGradFlow = 0;

    // Cached CRT scanline overlay
    let cachedScanlines = null, scanW = 0, scanH = 0;
    function buildScanlines() {
        if (scanW === WIDTH && scanH === HEIGHT && cachedScanlines) return;
        const oc = document.createElement('canvas');
        oc.width = WIDTH; oc.height = HEIGHT;
        const octx = oc.getContext('2d');
        octx.fillStyle = 'rgba(0,0,0,0.03)';
        for (let y = 0; y < HEIGHT; y += 4) octx.fillRect(0, y, WIDTH, 2);
        cachedScanlines = oc; scanW = WIDTH; scanH = HEIGHT;
    }

    // Cached danger border gradients
    let cachedDanger = { w: 0, h: 0, left: null, right: null, top: null, bottom: null };
    function buildDangerGradients() {
        if (cachedDanger.w === WIDTH && cachedDanger.h === HEIGHT) return;
        const dg = ctx.createLinearGradient(0, 0, 40, 0);
        dg.addColorStop(0, '#ff0044'); dg.addColorStop(1, 'transparent');
        const dg2 = ctx.createLinearGradient(WIDTH, 0, WIDTH-40, 0);
        dg2.addColorStop(0, '#ff0044'); dg2.addColorStop(1, 'transparent');
        const dg3 = ctx.createLinearGradient(0, 0, 0, 40);
        dg3.addColorStop(0, '#ff0044'); dg3.addColorStop(1, 'transparent');
        const dg4 = ctx.createLinearGradient(0, HEIGHT, 0, HEIGHT-40);
        dg4.addColorStop(0, '#ff0044'); dg4.addColorStop(1, 'transparent');
        cachedDanger = { w: WIDTH, h: HEIGHT, left: dg, right: dg2, top: dg3, bottom: dg4 };
    }

    // Danger border
    let dangerPulse = 0;

    // Mobile detection
    const isMobile = /Android|iPhone|iPad|iPod|webOS/i.test(navigator.userAgent) || window.innerWidth < 768;

    // Player
    let player = { x: 0, y: 0, vx: 0, vy: 0, radius: 12, baseRadius: 12, trail: [] };

    // Ghost Replay ‚Äî shows previous run's path as a faint ghost ship
    let ghostRecording = []; // current run recording: [{x,y,angle}]
    let ghostPlayback = JSON.parse(localStorage.getItem('neonSurviveGhost') || 'null'); // previous run
    let ghostFrame = 0;
    let ghostRecordTimer = 0;
    const GHOST_RECORD_INTERVAL = 1/15; // record 15fps to keep it lightweight

    // Dash
    let dash = { active: false, timer: 0, cooldown: 0, duration: 0.15, cooldownTime: 1.2, speed: 1200, invincible: false };
    let dashReadyFlash = 0; // visual flash when dash becomes available
    let lastTapTime = 0;

    // Entities
    let enemies = [], particles = [], stars = [], powerups = [];
    // Score orbs ‚Äî dropped by killed enemies
    let scoreOrbs = [];

    // Mini-boss system ‚Äî spawns every 5 waves
    let boss = null;
    function spawnBoss(bossWave) {
        const side = Math.floor(Math.random() * 4);
        let x, y;
        if (side === 0) { x = WIDTH / 2; y = -40; }
        else if (side === 1) { x = WIDTH + 40; y = HEIGHT / 2; }
        else if (side === 2) { x = WIDTH / 2; y = HEIGHT + 40; }
        else { x = -40; y = HEIGHT / 2; }
        const hp = 3 + Math.floor(bossWave / 5);
        boss = {
            x, y, radius: 28, color: '#ff2200', hp, maxHp: hp,
            vx: 0, vy: 0, speed: 30 + bossWave * 2, pulse: 0,
            shieldAngle: 0, flashTimer: 0, trail: []
        };
        waveAnnounce = '‚ö† BOSS INCOMING ‚ö†'; waveAnnounceTimer = 2.5;
        playSound(100, 0.4, 'sawtooth', 0.15);
        setTimeout(() => playSound(80, 0.5, 'sawtooth', 0.12), 200);
    }

    // Laser barriers ‚Äî rotating hazard lines from wave 4+
    let laserBarriers = [];
    function spawnLaserBarrier() {
        const cx = 80 + Math.random() * (WIDTH - 160);
        const cy = 80 + Math.random() * (HEIGHT - 160);
        const len = 120 + Math.random() * 100; // half-length
        const rotSpeed = (0.4 + Math.random() * 0.6) * (Math.random() > 0.5 ? 1 : -1);
        const lifetime = 6 + Math.random() * 4;
        laserBarriers.push({
            cx, cy, angle: Math.random() * Math.PI * 2,
            halfLen: len, rotSpeed, life: lifetime, maxLife: lifetime,
            warmup: 1.5, // warning phase before becoming lethal
            width: 3, color: '#ff2244'
        });
        // Warning sound
        if (!muted && audioCtx) {
            playSound(200, 0.3, 'sawtooth', 0.06);
            setTimeout(() => playSound(250, 0.2, 'sawtooth', 0.05), 150);
        }
    }

    // Floating text popups (score, combo, etc.)
    let floatingTexts = [];
    function spawnFloatingText(x, y, text, color = '#00ff88', size = 18, duration = 1.0) {
        floatingTexts.push({ x, y, text, color, size, duration, maxDuration: duration, vy: -80 - Math.random() * 30, vx: (Math.random() - 0.5) * 40 });
    }

    // Combo announcement system ‚Äî fighting game style
    let comboAnnounce = '', comboAnnounceTimer = 0, comboAnnounceColor = '#00ffff', comboAnnounceScale = 1;
    function getComboAnnouncement(combo) {
        if (combo >= 20) return { text: '‚ò†Ô∏è GODLIKE!', color: '#ff00ff', sound: 2000 };
        if (combo >= 15) return { text: 'üî• LEGENDARY!', color: '#ffdd00', sound: 1800 };
        if (combo >= 10) return { text: '‚ö° ULTRA!', color: '#ff8800', sound: 1600 };
        if (combo >= 7) return { text: 'üí• MEGA!', color: '#ff4400', sound: 1400 };
        if (combo >= 5) return { text: 'SUPER!', color: '#ffaa00', sound: 1200 };
        if (combo >= 3) return { text: 'TRIPLE!', color: '#00ffff', sound: 1000 };
        return null;
    }

    // Game history (last 5 games stored in localStorage)
    let gameHistory = JSON.parse(localStorage.getItem('neonSurviveHistory') || '[]');
    let sessionStreak = 0; // Games played this session
    let sessionBestScore = 0; // Best score this session

    // Input
    let keys = {}, mouse = { x: 0, y: 0, active: false }, touch = { x: 0, y: 0, active: false };

    // Timing
    let lastSpawn = 0, spawnInterval = 1000, lastPowerupSpawn = 0;

    // Effects
    let shakeAmount = 0, flashColor = null, flashAlpha = 0;
    // Kill streak
    let killStreak = 0, killStreakTimer = 0, killStreakAnnounce = '', killStreakAnnounceTimer = 0;
    // Ring explosions (wave clear, death)
    let rings = [];
    // Death slowmo
    let deathSlowmo = 0, deathSlowmoDuration = 1.2;

    // Near-death bullet time
    let bulletTime = 0, bulletTimeDuration = 0.12;
    let perfectDodgeCount = 0;
    let dangerProximity = 0; // 0-1, smoothed danger level based on nearest enemy

    // Proximity heartbeat
    let proximityBeatTimer = 0, lastProximityBeat = 0;

    // Death shards ‚Äî triangle fragments that spin away
    let deathShards = [];

    // Wave freeze ‚Äî brief pause on wave clear for impact
    let waveFreezeTimer = 0;

    // Flow Zone ‚Äî visual transformation on high combo streaks
    let flowZoneIntensity = 0; // 0-1, smoothly interpolated
    let flowZoneHueShift = 0; // animated hue rotation during flow

    // Atmospheric particles ‚Äî wave-themed ambient weather
    let atmosphere = [];
    const ATMO_MAX = 30;
    function spawnAtmoParticle() {
        const w = wave || 1;
        let color, size, vx, vy, life, glow;
        if (w <= 2) { // Gentle dust motes ‚Äî calm early game
            color = 'rgba(100,200,255,0.25)'; size = 1 + Math.random() * 1.5;
            vx = (Math.random() - 0.5) * 8; vy = -5 - Math.random() * 10; life = 4 + Math.random() * 3; glow = 0;
        } else if (w <= 5) { // Drifting embers ‚Äî heating up
            color = `rgba(255,${100 + Math.random()*80|0},30,0.35)`; size = 1 + Math.random() * 2;
            vx = (Math.random() - 0.5) * 15; vy = -15 - Math.random() * 20; life = 2.5 + Math.random() * 2; glow = 4;
        } else if (w <= 8) { // Hot sparks ‚Äî intense
            color = `rgba(255,${180 + Math.random()*75|0},50,0.4)`; size = 0.8 + Math.random() * 1.5;
            vx = (Math.random() - 0.5) * 25; vy = -20 - Math.random() * 30; life = 1.5 + Math.random() * 2; glow = 6;
        } else { // Falling ash + sparks ‚Äî apocalyptic
            const isSpark = Math.random() < 0.3;
            color = isSpark ? `rgba(255,${200+Math.random()*55|0},100,0.5)` : 'rgba(180,180,180,0.15)';
            size = isSpark ? 1 + Math.random() : 1.5 + Math.random() * 2;
            vx = (Math.random() - 0.5) * 20; vy = isSpark ? -25 - Math.random() * 20 : 8 + Math.random() * 12;
            life = isSpark ? 1 + Math.random() * 1.5 : 3 + Math.random() * 3; glow = isSpark ? 8 : 0;
        }
        atmosphere.push({
            x: Math.random() * WIDTH, y: vy > 0 ? -5 : HEIGHT + 5,
            vx, vy, size, color, life, maxLife: life, glow, wave: w
        });
    }

    // Gravity Wells ‚Äî environmental hazards that pull the player
    let gravityWells = [];
    let gravityWellTimer = 0;
    const GRAVITY_WELL_MIN_INTERVAL = 10; // seconds between spawns
    const GRAVITY_WELL_MAX_INTERVAL = 18;

    // Persistent XP/Level system
    let xpData = JSON.parse(localStorage.getItem('neonSurviveXP') || '{"xp":0,"level":1,"totalXP":0}');
    function xpForLevel(lvl) { return Math.floor(80 * Math.pow(1.4, lvl - 1)); }
    function addXP(amount) {
        xpData.xp += amount; xpData.totalXP += amount;
        while (xpData.xp >= xpForLevel(xpData.level)) {
            xpData.xp -= xpForLevel(xpData.level);
            xpData.level++;
            levelUpPending = true;
        }
        localStorage.setItem('neonSurviveXP', JSON.stringify(xpData));
    }
    let levelUpPending = false;
    // Ship colors unlocked by level
    function getShipColor(level) {
        if (level >= 20) return '#ff00ff'; // magenta
        if (level >= 15) return '#ffdd00'; // gold
        if (level >= 10) return '#ff8800'; // orange
        if (level >= 7) return '#00ffff';  // cyan
        if (level >= 4) return '#88ff00';  // lime
        return '#00ff88'; // default green
    }
    function getShipName(level) {
        if (level >= 20) return 'VOID PHANTOM';
        if (level >= 15) return 'GOLDEN ACE';
        if (level >= 10) return 'SOLAR FLARE';
        if (level >= 7) return 'ICE RUNNER';
        if (level >= 4) return 'LIME STREAK';
        return 'NEON PILOT';
    }

    // ============================================
    // ACHIEVEMENTS SYSTEM
    // ============================================
    const ACHIEVEMENTS = [
        { id: 'first_graze', name: 'Close Shave', desc: 'Get your first graze', icon: '‚ú®', check: (s) => s.grazeCount >= 1 },
        { id: 'graze_10', name: 'Thrill Seeker', desc: 'Graze 10 enemies in one game', icon: 'üí´', check: (s) => s.grazeCount >= 10 },
        { id: 'graze_50', name: 'Death Dancer', desc: 'Graze 50 enemies in one game', icon: 'üåü', check: (s) => s.grazeCount >= 50 },
        { id: 'combo_5', name: 'Combo Starter', desc: 'Reach a 5x graze combo', icon: 'üî•', check: (s) => s.comboBest >= 5 },
        { id: 'combo_10', name: 'Combo Master', desc: 'Reach a 10x graze combo', icon: '‚ö°', check: (s) => s.comboBest >= 10 },
        { id: 'combo_20', name: 'Combo Legend', desc: 'Reach a 20x graze combo', icon: 'üëë', check: (s) => s.comboBest >= 20 },
        { id: 'wave_3', name: 'Warming Up', desc: 'Survive to wave 3', icon: 'üåä', check: (s) => s.wave >= 3 },
        { id: 'wave_5', name: 'Proven Pilot', desc: 'Survive to wave 5', icon: 'üõ∏', check: (s) => s.wave >= 5 },
        { id: 'wave_10', name: 'Elite Survivor', desc: 'Survive to wave 10', icon: 'üèÜ', check: (s) => s.wave >= 10 },
        { id: 'kill_boss', name: 'Boss Slayer', desc: 'Defeat a boss', icon: 'üíÄ', check: (s) => s.bossKilled },
        { id: 'kill_10', name: 'Hunter', desc: 'Kill 10 enemies in one game', icon: 'üéØ', check: (s) => s.killCount >= 10 },
        { id: 'score_1000', name: 'Four Digits', desc: 'Score 1,000 points', icon: 'üìä', check: (s) => s.score >= 1000 },
        { id: 'score_5000', name: 'High Roller', desc: 'Score 5,000 points', icon: 'üíé', check: (s) => s.score >= 5000 },
        { id: 'dash_kill', name: 'Dash Strike', desc: 'Kill an enemy by dashing', icon: 'üí®', check: (s) => s.dashKill },
        { id: 'survive_60', name: 'Minute Man', desc: 'Survive 60 seconds', icon: '‚è±', check: (s) => s.gameTime >= 60 },
        { id: 'survive_180', name: 'Endurance', desc: 'Survive 3 minutes', icon: 'üïê', check: (s) => s.gameTime >= 180 },
        { id: 'level_5', name: 'Rank Up', desc: 'Reach pilot level 5', icon: 'üéñ', check: (s) => s.level >= 5 },
        { id: 'level_10', name: 'Veteran', desc: 'Reach pilot level 10', icon: 'üèÖ', check: (s) => s.level >= 10 },
        { id: 'games_10', name: 'Dedicated', desc: 'Play 10 games', icon: 'üéÆ', check: (s) => s.totalGames >= 10 },
        { id: 'powerup_all', name: 'Fully Loaded', desc: 'Collect all 3 power-up types in one game', icon: 'üß™', check: (s) => s.powerupsCollected && s.powerupsCollected.shield && s.powerupsCollected.slowmo && s.powerupsCollected.magnet },
    ];
    let unlockedAchievements = JSON.parse(localStorage.getItem('neonSurviveAchievements') || '[]');
    let achievementToasts = [];
    let sessionPowerupsCollected = {};
    let sessionBossKilled = false;
    let sessionDashKill = false;

    function checkAchievements() {
        const state = {
            grazeCount, comboBest, wave, killCount, score, gameTime,
            bossKilled: sessionBossKilled, dashKill: sessionDashKill,
            level: xpData.level, totalGames: lifetime.games,
            powerupsCollected: sessionPowerupsCollected
        };
        let newUnlocks = 0;
        ACHIEVEMENTS.forEach(a => {
            if (unlockedAchievements.includes(a.id)) return;
            if (a.check(state)) {
                unlockedAchievements.push(a.id);
                newUnlocks++;
                // Queue toast
                achievementToasts.push({ icon: a.icon, name: a.name, desc: a.desc, timer: 3.5, fadeIn: 0 });
                // Play achievement sound
                if (!muted && audioCtx) {
                    playSound(880, 0.1, 'sine', 0.08);
                    setTimeout(() => playSound(1100, 0.1, 'sine', 0.08), 80);
                    setTimeout(() => playSound(1320, 0.15, 'sine', 0.1), 160);
                }
            }
        });
        if (newUnlocks > 0) localStorage.setItem('neonSurviveAchievements', JSON.stringify(unlockedAchievements));
    }

    function renderAchievementToasts(ctx) {
        const toastH = 50, toastW = 260, padding = 10, startY = 70;
        achievementToasts.forEach((t, i) => {
            t.fadeIn = Math.min(1, t.fadeIn + 0.05);
            const alpha = t.timer > 0.5 ? t.fadeIn : t.timer * 2;
            const y = startY + i * (toastH + 8);
            const x = WIDTH - toastW - padding;
            ctx.save();
            ctx.globalAlpha = alpha * 0.9;
            // Background
            ctx.fillStyle = 'rgba(0,0,0,0.85)';
            ctx.strokeStyle = '#ffdd00';
            ctx.lineWidth = 1.5;
            const r = 8;
            ctx.beginPath();
            ctx.moveTo(x + r, y); ctx.lineTo(x + toastW - r, y);
            ctx.arcTo(x + toastW, y, x + toastW, y + r, r);
            ctx.lineTo(x + toastW, y + toastH - r);
            ctx.arcTo(x + toastW, y + toastH, x + toastW - r, y + toastH, r);
            ctx.lineTo(x + r, y + toastH);
            ctx.arcTo(x, y + toastH, x, y + toastH - r, r);
            ctx.lineTo(x, y + r);
            ctx.arcTo(x, y, x + r, y, r);
            ctx.closePath();
            ctx.fill(); ctx.stroke();
            // Gold glow
            ctx.shadowColor = '#ffdd00'; ctx.shadowBlur = 10;
            ctx.stroke();
            ctx.shadowBlur = 0;
            // Icon
            ctx.font = '22px serif';
            ctx.fillStyle = '#fff';
            ctx.fillText(t.icon, x + 12, y + 33);
            // Text
            ctx.font = 'bold 13px "Courier New", monospace';
            ctx.fillStyle = '#ffdd00';
            ctx.fillText(t.name, x + 42, y + 20);
            ctx.font = '11px "Courier New", monospace';
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.fillText(t.desc, x + 42, y + 37);
            ctx.restore();
        });
    }

    function updateAchievementToasts(dt) {
        achievementToasts.forEach(t => t.timer -= dt);
        compactInPlace(achievementToasts, t => t.timer > 0);
    }

    // ============================================
    // PERK CHOICE SYSTEM ‚Äî Roguelite wave rewards
    // ============================================
    const PERKS = [
        { id: 'speed', icon: '‚ö°', name: 'Swift', desc: '+15% move speed (stacks)', apply: () => { player.speed *= 1.15; } },
        { id: 'shield', icon: 'üõ°', name: 'Barrier', desc: 'Shield for 6 seconds', apply: () => { activePowerups.shield = Math.max(activePowerups.shield, 6); } },
        { id: 'magnet', icon: 'üß≤', name: 'Magnetism', desc: 'Attract orbs for 8s', apply: () => { activePowerups.magnet = Math.max(activePowerups.magnet, 8); } },
        { id: 'score_mult', icon: 'üíé', name: 'Jackpot', desc: 'Score x2 for 10s', apply: () => { scoreMult = Math.min(MULT_MAX, scoreMult + 1); } },
        { id: 'tiny', icon: 'üî¨', name: 'Shrink', desc: 'Smaller hitbox for 8s', apply: () => { activePowerups.tiny = Math.max(activePowerups.tiny||0, 8); if(!player.shrunk){player.shrunk=true; player.radius *= 0.7;} } },
        { id: 'graze_range', icon: 'üåÄ', name: 'Aura', desc: 'Wider graze zone for 10s', apply: () => { activePowerups.aura = Math.max(activePowerups.aura||0, 10); grazeExpand = 1.5; } },
        { id: 'dash_reset', icon: 'üí®', name: 'Quick Dash', desc: 'Instant dash cooldown reset', apply: () => { player.dashCooldown = 0; } },
        { id: 'slow_enemies', icon: 'üïê', name: 'Time Warp', desc: 'Enemies slowed 30% for 8s', apply: () => { activePowerups.slowmo = Math.max(activePowerups.slowmo, 8); } },
        { id: 'heal_combo', icon: 'üî•', name: 'Hot Streak', desc: 'Start with 5x combo', apply: () => { comboCount = Math.max(comboCount, 5); comboTimer = 3; } },
        { id: 'orb_shower', icon: '‚ú®', name: 'Orb Rain', desc: 'Spawn 8 bonus score orbs', apply: () => { for(let i=0;i<8;i++) scoreOrbs.push({ x:Math.random()*WIDTH, y:Math.random()*HEIGHT, vx:(Math.random()-0.5)*60, vy:(Math.random()-0.5)*60, life:6, value:50+wave*10 }); } },
    ];
    let grazeExpand = 1; // multiplier for graze detection radius
    let perkChoiceActive = false;
    let perkWaveThreshold = 2; // offer perks every 2 waves starting wave 2

    function offerPerkChoice() {
        perkChoiceActive = true;
        paused = true;
        const available = PERKS.slice();
        // Pick 2 random distinct perks
        const idx1 = Math.floor(Math.random() * available.length);
        const p1 = available.splice(idx1, 1)[0];
        const idx2 = Math.floor(Math.random() * available.length);
        const p2 = available[idx2];
        const container = document.getElementById('perkCards');
        container.innerHTML = '';
        [p1, p2].forEach(perk => {
            const card = document.createElement('div');
            card.className = 'perk-card';
            card.innerHTML = `<div class="perk-icon">${perk.icon}</div><div class="perk-name">${perk.name}</div><div class="perk-desc">${perk.desc}</div>`;
            card.onclick = () => selectPerk(perk);
            card.ontouchend = (e) => { e.preventDefault(); selectPerk(perk); };
            container.appendChild(card);
        });
        document.getElementById('perkChoice').classList.add('show');
    }

    function selectPerk(perk) {
        perk.apply();
        perkChoiceActive = false;
        paused = false;
        document.getElementById('perkChoice').classList.remove('show');
        // Feedback
        spawnFloatingText(WIDTH/2, HEIGHT/2, `${perk.icon} ${perk.name}!`, '#ffdd00', 20, 2);
        flashColor = '#ffdd00'; flashAlpha = 0.25;
        playSound(880, 0.15, 'sine', 0.1);
        setTimeout(() => playSound(1320, 0.15, 'sine', 0.08), 80);
    }

    // Dash afterimages
    let dashAfterimages = [];

    // Nebula clouds ‚Äî procedural drifting background patches
    let nebulae = [];
    // Nebula color palettes per difficulty tier ‚Äî atmosphere shifts as danger rises
    const nebulaPalettes = [
        ['rgba(0,100,255,', 'rgba(60,0,200,', 'rgba(0,180,120,', 'rgba(40,80,200,'],   // calm (wave 1-2)
        ['rgba(0,120,255,', 'rgba(100,0,220,', 'rgba(0,160,180,', 'rgba(80,40,200,'],   // medium (wave 3-4)
        ['rgba(200,100,0,', 'rgba(180,0,150,', 'rgba(160,80,0,', 'rgba(220,60,40,'],     // hard (wave 5-6)
        ['rgba(255,60,0,', 'rgba(200,0,100,', 'rgba(255,120,0,', 'rgba(180,20,60,'],     // insane (wave 7-9)
        ['rgba(255,0,20,', 'rgba(200,0,60,', 'rgba(180,0,0,', 'rgba(255,30,80,'],        // nightmare (wave 10+)
    ];
    let nebulaTargetPalette = 0, nebulaPaletteBlend = 0;
    function getNebulaPaletteIndex(w) {
        if (w <= 2) return 0; if (w <= 4) return 1; if (w <= 6) return 2; if (w <= 9) return 3; return 4;
    }
    function initNebulae() {
        const colors = nebulaPalettes[0];
        for (let i = 0; i < 5; i++) {
            nebulae.push({
                x: Math.random() * 2000 - 500, y: Math.random() * 2000 - 500,
                radius: 150 + Math.random() * 250,
                color: colors[Math.floor(Math.random() * colors.length)],
                colorIdx: Math.floor(Math.random() * colors.length),
                vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                phase: Math.random() * Math.PI * 2
            });
        }
    }
    let lastNebulaPaletteIdx = 0;
    function updateNebulae(dt) {
        nebulae.forEach(n => {
            n.x += n.vx * dt; n.y += n.vy * dt; n.phase += dt * 0.3;
            if (n.x < -n.radius * 2) n.x = WIDTH + n.radius;
            if (n.x > WIDTH + n.radius * 2) n.x = -n.radius;
            if (n.y < -n.radius * 2) n.y = HEIGHT + n.radius;
            if (n.y > HEIGHT + n.radius * 2) n.y = -n.radius;
        });
        // Shift nebula palette based on current wave
        const palIdx = getNebulaPaletteIndex(wave);
        if (palIdx !== lastNebulaPaletteIdx) {
            lastNebulaPaletteIdx = palIdx;
            const palette = nebulaPalettes[palIdx];
            nebulae.forEach(n => { n.color = palette[n.colorIdx % palette.length]; });
            buildNebulaCanvases(); // rebuild with new colors
        }
    }
    // Pre-rendered nebula canvases (avoid per-frame createRadialGradient)
    let nebulaCanvases = [];
    function buildNebulaCanvases() {
        nebulaCanvases = nebulae.map(n => {
            const size = Math.ceil((n.radius + 25) * 2);
            const oc = document.createElement('canvas');
            oc.width = size; oc.height = size;
            const octx = oc.getContext('2d');
            const cx = size / 2, cy = size / 2;
            const grad = octx.createRadialGradient(cx, cy, 0, cx, cy, size / 2);
            grad.addColorStop(0, n.color + '0.03)');
            grad.addColorStop(0.5, n.color + '0.015)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            octx.fillStyle = grad;
            octx.fillRect(0, 0, size, size);
            return oc;
        });
    }
    function renderNebulae() {
        nebulae.forEach((n, i) => {
            if (!nebulaCanvases[i]) return;
            const pulseScale = 1 + Math.sin(n.phase) * 0.08;
            const alpha = 0.6 + Math.sin(n.phase) * 0.3;
            ctx.globalAlpha = alpha;
            const oc = nebulaCanvases[i];
            const w = oc.width * pulseScale, h = oc.height * pulseScale;
            ctx.drawImage(oc, n.x - w/2, n.y - h/2, w, h);
        });
        ctx.globalAlpha = 1;
    }

    // Attract mode (menu background)
    let attractEnemies = [];
    function updateAttractMode(dt) {
        if (Math.random() < dt * 1.5) {
            const side = Math.floor(Math.random() * 4);
            let x, y, vx, vy;
            const sp = 60 + Math.random() * 100;
            if (side === 0) { x = Math.random() * WIDTH; y = -15; vx = (Math.random()-0.5)*80; vy = sp; }
            else if (side === 1) { x = WIDTH+15; y = Math.random() * HEIGHT; vx = -sp; vy = (Math.random()-0.5)*80; }
            else if (side === 2) { x = Math.random() * WIDTH; y = HEIGHT+15; vx = (Math.random()-0.5)*80; vy = -sp; }
            else { x = -15; y = Math.random() * HEIGHT; vx = sp; vy = (Math.random()-0.5)*80; }
            const colors = ['#ff0044','#ffaa00','#ff00ff','#00aaff'];
            attractEnemies.push({ x, y, vx, vy, radius: 5+Math.random()*6, color: colors[Math.floor(Math.random()*4)], trail: [] });
        }
        attractEnemies.forEach(e => {
            e.x += e.vx * dt; e.y += e.vy * dt;
            e.trail.push({ x: e.x, y: e.y, life: 1 });
            if (e.trail.length > 6) e.trail.shift();
            e.trail.forEach(t => t.life -= 0.15);
        });
        compactInPlace(attractEnemies, e => e.x > -50 && e.x < WIDTH+50 && e.y > -50 && e.y < HEIGHT+50);
    }
    function renderAttractMode() {
        attractEnemies.forEach(e => {
            e.trail.forEach(t => {
                if (t.life > 0) { ctx.globalAlpha = t.life * 0.15; ctx.fillStyle = e.color; ctx.beginPath(); ctx.arc(t.x, t.y, e.radius * t.life * 0.5, 0, Math.PI*2); ctx.fill(); }
            });
            ctx.globalAlpha = 0.3; ctx.fillStyle = e.color; ctx.shadowBlur = 10; ctx.shadowColor = e.color;
            ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
        });
        ctx.globalAlpha = 1;
    }

    // Difficulty tier names
    function getDifficultyTier(wave) {
        if (wave <= 2) return { name: 'EASY', color: '#00ff88' };
        if (wave <= 4) return { name: 'MEDIUM', color: '#00aaff' };
        if (wave <= 6) return { name: 'HARD', color: '#ffaa00' };
        if (wave <= 9) return { name: 'INSANE', color: '#ff4400' };
        return { name: 'NIGHTMARE', color: '#ff0044' };
    }

    // Death tips based on stats
    function getDeathTip(wave, grazeCount, comboBest, killCount, gameTime) {
        if (wave <= 1 && gameTime < 10) return "üí° Tip: Use WASD/mouse to move. Get close to enemies without touching to GRAZE for points!";
        if (grazeCount < 3 && wave <= 2) return "üí° Tip: Fly close to enemies to graze them ‚Äî it's risky but earns big points and combos!";
        if (comboBest < 3 && wave >= 3) return "üí° Tip: Chain grazes within 2s for combo multipliers. The closer the graze, the more dramatic!";
        if (killCount === 0 && wave >= 2) return "üí° Tip: Dash through enemies (SPACE/double-tap) or use Shield power-ups to destroy them!";
        if (wave >= 5) return "üí° Tip: Watch for sniper laser sights! Move perpendicular to the beam to dodge.";
        if (wave >= 3) return "üí° Tip: Purple burst enemies explode into 4 projectiles ‚Äî keep your distance!";
        return "üí° Tip: Collect power-ups during wave breaks for an edge in the next wave.";
    }

    // Performance rank system
    function getPerformanceRank(wave, score, grazes, comboBest, kills) {
        let pts = 0;
        pts += Math.min(40, wave * 5);           // waves survived (max 40)
        pts += Math.min(25, score / 200);         // score (max 25)
        pts += Math.min(15, grazes * 1.5);        // grazing skill (max 15)
        pts += Math.min(10, comboBest * 2);       // combo mastery (max 10)
        pts += Math.min(10, kills * 1);            // kills (max 10)
        if (pts >= 90) return { rank: 'S', color: '#ffdd00', glow: '#ffdd00' };
        if (pts >= 75) return { rank: 'A', color: '#00ff88', glow: '#00ff88' };
        if (pts >= 55) return { rank: 'B', color: '#00aaff', glow: '#00aaff' };
        if (pts >= 35) return { rank: 'C', color: '#ffaa00', glow: '#ffaa00' };
        if (pts >= 20) return { rank: 'D', color: '#ff6600', glow: '#ff6600' };
        return { rank: 'F', color: '#ff0044', glow: '#ff0044' };
    }

    // Speed lines during dash
    let speedLines = [];
    function spawnSpeedLines() {
        for (let i = 0; i < 5; i++) {
            const angle = Math.atan2(player.vy, player.vx) + Math.PI + (Math.random()-0.5)*0.8;
            speedLines.push({
                x: player.x + (Math.random()-0.5)*30,
                y: player.y + (Math.random()-0.5)*30,
                angle, length: 20 + Math.random()*40, life: 0.2 + Math.random()*0.15, decay: 0.04
            });
        }
    }

    // Wave system
    let wave = 1, waveTimer = 0, waveDuration = 8, waveBreak = false, waveBreakTimer = 0, waveBreakDuration = 2;
    let waveAnnounce = '', waveAnnounceTimer = 0;
    let waveKills = 0, waveGrazes = 0; // per-wave stats
    let waveBreakStats = null; // {kills, grazes, wave} shown during break
    let beatPulse = 0; // 0-1 pulse synced to beat timing

    // Combo system
    let comboCount = 0, comboTimer = 0, comboBest = 0;

    // Score multiplier ‚Äî builds with activity, decays when idle
    let scoreMult = 1, scoreMultTarget = 1, scoreMultDecayTimer = 0;
    const MULT_DECAY_DELAY = 3; // seconds of no activity before decay starts
    const MULT_MAX = 5;
    let scoreMultPulse = 0; // visual pulse when multiplier increases

    // Active power-ups
    let activePowerups = { shield: 0, slowmo: 0, magnet: 0 };

    // Audio
    let audioCtx = null;
    function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

    function playSound(freq, duration, type = 'sine', volume = 0.1) {
        if (!audioCtx || muted) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.value = volume * masterVolume;
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + duration);
    }

    // Ambient beat system
    let beatBPM = 80, beatPlaying = false;
    let beatCount = 0;
    // Adaptive music: kick + hi-hat + bassline that intensifies with wave
    function playHiHat() {
        if (!audioCtx || muted) return;
        const bufSize = audioCtx.sampleRate * 0.05;
        const buf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufSize, 8);
        const src = audioCtx.createBufferSource();
        const filt = audioCtx.createBiquadFilter();
        const g = audioCtx.createGain();
        src.buffer = buf;
        filt.type = 'highpass'; filt.frequency.value = 7000;
        g.gain.value = 0.04 * masterVolume;
        src.connect(filt); filt.connect(g); g.connect(audioCtx.destination);
        src.start();
    }
    function playBassNote(noteIdx) {
        if (!audioCtx || muted) return;
        // Pentatonic bass: E1, G1, A1, B1, D2
        const notes = [41.2, 49.0, 55.0, 61.7, 73.4];
        const freq = notes[noteIdx % notes.length];
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        const vol = 0.06 * masterVolume;
        g.gain.setValueAtTime(vol, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.3);
    }
    function startBeat() {
        if (!audioCtx || beatPlaying) return;
        beatPlaying = true;
        beatCount = 0;
        function scheduleBeat() {
            if (!beatPlaying) return;
            const bpm = beatBPM + (wave - 1) * 8;
            const interval = 60000 / bpm;
            // Kick on every beat
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(80, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.12);
            gain.gain.setValueAtTime(0.08 * masterVolume, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.2);
            // Hi-hat on off-beats (wave 2+)
            if (wave >= 2 && beatCount % 2 === 1) playHiHat();
            // Bassline from wave 3+ (plays every 2nd beat in a 4-note pattern)
            if (wave >= 3 && beatCount % 2 === 0) playBassNote(Math.floor(beatCount / 2) % 5);
            // Extra hi-hat on every beat at wave 5+ for intensity
            if (wave >= 5 && beatCount % 2 === 0) setTimeout(() => { if (beatPlaying) playHiHat(); }, interval * 0.5);
            beatPulse = 1;
            beatCount++;
            beatInterval = setTimeout(scheduleBeat, interval);
        }
        scheduleBeat();
    }
    function stopBeat() { beatPlaying = false; beatCount = 0; if (beatInterval) clearTimeout(beatInterval); }

    // Dash sound ‚Äî whoosh
    function playDashSound() {
        if (!audioCtx || muted) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(300, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.15);
        gain.gain.setValueAtTime(0.15 * masterVolume, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.2);
    }

    // Power-up pickup sound
    function playPowerupSound() {
        playSound(800, 0.1, 'sine', 0.15);
        setTimeout(() => playSound(1200, 0.1, 'sine', 0.12), 60);
        setTimeout(() => playSound(1600, 0.15, 'sine', 0.1), 120);
    }

    // Dramatic death explosion sound
    function playDeathSound() {
        if (!audioCtx) return;
        // Low rumble
        const osc1 = audioCtx.createOscillator();
        const g1 = audioCtx.createGain();
        osc1.type = 'sawtooth';
        osc1.frequency.setValueAtTime(80, audioCtx.currentTime);
        osc1.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.8);
        g1.gain.setValueAtTime(0.2 * masterVolume, audioCtx.currentTime);
        g1.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);
        osc1.connect(g1); g1.connect(audioCtx.destination);
        osc1.start(); osc1.stop(audioCtx.currentTime + 0.9);
        // Noise burst
        const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/data.length, 2);
        const noise = audioCtx.createBufferSource();
        const g2 = audioCtx.createGain();
        noise.buffer = buf;
        g2.gain.setValueAtTime(0.15 * masterVolume, audioCtx.currentTime);
        g2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
        noise.connect(g2); g2.connect(audioCtx.destination);
        noise.start();
        // Descending tone
        setTimeout(() => { playSound(400, 0.4, 'sine', 0.1); }, 200);
        setTimeout(() => { playSound(200, 0.5, 'sine', 0.08); }, 400);
    }

    // Graze streak sound ‚Äî pentatonic arpeggio that rises with combo
    const PENTATONIC = [1, 9/8, 5/4, 3/2, 5/3, 2]; // C pentatonic ratios
    function playGrazeStreakSound(combo) {
        if (!audioCtx || muted) return;
        const noteIdx = (combo - 1) % PENTATONIC.length;
        const octave = Math.floor((combo - 1) / PENTATONIC.length);
        const baseFreq = 523.25 * PENTATONIC[noteIdx] * Math.pow(2, Math.min(octave, 2)); // C5 base, up to 2 octaves
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = combo >= 10 ? 'triangle' : 'sine';
        osc.frequency.setValueAtTime(baseFreq, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.15, audioCtx.currentTime + 0.1);
        const vol = Math.min(0.15, 0.06 + combo * 0.008) * masterVolume;
        g.gain.setValueAtTime(vol, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.18);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.22);
        // Harmony note on high combos
        if (combo >= 5) {
            const osc2 = audioCtx.createOscillator();
            const g2 = audioCtx.createGain();
            osc2.type = 'sine';
            osc2.frequency.setValueAtTime(baseFreq * 1.5, audioCtx.currentTime + 0.03);
            g2.gain.setValueAtTime(vol * 0.4, audioCtx.currentTime + 0.03);
            g2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
            osc2.connect(g2); g2.connect(audioCtx.destination);
            osc2.start(audioCtx.currentTime + 0.03); osc2.stop(audioCtx.currentTime + 0.2);
        }
    }

    // Proximity heartbeat sound ‚Äî low thump when enemies are close
    function playProximityBeat(closeness) {
        if (!audioCtx || muted) return;
        const vol = 0.03 + closeness * 0.08;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(55, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.12);
        g.gain.setValueAtTime(vol * masterVolume, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.2);
    }

    // Wall spark sound
    function playVortexSound() {
        if (!audioCtx || muted) return;
        // Deep warping drone
        const o = audioCtx.createOscillator(), g = audioCtx.createGain();
        o.type = 'sawtooth';
        o.frequency.setValueAtTime(80, audioCtx.currentTime);
        o.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime + 0.8);
        g.gain.setValueAtTime(0.08 * masterVolume, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1);
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); o.stop(audioCtx.currentTime + 1);
    }

    function playWallSparkSound() {
        if (!audioCtx || muted) return;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(1200, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.06);
        g.gain.setValueAtTime(0.04 * masterVolume, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.06);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.08);
    }

    // Orb collect sound ‚Äî short sparkle
    function playOrbCollectSound() {
        if (!audioCtx || muted) return;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(900 + Math.random() * 400, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1800, audioCtx.currentTime + 0.06);
        g.gain.setValueAtTime(0.05 * masterVolume, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.1);
    }

    // Wave clear fanfare
    function playWaveClearSound() {
        if (!audioCtx) return;
        const notes = [523, 659, 784, 1047]; // C5 E5 G5 C6
        notes.forEach((f, i) => {
            setTimeout(() => playSound(f, 0.25, 'sine', 0.1), i * 80);
        });
    }

    // Bass drone ‚Äî sustained tension note that increases with wave
    let bassDrone = [], bassDroneGain = null;
    const droneNotes = [55, 61.74, 73.42, 82.41, 98, 110]; // A1 pentatonic rising tension
    function startBassDrone() {
        if (!audioCtx || bassDrone.length) return;
        bassDroneGain = audioCtx.createGain();
        bassDroneGain.gain.value = 0;
        bassDroneGain.gain.linearRampToValueAtTime(0.03 * masterVolume, audioCtx.currentTime + 1.5);
        bassDroneGain.connect(audioCtx.destination);
        // Two detuned oscillators for rich pad + sub-bass
        [0, 6, -6].forEach((det, i) => {
            const osc = audioCtx.createOscillator();
            osc.type = i < 2 ? 'sine' : 'triangle';
            osc.frequency.value = i < 2 ? 55 : 27.5;
            osc.detune.value = det;
            osc.connect(bassDroneGain);
            osc.start();
            bassDrone.push(osc);
        });
    }
    function updateBassDrone(w) {
        if (!bassDrone.length || !bassDroneGain || !audioCtx) return;
        const noteIdx = Math.min(Math.floor((w - 1) / 2), droneNotes.length - 1);
        const freq = droneNotes[noteIdx];
        const t = audioCtx.currentTime;
        bassDrone[0].frequency.linearRampToValueAtTime(freq, t + 1.5);
        bassDrone[1].frequency.linearRampToValueAtTime(freq, t + 1.5);
        bassDrone[2].frequency.linearRampToValueAtTime(freq / 2, t + 1.5);
        const vol = Math.min(0.03 + w * 0.004, 0.06) * masterVolume;
        bassDroneGain.gain.linearRampToValueAtTime(vol, t + 1);
    }
    function stopBassDrone() {
        if (bassDrone.length) {
            if (bassDroneGain && audioCtx) bassDroneGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.4);
            setTimeout(() => { bassDrone.forEach(o => { try { o.stop(); } catch(e){} }); bassDrone = []; bassDroneGain = null; }, 500);
        }
    }

    // Arpeggio melody system
    let arpPlaying = false, arpTimeout = null, arpStep = 0;
    let muted = localStorage.getItem('neonSurviveMuted') === 'true';
    const arpScales = [
        [261, 329, 392, 523, 659], // C major pentatonic
        [293, 349, 440, 523, 659], // D minor-ish
        [330, 392, 494, 587, 659], // E phrygian feel
        [349, 440, 523, 659, 698], // F lydian feel
    ];
    function startArp() {
        if (arpPlaying || muted) return;
        arpPlaying = true; arpStep = 0;
        function scheduleArpNote() {
            if (!arpPlaying || !audioCtx || muted) return;
            const scaleIdx = Math.min(wave - 1, arpScales.length - 1);
            const scale = arpScales[scaleIdx];
            const note = scale[arpStep % scale.length];
            const octave = Math.floor(arpStep / scale.length) % 2 === 0 ? 1 : 2;
            const freq = note * octave;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'triangle';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.04 * masterVolume, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.25);
            arpStep++;
            const bpm = beatBPM + (wave - 1) * 8;
            arpTimeout = setTimeout(scheduleArpNote, (60000 / bpm) / 2);
        }
        scheduleArpNote();
    }
    function stopArp() { arpPlaying = false; if (arpTimeout) clearTimeout(arpTimeout); }

    function toggleMute() {
        muted = !muted;
        localStorage.setItem('neonSurviveMuted', muted);
        document.getElementById('muteBtn').textContent = muted ? 'üîá' : 'üîä';
        if (muted) { stopBeat(); stopArp(); stopBassDrone(); if (audioCtx) audioCtx.suspend(); }
        else if (gameState === 'playing' && !paused) { if (audioCtx) audioCtx.resume(); startBeat(); startArp(); startBassDrone(); }
    }

    // ============================================
    // INIT
    // ============================================
    function resizeCanvas() {
        WIDTH = window.innerWidth; HEIGHT = window.innerHeight;
        canvas.width = WIDTH; canvas.height = HEIGHT;
    }

    function init() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        // 3-layer parallax starfield
        for (let i = 0; i < 60; i++) {
            stars.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, size: 0.5 + Math.random(), speed: 0.05 + Math.random() * 0.15, layer: 0, twinkle: Math.random() * Math.PI * 2, twinkleSpeed: 0.5 + Math.random() * 2 });
        }
        for (let i = 0; i < 40; i++) {
            stars.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, size: 1 + Math.random(), speed: 0.2 + Math.random() * 0.3, layer: 1, twinkle: Math.random() * Math.PI * 2, twinkleSpeed: 0.3 + Math.random() * 1.5 });
        }
        for (let i = 0; i < 15; i++) {
            stars.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, size: 2 + Math.random() * 1.5, speed: 0.5 + Math.random() * 0.5, layer: 2, twinkle: Math.random() * Math.PI * 2, twinkleSpeed: 0.2 + Math.random() * 1 });
        }
        initNebulae();
        document.getElementById('startBtn').addEventListener('click', () => { dailyChallengeActive = false; resetDailyMods(); startGame(); });
        document.getElementById('restartBtn').addEventListener('click', startGame);
        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ' && gameState === 'playing' && !paused) { e.preventDefault(); tryDash(); }
            if (e.key === 'f' && gameState === 'playing' && !paused) { e.preventDefault(); tryGrazeBlast(); }
            if ((e.key === 'p' || e.key === 'Escape') && gameState === 'playing') { e.preventDefault(); togglePause(); }
            if ((e.key === 'Enter' || e.key === ' ' || e.key === 'r') && gameState === 'gameover') { e.preventDefault(); startGame(); }
        });
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        canvas.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; mouse.active = true; });
        let tapCount = 0, tapResetTimer = null;
        canvas.addEventListener('touchstart', e => {
            handleTouch(e);
            const now = Date.now();
            if (now - lastTapTime < 300) {
                tapCount++;
                if (tapCount >= 3) { tryGrazeBlast(); tapCount = 0; }
                else if (tapCount === 2) { tryDash(); }
            } else { tapCount = 1; }
            lastTapTime = now;
            clearTimeout(tapResetTimer);
            tapResetTimer = setTimeout(() => tapCount = 0, 400);
        });
        canvas.addEventListener('touchmove', handleTouch);
        canvas.addEventListener('touchend', () => touch.active = false);
        // Prevent scroll during gameplay
        document.body.addEventListener('touchmove', e => { if (gameState === 'playing') e.preventDefault(); }, { passive: false });
        document.getElementById('highScoreDisplay').textContent = `HIGH SCORE: ${Math.floor(highScore)}`;
        // Populate daily challenge info
        const todayChallenge = getTodaysChallenge();
        const dailyBest = getDailyBest();
        document.getElementById('dailyInfo').innerHTML = `${todayChallenge.name}: ${todayChallenge.desc}<br>Score bonus: ${todayChallenge.scoreBonus}x${dailyBest > 0 ? ` | Today's best: ${dailyBest}` : ''}`;
        updateLifetimeDisplay();
        document.getElementById('timestamp').textContent = new Date().toLocaleString();
        requestAnimationFrame(gameLoop);
    }

    function handleTouch(e) {
        e.preventDefault();
        touch.x = e.touches[0].clientX;
        touch.y = e.touches[0].clientY;
        touch.active = true;
    }

    // ============================================
    // DASH
    // ============================================
    let dashBuffer = 0; // input buffer timer (seconds) ‚Äî queues dash if pressed during cooldown
    const DASH_BUFFER_WINDOW = 0.2; // 200ms buffer

    function tryDash() {
        if (dash.cooldown > 0 || dash.active) {
            // Buffer the input ‚Äî will fire when cooldown expires
            dashBuffer = DASH_BUFFER_WINDOW;
            return;
        }
        dashBuffer = 0;
        dash.active = true;
        dash.timer = dash.duration;
        dash.cooldown = dash.cooldownTime;
        dash.invincible = true;
        playDashSound();
        shakeAmount = 5;
        flashColor = '#00ff88'; flashAlpha = 0.15;
        spawnSpeedLines();
        // Dash trail burst
        for (let i = 0; i < 8; i++) {
            const a = Math.random() * Math.PI * 2;
            particles.push({
                x: player.x, y: player.y,
                vx: Math.cos(a) * 200, vy: Math.sin(a) * 200,
                life: 0.4, decay: 0.025, size: 3, color: '#00ff88'
            });
        }
    }

    // ============================================
    // GRAZE BLAST ‚Äî spend combo to push/destroy enemies
    // ============================================
    let blastRings = []; // visual shockwave rings
    const BLAST_MIN_COMBO = 5;
    const BLAST_RADIUS_BASE = 180;
    const BLAST_PUSH_FORCE = 600;

    function tryGrazeBlast() {
        if (comboCount < BLAST_MIN_COMBO) return;
        const power = comboCount;
        const radius = BLAST_RADIUS_BASE + power * 8;
        // Consume ALL combo
        const consumed = comboCount;
        comboCount = 0; comboTimer = 0;
        // Push/destroy enemies
        let kills = 0;
        enemies.forEach(e => {
            const dx = e.x - player.x, dy = e.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < radius) {
                const pushStr = BLAST_PUSH_FORCE * (1 - dist / radius) * (1 + power * 0.1);
                const nx = dist > 0 ? dx / dist : 0, ny = dist > 0 ? dy / dist : 0;
                // Small enemies (radius <= 6) get destroyed
                if (e.radius <= 6 && dist < radius * 0.6) {
                    const deadX = e.x, deadY = e.y, deadColor = e.color || '#00ffff';
                    e.x = -9999; // mark for removal
                    kills++;
                    score += Math.floor(25 * scoreMult);
                    for (let i = 0; i < 6; i++) {
                        const a = Math.random() * Math.PI * 2;
                        const sp = 120 + Math.random() * 80;
                        particles.push({ x: deadX, y: deadY, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.5, decay: 0.025, size: 2 + Math.random(), color: i % 2 ? deadColor : '#ffffff' });
                    }
                } else {
                    e.vx += nx * pushStr;
                    e.vy += ny * pushStr;
                }
            }
        });
        // Remove destroyed enemies
        compactInPlace(enemies, e => e.x > -9000);
        killCount += kills;
        // Also push score orbs toward player
        scoreOrbs.forEach(o => {
            const dx = o.x - player.x, dy = o.y - player.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < radius) {
                const pull = -300 * (1 - dist / radius);
                const nx = dist > 0 ? dx / dist : 0, ny = dist > 0 ? dy / dist : 0;
                o.vx += nx * pull; o.vy += ny * pull;
            }
        });
        // Visual + audio feedback
        blastRings.push({ x: player.x, y: player.y, radius: 0, maxRadius: radius, life: 0.6, power: consumed, color: consumed >= 15 ? '#ff00ff' : consumed >= 10 ? '#ffaa00' : '#00ffff' });
        shakeAmount = 8 + power * 0.5;
        flashColor = consumed >= 15 ? '#ff00ff' : '#00ffff';
        flashAlpha = 0.3;
        hitFreezeTimer = 0.08;
        // Sound ‚Äî ascending tone burst
        playSound(300 + consumed * 40, 0.15, 'sawtooth', 0.15);
        setTimeout(() => playSound(500 + consumed * 40, 0.1, 'sine', 0.1), 50);
        // Floating text
        const blastLabel = consumed >= 15 ? 'üí• MEGA BLAST!' : consumed >= 10 ? '‚ö° GRAZE BLAST!' : '‚ú¶ BLAST!';
        spawnFloatingText(player.x, player.y - 40, blastLabel, consumed >= 15 ? '#ff00ff' : '#00ffff', 24, 1.5);
        if (kills > 0) spawnFloatingText(player.x, player.y - 65, `+${kills} kills`, '#ffdd00', 16, 1.0);
    }

    // ============================================
    // GAME CONTROL
    // ============================================
    function togglePause() {
        if (gameState !== 'playing') return;
        paused = !paused;
        document.getElementById('pauseOverlay').classList.toggle('show', paused);
        if (paused) { stopBeat(); stopArp(); if (audioCtx) audioCtx.suspend(); }
        else { if (!muted) { startBeat(); startArp(); if (audioCtx) audioCtx.resume(); } }
    }

    function startGame() {
        initAudio();
        if (!muted) { startBeat(); startBassDrone(); startArp(); }
        document.getElementById('muteBtn').style.display = 'block';
        document.getElementById('muteBtn').textContent = muted ? 'üîá' : 'üîä';
        gameState = 'playing'; score = 0; grazeCount = 0; gameTime = 0; difficulty = 1; orbChainCount = 0; orbChainTimer = 0; hitFreezeTimer = 0;
        ghostRecording = []; ghostFrame = 0; ghostRecordTimer = 0;
        gravityWells = []; gravityWellTimer = GRAVITY_WELL_MIN_INTERVAL * 0.5;
        player.x = WIDTH / 2; player.y = HEIGHT / 2; player.vx = 0; player.vy = 0; player.trail = [];
        // Apply daily challenge player mods
        if (dailyChallengeActive) { player.radius = player.baseRadius * dailyMods.playerRadiusMult; }
        enemies = []; particles = []; powerups = []; scoreOrbs = []; boss = null; gravityWells = []; atmosphere = [];
        lastSpawn = 0; lastPowerupSpawn = 0;
        wave = 1; waveTimer = 0; waveBreak = false; waveBreakTimer = 0;
        comboCount = 0; comboTimer = 0; comboBest = 0; killCount = 0; killStreak = 0; killStreakTimer = 0; perfectDodgeCount = 0; dangerProximity = 0;
        scoreMult = 1; scoreMultTarget = 1; scoreMultDecayTimer = 0; scoreMultPulse = 0;
        paused = false; newHighScore = false; document.getElementById('pauseOverlay').classList.remove('show');
        document.getElementById('pauseBtn').style.display = 'block';
        dash.active = false; dash.timer = 0; dash.cooldown = 0; dash.invincible = false; dashBuffer = 0;
        blastRings = [];
        laserBarriers = [];
        grazeExpand = 1; perkChoiceActive = false;
        document.getElementById('perkChoice').classList.remove('show');
        activePowerups = { shield: 0, slowmo: 0, magnet: 0, tiny: 0, aura: 0 };
        player.shrunk = false;
        sessionPowerupsCollected = {}; sessionBossKilled = false; sessionDashKill = false; achievementToasts = [];
        waveAnnounce = 'WAVE 1'; waveAnnounceTimer = 1.5;
        document.getElementById('menu').classList.add('hidden');
        document.getElementById('gameOver').classList.remove('show');
        document.querySelectorAll('.info-section,.footer').forEach(el => el.style.display = 'none');
        document.body.style.overflow = 'hidden';
    }

    function endGame() {
        gameState = 'dying'; deathSlowmo = deathSlowmoDuration;
        perkChoiceActive = false; paused = false;
        document.getElementById('perkChoice').classList.remove('show');
        shakeAmount = 25;
        // Death ring
        rings.push({ x: player.x, y: player.y, radius: 5, maxRadius: Math.max(WIDTH, HEIGHT) * 0.8, speed: 300, life: 1, color: '#ff0044', width: 4 });
        // Death shards ‚Äî triangle fragments spinning away
        deathShards = [];
        const shipCol = getShipColor(xpData.level);
        const r = player.radius;
        const baseAngle = Math.atan2(player.vy, player.vx) || 0;
        // Break triangle into 6 shards (triangular fragments)
        const shardPoints = [
            [r*1.3, 0], [-r*0.8, -r*0.9], [-r*0.4, 0], [-r*0.8, r*0.9]
        ];
        for (let i = 0; i < 6; i++) {
            const a = baseAngle + (Math.PI * 2 / 6) * i + (Math.random()-0.5)*0.5;
            const sp = 120 + Math.random() * 250;
            deathShards.push({
                x: player.x, y: player.y,
                vx: Math.cos(a) * sp, vy: Math.sin(a) * sp,
                rotation: baseAngle + Math.random() * Math.PI,
                rotSpeed: (Math.random()-0.5) * 15,
                size: r * (0.3 + Math.random() * 0.5),
                life: 1.8, decay: 0.012,
                color: Math.random() > 0.3 ? shipCol : '#ff0044'
            });
        }
        // Smaller particle burst (reduced since shards carry the visual weight)
        for (let i = 0; i < 18; i++) {
            const a = Math.random() * Math.PI * 2, sp = Math.random() * 300 + 50;
            particles.push({ x: player.x, y: player.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 1.5, decay: 0.012, size: Math.random()*5+2, color: Math.random()>0.5?'#ff0044':'#ff8800' });
        }
        playDeathSound();
        // Save ghost recording for next run (only if meaningful length)
        if (ghostRecording.length > 30) {
            // Keep max ~90s of ghost data (15fps * 3 values * 90s = 4050 entries)
            const maxEntries = 15 * 3 * 90;
            localStorage.setItem('neonSurviveGhost', JSON.stringify(ghostRecording.slice(0, maxEntries)));
            ghostPlayback = ghostRecording.slice(0, maxEntries);
        }
        // Award XP for this run
        const xpEarned = Math.floor(score * 0.1 + wave * 20 + grazeCount * 5);
        addXP(xpEarned);
    }

    function updateAchievementDisplay() {
        const el = document.getElementById('achievementCount');
        if (el) el.innerHTML = unlockedAchievements.length > 0 ? `üèÜ ${unlockedAchievements.length}/${ACHIEVEMENTS.length} Achievements` : '';
    }
    function updateLifetimeDisplay() {
        updateAchievementDisplay();
        const el = document.getElementById('lifetimeStats');
        if (el && lifetime.games > 0) {
            el.innerHTML = `GAMES: ${lifetime.games} | BEST WAVE: ${lifetime.bestWave} | KILLS: ${lifetime.totalKills} | GRAZES: ${lifetime.totalGrazes} | BEST COMBO: x${lifetime.bestCombo}`;
        }
        // Pilot rank/XP display
        const prEl = document.getElementById('pilotRank');
        if (prEl) {
            const shipCol = getShipColor(xpData.level);
            const shipName = getShipName(xpData.level);
            const needed = xpForLevel(xpData.level);
            const pct = Math.floor((xpData.xp / needed) * 100);
            const barW = 140;
            const filledW = Math.floor(barW * (xpData.xp / needed));
            prEl.innerHTML = `<span style="color:${shipCol};text-shadow:0 0 10px ${shipCol}">‚ñ∂ ${shipName}</span> <span style="opacity:0.6">LVL ${xpData.level}</span><br>` +
                `<span style="display:inline-block;width:${barW}px;height:6px;background:rgba(255,255,255,0.1);border-radius:3px;vertical-align:middle;overflow:hidden">` +
                `<span style="display:block;width:${filledW}px;height:100%;background:${shipCol};border-radius:3px;box-shadow:0 0 6px ${shipCol}"></span></span>` +
                `<span style="font-size:11px;opacity:0.5;margin-left:6px">${xpData.xp}/${needed} XP</span>`;
        }
    }

    function finalizeDeath() {
        checkAchievements();
        gameState = 'gameover'; stopBeat(); stopBassDrone(); stopArp();
        document.getElementById('pauseBtn').style.display = 'none';
        document.body.style.overflow = '';
        // Update lifetime stats
        lifetime.games++;
        lifetime.bestWave = Math.max(lifetime.bestWave, wave);
        lifetime.totalKills += killCount;
        lifetime.totalGrazes += grazeCount;
        lifetime.totalTime += gameTime;
        lifetime.bestCombo = Math.max(lifetime.bestCombo, comboBest);
        saveLifetime();
        updateLifetimeDisplay();
        // Final explosion burst
        for (let i = 0; i < 40; i++) {
            const a = Math.random() * Math.PI * 2, sp = Math.random() * 200 + 80;
            particles.push({ x: player.x, y: player.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 1, decay: 0.02, size: Math.random()*4+1, color: Math.random()>0.3?'#ff0044':'#ffffff' });
        }
        flashColor = '#ff0044'; flashAlpha = 0.6;
        if (score > highScore) { highScore = score; localStorage.setItem('neonSurviveHighScore', highScore); }
        if (dailyChallengeActive) saveDailyBest(score);
        const survivalTime = gameTime.toFixed(1);
        const rankInfo = getPerformanceRank(wave, score, grazeCount, comboBest, killCount);
        const tier = getDifficultyTier(wave);
        const tip = getDeathTip(wave, grazeCount, comboBest, killCount, gameTime);
        const isNewHS = score > (localStorage.getItem('neonSurviveHighScore') || 0);
        const newHSBadge = isNewHS ? '<div style="color:#ffff00;font-size:18px;margin-top:5px;animation:pulse 1s infinite">‚òÖ NEW HIGH SCORE ‚òÖ</div>' : '';
        const grazesPerSec = gameTime > 0 ? (grazeCount / gameTime).toFixed(1) : '0.0';
        // Session streak tracking
        sessionStreak++;
        if (score > sessionBestScore) sessionBestScore = score;
        // Save game to history
        gameHistory.push({ rank: rankInfo.rank, score: Math.floor(score), wave, time: survivalTime, grazes: grazeCount, kills: killCount, combo: comboBest });
        if (gameHistory.length > 10) gameHistory = gameHistory.slice(-10);
        localStorage.setItem('neonSurviveHistory', JSON.stringify(gameHistory));
        // Build history display (last 5)
        const historyHtml = gameHistory.length > 1 ? '<div style="margin-top:18px;font-size:12px;opacity:0.45;line-height:1.7">' +
            'RECENT: ' + gameHistory.slice(-6, -1).reverse().map(h => `<span style="color:${h.rank==='S'||h.rank==='S+'?'#ffff00':h.rank==='A'?'#00ff88':'#aaa'}">${h.rank}</span>`).join(' ‚Üí ') +
            '</div>' : '';
        // Session streak display
        const streakLabels = ['', '', '', 'üî• On Fire!', 'üî•üî• Unstoppable!', 'üî•üî•üî• ADDICTED!', 'üíÄ NO LIFE!', 'üíÄüíÄ ASCENDED!'];
        const streakLabel = sessionStreak >= 8 ? 'üíÄüíÄüíÄ TRANSCENDENT!' : (streakLabels[sessionStreak] || '');
        const streakHtml = sessionStreak >= 2 ? `<div style="margin-top:10px;font-size:13px;opacity:0.6;line-height:1.5">Session: ${sessionStreak} games${streakLabel ? ` ‚Äî <span style="color:#ff8800;text-shadow:0 0 8px #ff4400">${streakLabel}</span>` : ''}${sessionBestScore > score ? `<br>Session best: ${Math.floor(sessionBestScore)}` : ''}</div>` : '';
        // Animated stat bars for game over
        const statBars = [
            { label: 'Waves', value: wave, max: 15, color: tier.color },
            { label: 'Grazes', value: grazeCount, max: Math.max(30, grazeCount), color: '#00ffff' },
            { label: 'Kills', value: killCount, max: Math.max(20, killCount), color: '#ff8800' },
            { label: 'Combo', value: comboBest, max: 20, color: '#ff00ff' },
        ];
        const barsHtml = statBars.map((s, i) => {
            const pct = Math.min(100, (s.value / s.max) * 100);
            return `<div style="display:flex;align-items:center;gap:8px;margin:4px 0;font-size:12px;opacity:0.9">` +
                `<span style="width:55px;text-align:right;opacity:0.6">${s.label}</span>` +
                `<div style="flex:1;height:6px;background:rgba(255,255,255,0.08);border-radius:3px;overflow:hidden">` +
                `<div style="width:0%;height:100%;background:${s.color};border-radius:3px;box-shadow:0 0 6px ${s.color};transition:width 0.8s cubic-bezier(.17,.67,.35,1.2) ${0.3 + i * 0.15}s" data-stat-bar="${pct}"></div></div>` +
                `<span style="width:30px;font-size:11px;opacity:0.7">${s.value}</span></div>`;
        }).join('');
        document.getElementById('finalScore').innerHTML = `<div id="rankReveal" style="font-size:80px;color:${rankInfo.color};text-shadow:0 0 30px ${rankInfo.glow},0 0 60px ${rankInfo.glow};margin-bottom:5px;opacity:0;transform:scale(3);transition:opacity 0.4s,transform 0.5s cubic-bezier(.17,.67,.35,1.2)">${rankInfo.rank}</div>SCORE: ${Math.floor(score)}${newHSBadge}<div style="margin-top:12px;font-size:16px;opacity:0.8;line-height:1.8">Wave ${wave} <span style="color:${tier.color}">[${tier.name}]</span> | ${survivalTime}s<br>${grazesPerSec} grazes/s | Best combo: x${comboBest}${perfectDodgeCount > 0 ? ` | ‚ö°${perfectDodgeCount} perfect dodge${perfectDodgeCount>1?'s':''}` : ''}</div><div style="margin-top:14px;max-width:280px;width:100%">${barsHtml}</div>${historyHtml}${streakHtml}<div style="margin-top:15px;font-size:13px;opacity:0.55;max-width:400px;line-height:1.5">${tip}</div>`;
        // Trigger bar animations after DOM paint
        requestAnimationFrame(() => { requestAnimationFrame(() => {
            document.querySelectorAll('[data-stat-bar]').forEach(el => { el.style.width = el.dataset.statBar + '%'; });
        }); });
        setTimeout(() => {
            document.getElementById('gameOver').classList.add('show');
            // Dramatic rank reveal with delay
            setTimeout(() => {
                const rr = document.getElementById('rankReveal');
                if (rr) { rr.style.opacity = '1'; rr.style.transform = 'scale(1)'; }
                // Rank reveal sound
                if (!muted && audioCtx) {
                    const rankFreqs = { 'S': [880,1100,1320,1760], 'A': [660,880,1100], 'B': [523,659,784], 'C': [440,523], 'D': [330,440], 'F': [220] };
                    const freqs = rankFreqs[rankInfo.rank] || [440];
                    freqs.forEach((f, i) => setTimeout(() => playSound(f, 0.25, 'sine', 0.1), i * 80));
                }
            }, 400);
        }, 800);
    }

    // ============================================
    // POWER-UPS
    // ============================================
    // Gravity Well system ‚Äî vortex power-up creates a black hole that pulls enemies
    let gravityWells = [];

    function spawnPowerup() {
        const types = ['shield', 'slowmo', 'magnet', 'vortex'];
        const colors = { shield: '#00aaff', slowmo: '#ff00ff', magnet: '#ffff00', vortex: '#aa00ff' };
        const symbols = { shield: 'üõ°', slowmo: '‚è≥', magnet: 'üß≤', vortex: 'üåÄ' };
        const type = types[Math.floor(Math.random() * types.length)];
        powerups.push({
            x: Math.random() * (WIDTH - 100) + 50,
            y: Math.random() * (HEIGHT - 100) + 50,
            type, color: colors[type], symbol: symbols[type],
            radius: 15, life: 10, pulse: 0
        });
    }

    function collectPowerup(p) {
        if (p.type === 'vortex') {
            // Spawn a gravity well at collection point
            gravityWells.push({ x: p.x, y: p.y, life: 4, maxLife: 4, radius: 0, maxRadius: 180, pull: 400, angle: 0 });
            playVortexSound();
        } else {
            activePowerups[p.type] = p.type === 'shield' ? 5 : p.type === 'slowmo' ? 4 : 6;
        }
        sessionPowerupsCollected[p.type] = true;
        playPowerupSound();
        flashColor = p.color; flashAlpha = 0.2;
        // Pickup particles
        for (let i = 0; i < 12; i++) {
            const a = Math.random() * Math.PI * 2;
            particles.push({ x: p.x, y: p.y, vx: Math.cos(a)*150, vy: Math.sin(a)*150, life: 0.6, decay: 0.03, size: 2, color: p.color });
        }
        particles.push({ x: p.x, y: p.y - 15, vx: 0, vy: -60, life: 1, decay: 0.02, size: 0, color: p.color, text: p.type.toUpperCase() });
    }

    // ============================================
    // GAME LOOP
    // ============================================
    let lastTime = 0;
    function gameLoop(timestamp) {
        requestAnimationFrame(gameLoop);
        const rawDt = lastTime ? (timestamp - lastTime) / 1000 : 1/60;
        lastTime = timestamp;
        const dt = Math.min(rawDt, 1/30); // Cap dt to prevent physics jumps

        // Hit freeze ‚Äî skip update for juicy pause on graze
        if (hitFreezeTimer > 0) { hitFreezeTimer -= rawDt; }
        // Wave freeze ‚Äî brief pause on wave clear
        if (waveFreezeTimer > 0) { waveFreezeTimer -= rawDt; }
        if (gameState === 'playing' && !paused && hitFreezeTimer <= 0 && waveFreezeTimer <= 0) update(dt, timestamp);
        if (gameState === 'dying') updateDying(dt);
        if (gameState === 'menu' || gameState === 'gameover') updateAttractMode(dt);
        updateNebulae(dt);
        // Update rings always
        rings.forEach(r => { r.radius += r.speed * dt; r.life -= dt / (r.maxRadius / r.speed); });
        compactInPlace(rings, r => r.life > 0 && r.radius < r.maxRadius);
        render();
    }

    function update(dt, timestamp) {
        // Bullet time tick
        if (bulletTime > 0) bulletTime -= dt;
        const btMult = bulletTime > 0 ? 0.15 : 1;
        const timeMult = (activePowerups.slowmo > 0 ? 0.5 : 1) * btMult;
        const eDt = dt * timeMult; // Enemy delta time (slowed)
        gameTime += dt;
        // Ghost recording
        ghostRecordTimer += dt;
        if (ghostRecordTimer >= GHOST_RECORD_INTERVAL) {
            ghostRecordTimer -= GHOST_RECORD_INTERVAL;
            const angle = Math.atan2(player.vy, player.vx) || 0;
            ghostRecording.push(Math.round(player.x)|0, Math.round(player.y)|0, Math.round(angle*100)/100);
        }
        // Periodic achievement check (every 5s for time-based)
        if (Math.floor(gameTime) % 5 === 0 && Math.floor(gameTime) !== Math.floor(gameTime - dt)) checkAchievements();

        // Wave system
        waveTimer += dt;
        if (waveBreak) {
            waveBreakTimer += dt;
            if (waveBreakTimer >= waveBreakDuration) {
                waveBreak = false; waveBreakTimer = 0; waveTimer = 0; wave++;
                checkAchievements();
                const waveHints = wave >= 5 ? '‚ö† Snipers active' : wave >= 3 ? '‚ö† Burst enemies' : '';
                waveAnnounce = `WAVE ${wave}`; waveAnnounceTimer = 1.8;
                waveKills = 0; waveGrazes = 0; waveBreakStats = null;
                playSound(600, 0.2, 'square', 0.08);
                setTimeout(() => playSound(800, 0.2, 'square', 0.08), 100);
                // Wave start edge particle burst
                if (settings.particles) {
                    const tier = getDifficultyTier(wave);
                    for (let i = 0; i < 20; i++) {
                        const side = Math.floor(Math.random() * 4);
                        let px, py, pvx, pvy;
                        if (side === 0) { px = Math.random() * WIDTH; py = 0; pvx = (Math.random()-0.5)*100; pvy = 80 + Math.random()*60; }
                        else if (side === 1) { px = WIDTH; py = Math.random() * HEIGHT; pvx = -(80 + Math.random()*60); pvy = (Math.random()-0.5)*100; }
                        else if (side === 2) { px = Math.random() * WIDTH; py = HEIGHT; pvx = (Math.random()-0.5)*100; pvy = -(80 + Math.random()*60); }
                        else { px = 0; py = Math.random() * HEIGHT; pvx = 80 + Math.random()*60; pvy = (Math.random()-0.5)*100; }
                        particles.push({ x: px, y: py, vx: pvx, vy: pvy, life: 0.8, decay: 0.025, size: 2 + Math.random()*2, color: tier.color });
                    }
                }
                updateBassDrone(wave);
                // Boss every 5 waves
                if (wave % 5 === 0 && !boss) { setTimeout(() => { if (gameState === 'playing') spawnBoss(wave); }, 1500); }
                // Perk choice ‚Äî every 2 waves starting wave 2
                if (wave > 1 && wave % perkWaveThreshold === 0) {
                    setTimeout(() => { if (gameState === 'playing' && !perkChoiceActive) offerPerkChoice(); }, 800);
                }
            }
        } else if (waveTimer >= waveDuration) {
            waveBreak = true; waveBreakTimer = 0;
            waveFreezeTimer = 0.15; // brief freeze for impact
            waveBreakStats = { wave, kills: waveKills, grazes: waveGrazes };
            // Perfect wave bonus ‚Äî 5+ grazes in a wave
            const isPerfectWave = waveGrazes >= 5;
            waveBreakStats.perfect = isPerfectWave;
            waveAnnounce = isPerfectWave ? '‚òÖ PERFECT WAVE ‚òÖ' : 'CLEAR!'; waveAnnounceTimer = isPerfectWave ? 2.2 : 1.5;
            flashColor = isPerfectWave ? '#ffdd00' : '#00ff88'; flashAlpha = isPerfectWave ? 0.5 : 0.3;
            playWaveClearSound();
            if (isPerfectWave) {
                // Perfect wave rewards: bonus score + brief shield
                score += 500 * wave;
                activePowerups.shield = Math.max(activePowerups.shield, 3);
                spawnFloatingText(WIDTH/2, HEIGHT/2 + 70, `+${500 * wave} BONUS!`, '#ffdd00', 22, 2);
                // Extra celebration sounds
                setTimeout(() => playSound(1047, 0.2, 'sine', 0.12), 300);
                setTimeout(() => playSound(1319, 0.3, 'sine', 0.1), 500);
                // Golden particles burst
                for (let i = 0; i < 25; i++) {
                    const a = Math.random() * Math.PI * 2, sp = 100 + Math.random() * 200;
                    particles.push({ x: player.x, y: player.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 1.2, decay: 0.015, size: 2 + Math.random()*3, color: Math.random() > 0.5 ? '#ffdd00' : '#ffffff' });
                }
            }
            // Expanding ring VFX
            const ringColor = isPerfectWave ? '#ffdd00' : '#00ff88';
            rings.push({ x: player.x, y: player.y, radius: 20, maxRadius: Math.max(WIDTH, HEIGHT) * 0.6, speed: 600, life: 1, color: ringColor, width: 3 });
            rings.push({ x: player.x, y: player.y, radius: 10, maxRadius: Math.max(WIDTH, HEIGHT) * 0.4, speed: 450, life: 1, color: isPerfectWave ? '#fff' : '#00ffcc', width: 2 });
            // Spawn bonus orb during wave break
            powerups.push({
                x: WIDTH/2 + (Math.random()-0.5)*200, y: HEIGHT/2 + (Math.random()-0.5)*200,
                type: 'shield', color: '#00ffcc', symbol: '‚≠ê',
                radius: 18, life: waveBreakDuration + 0.5, pulse: 0
            });
        }
        if (waveAnnounceTimer > 0) waveAnnounceTimer -= dt;

        difficulty = 1 + (wave - 1) * 0.3 + gameTime * 0.02;
        spawnInterval = waveBreak ? 99999 : Math.max(250, 900 - wave * 60);

        // Combo timer
        if (comboTimer > 0) { comboTimer -= dt; if (comboTimer <= 0) comboCount = 0; }
        // Kill streak timer
        if (killStreakTimer > 0) { killStreakTimer -= dt; if (killStreakTimer <= 0) killStreak = 0; }
        if (killStreakAnnounceTimer > 0) killStreakAnnounceTimer -= dt;
        if (comboAnnounceTimer > 0) { comboAnnounceTimer -= dt; comboAnnounceScale = Math.max(1, comboAnnounceScale - dt * 2); }

        // Flow Zone intensity ‚Äî smooth interpolation based on combo
        const targetFlow = comboCount >= 20 ? 1.0 : comboCount >= 10 ? 0.7 : comboCount >= 5 ? 0.4 : 0;
        flowZoneIntensity += (targetFlow - flowZoneIntensity) * dt * 3;
        if (flowZoneIntensity < 0.01) flowZoneIntensity = 0;
        if (flowZoneIntensity > 0) flowZoneHueShift += dt * (60 + flowZoneIntensity * 120);

        // Laser barriers update
        laserBarriers.forEach(lb => {
            lb.life -= dt;
            if (lb.warmup > 0) lb.warmup -= dt;
            lb.angle += lb.rotSpeed * dt;
            // Collision with player (only when active, not warming up)
            if (lb.warmup <= 0 && !dash.invincible && activePowerups.shield <= 0) {
                // Point-line distance from player to the laser segment
                const cos = Math.cos(lb.angle), sin = Math.sin(lb.angle);
                const ax = lb.cx - cos * lb.halfLen, ay = lb.cy - sin * lb.halfLen;
                const bx = lb.cx + cos * lb.halfLen, by = lb.cy + sin * lb.halfLen;
                const abx = bx - ax, aby = by - ay;
                const apx = player.x - ax, apy = player.y - ay;
                const t = Math.max(0, Math.min(1, (apx*abx + apy*aby) / (abx*abx + aby*aby)));
                const closestX = ax + t * abx, closestY = ay + t * aby;
                const distSq = (player.x - closestX) ** 2 + (player.y - closestY) ** 2;
                if (distSq < (player.radius + 4) ** 2) {
                    endGame();
                }
            }
        });
        compactInPlace(laserBarriers, lb => lb.life > 0);
        // Spawn lasers ‚Äî wave 4+, chance per wave proportional to difficulty
        if (wave >= 4 && !waveBreak && laserBarriers.length < Math.min(3, Math.floor(wave / 3))) {
            if (Math.random() < dt * 0.08 * (wave - 3)) {
                spawnLaserBarrier();
            }
        }

        // Gravity wells update
        gravityWells.forEach(gw => {
            gw.life -= dt;
            gw.angle += dt * 3;
            gw.radius = gw.maxRadius * Math.min(1, (gw.maxLife - gw.life) * 4); // expand quickly
            const fade = gw.life / gw.maxLife;
            // Pull enemies toward center
            enemies.forEach(e => {
                const dx = gw.x - e.x, dy = gw.y - e.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < gw.radius && dist > 5) {
                    const strength = gw.pull * fade * (1 - dist / gw.radius);
                    e.vx += (dx/dist) * strength * dt;
                    e.vy += (dy/dist) * strength * dt;
                }
            });
            // Pull boss too (weaker)
            if (boss) {
                const dx = gw.x - boss.x, dy = gw.y - boss.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < gw.radius && dist > 5) {
                    const strength = gw.pull * fade * 0.3 * (1 - dist / gw.radius);
                    boss.x += (dx/dist) * strength * dt;
                    boss.y += (dy/dist) * strength * dt;
                }
            }
            // Ambient particles ‚Äî spiral inward
            if (settings.particles && Math.random() < 0.4) {
                const a = Math.random() * Math.PI * 2;
                const r = gw.radius * (0.5 + Math.random() * 0.5);
                particles.push({
                    x: gw.x + Math.cos(a) * r, y: gw.y + Math.sin(a) * r,
                    vx: (gw.x - (gw.x + Math.cos(a)*r)) * 2, vy: (gw.y - (gw.y + Math.sin(a)*r)) * 2,
                    life: 0.5, decay: 0.04, size: 1.5, color: '#aa00ff'
                });
            }
        });
        compactInPlace(gravityWells, gw => gw.life > 0);

        // Beat pulse decay
        if (beatPulse > 0) beatPulse = Math.max(0, beatPulse - dt * 5);

        // Dash update
        if (dash.active) { dash.timer -= dt; if (dash.timer <= 0) { dash.active = false; dash.invincible = false; } }
        if (dash.cooldown > 0) {
            const wasCooling = dash.cooldown > 0;
            dash.cooldown -= dt;
            if (dash.cooldown <= 0 && wasCooling && !dash.active) {
                dashReadyFlash = 0.4;
                playSound(1200, 0.08, 'sine', 0.06);
                // Consume buffered dash input
                if (dashBuffer > 0) { dashBuffer = 0; tryDash(); }
            }
        }
        if (dashBuffer > 0) dashBuffer -= dt;
        if (dashReadyFlash > 0) dashReadyFlash -= dt;

        // Power-up timers
        for (const k in activePowerups) { if (activePowerups[k] > 0) activePowerups[k] -= dt; }
        // Expire shrink powerup
        if (player.shrunk && (activePowerups.tiny||0) <= 0) { player.radius /= 0.7; player.shrunk = false; }
        // Expire aura powerup
        if (grazeExpand > 1 && (activePowerups.aura||0) <= 0) { grazeExpand = 1; }

        // Score multiplier update
        if (scoreMultDecayTimer > 0) { scoreMultDecayTimer -= dt; }
        else { scoreMultTarget = Math.max(1, scoreMultTarget - dt * 0.3); }
        scoreMult += (scoreMultTarget - scoreMult) * dt * 5; // smooth lerp
        if (scoreMultPulse > 0) scoreMultPulse -= dt * 2;

        // Score
        const comboMult = Math.max(1, comboCount);
        score = (gameTime * 10 + grazeCount * 50 * comboMult) * scoreMult;
        // New high score detection
        if (!newHighScore && score > highScore && highScore > 0) {
            newHighScore = true;
            flashColor = '#ffff00'; flashAlpha = 0.4;
            shakeAmount = 8;
            playSound(880, 0.2, 'sine', 0.12);
            setTimeout(() => playSound(1100, 0.2, 'sine', 0.1), 100);
            setTimeout(() => playSound(1320, 0.3, 'sine', 0.1), 200);
            for (let i = 0; i < 20; i++) {
                const a = Math.random() * Math.PI * 2;
                particles.push({ x: player.x, y: player.y, vx: Math.cos(a)*200, vy: Math.sin(a)*200, life: 1.2, decay: 0.015, size: 3, color: '#ffff00' });
            }
            particles.push({ x: WIDTH/2, y: HEIGHT/3, vx: 0, vy: -30, life: 2, decay: 0.012, size: 0, color: '#ffff00', text: '‚òÖ NEW HIGH SCORE ‚òÖ' });
        }
        const comboMult2 = comboCount > 1 ? ` | x${comboCount} COMBO` : '';
        const dashText = dash.cooldown > 0 ? ` | DASH: ${dash.cooldown.toFixed(1)}s` : ' | DASH: ‚úì';
        const tier = getDifficultyTier(wave);
        const multColor = scoreMult >= 4 ? '#ff00ff' : scoreMult >= 3 ? '#ffaa00' : scoreMult >= 2 ? '#00ffff' : '#00ff88';
        const multText = scoreMult > 1.05 ? ` | <span style="color:${multColor};text-shadow:0 0 8px ${multColor}">x${scoreMult.toFixed(1)}</span>` : '';
        const dailyTag = dailyChallengeActive ? ` | <span style="color:#ffdd00">üéØ DAILY</span>` : '';
        document.getElementById('scoreDisplay').innerHTML = `WAVE ${wave} <span style="color:${tier.color};font-size:0.8em">[${tier.name}]</span> | ${Math.floor(score)} pts${multText} | GRAZE: ${grazeCount}${comboMult2}${dashText}${dailyTag}`;

        // Power-up HUD
        const pTexts = [];
        if (activePowerups.shield > 0) pTexts.push(`üõ° ${activePowerups.shield.toFixed(1)}s`);
        if (activePowerups.slowmo > 0) pTexts.push(`‚è≥ ${activePowerups.slowmo.toFixed(1)}s`);
        if (activePowerups.magnet > 0) pTexts.push(`üß≤ ${activePowerups.magnet.toFixed(1)}s`);
        document.getElementById('powerupHud').textContent = pTexts.join('  ');

        updatePlayer(dt);

        // Spawn enemies
        if (timestamp - lastSpawn > spawnInterval) { spawnEnemy(); lastSpawn = timestamp; }

        // Spawn power-ups (every 8-12 seconds)
        if (timestamp - lastPowerupSpawn > 8000 + Math.random() * 4000) {
            if (powerups.length < 3 && !dailyMods.noPowerups) spawnPowerup();
            lastPowerupSpawn = timestamp;
        }

        // Gravity Wells ‚Äî environmental hazards (wave 3+)
        if (wave >= 3 && !waveBreak) {
            gravityWellTimer -= dt;
            if (gravityWellTimer <= 0 && gravityWells.length < 2) {
                // Spawn a gravity well away from player
                let wx, wy, attempts = 0;
                do {
                    wx = 80 + Math.random() * (WIDTH - 160);
                    wy = 80 + Math.random() * (HEIGHT - 160);
                    attempts++;
                } while (Math.hypot(wx - player.x, wy - player.y) < 150 && attempts < 10);
                const strength = 120 + wave * 15; // pull strength scales with wave
                const duration = 4 + Math.random() * 3;
                gravityWells.push({ x: wx, y: wy, strength, radius: 120 + wave * 5, life: duration, maxLife: duration, warmup: 1.5, age: 0, angle: 0 });
                gravityWellTimer = GRAVITY_WELL_MIN_INTERVAL + Math.random() * (GRAVITY_WELL_MAX_INTERVAL - GRAVITY_WELL_MIN_INTERVAL);
                // Spawn sound ‚Äî deep rumble
                if (!muted) { playSound(80, 0.8, 'sine', 0.15); setTimeout(() => playSound(60, 0.6, 'sine', 0.12), 100); }
                // Warning text
                spawnFloatingText(wx, wy - 30, '‚ö† VORTEX', '#ff44aa', 16, 1.5);
            }
        }
        // Update gravity wells
        for (let i = gravityWells.length - 1; i >= 0; i--) {
            const gw = gravityWells[i];
            gw.age += dt;
            gw.life -= dt;
            gw.angle += dt * 3;
            if (gw.life <= 0) {
                // Collapse burst particles
                if (settings.particles) {
                    for (let p = 0; p < 12; p++) {
                        const a = Math.random() * Math.PI * 2, sp = 60 + Math.random() * 120;
                        particles.push({ x: gw.x, y: gw.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.8, decay: 0.02, size: 2, color: '#ff44aa' });
                    }
                }
                if (!muted) playSound(200, 0.3, 'sine', 0.08);
                gravityWells.splice(i, 1);
                continue;
            }
            // Pull player (only after warmup)
            if (gw.age > gw.warmup) {
                const dx = gw.x - player.x, dy = gw.y - player.y;
                const dist = Math.hypot(dx, dy);
                if (dist < gw.radius && dist > 5) {
                    const pullFactor = (1 - dist / gw.radius) * gw.strength * dt;
                    // Fade out pull in last 0.5s
                    const fadeMult = gw.life < 0.5 ? gw.life / 0.5 : 1;
                    player.vx += (dx / dist) * pullFactor * fadeMult;
                    player.vy += (dy / dist) * pullFactor * fadeMult;
                }
            }
            // Pull particles inward (ambient effect)
            if (settings.particles && Math.random() < 0.4) {
                const pa = Math.random() * Math.PI * 2;
                const pr = gw.radius * (0.5 + Math.random() * 0.5);
                particles.push({ x: gw.x + Math.cos(pa)*pr, y: gw.y + Math.sin(pa)*pr, vx: -Math.cos(pa)*40, vy: -Math.sin(pa)*40, life: 0.6, decay: 0.025, size: 1.5, color: gw.age < gw.warmup ? '#ff44aa44' : '#ff44aa' });
            }
        }

        updateEnemies(eDt);
        updatePowerups(dt);
        // Score orbs update
        scoreOrbs.forEach(o => {
            o.vx *= 0.96; o.vy *= 0.96;
            o.x += o.vx * dt; o.y += o.vy * dt;
            o.life -= dt; o.pulse += dt * 4;
            // Magnet toward player when close or magnet active
            const odx = player.x - o.x, ody = player.y - o.y;
            const odist = Math.sqrt(odx*odx + ody*ody);
            const magnetRange = activePowerups.magnet > 0 ? 300 : 80;
            if (odist < magnetRange && odist > 5) {
                const pull = activePowerups.magnet > 0 ? 350 : 150;
                o.vx += (odx/odist) * pull * dt;
                o.vy += (ody/odist) * pull * dt;
            }
            // Collection
            if (odist < player.radius + o.radius + 8) {
                score += o.value;
                o.life = 0;
                playOrbCollectSound();
                // Orb chain tracking
                orbChainCount++; orbChainTimer = 0.5;
                const chainBonus = orbChainCount >= 5 ? 3 : orbChainCount >= 3 ? 2 : 1;
                const orbText = orbChainCount >= 3 ? `+${o.value}x${chainBonus}` : `+${o.value}`;
                if (chainBonus > 1) score += o.value * (chainBonus - 1); // bonus score
                particles.push({ x: o.x, y: o.y - 8, vx: 0, vy: -50, life: 0.6, decay: 0.03, size: 0, color: orbChainCount >= 5 ? '#ff8800' : '#ffdd00', text: orbText });
                const sparkCount = 3 + (orbChainCount >= 3 ? 4 : 0);
                for (let si = 0; si < sparkCount; si++) {
                    const sa = Math.random() * Math.PI * 2;
                    const sspd = orbChainCount >= 3 ? 120 : 60;
                    particles.push({ x: o.x, y: o.y, vx: Math.cos(sa)*sspd, vy: Math.sin(sa)*sspd, life: 0.3 + (orbChainCount >= 3 ? 0.2 : 0), decay: 0.04, size: 2, color: orbChainCount >= 5 ? '#ff8800' : '#ffdd00' });
                }
                if (orbChainCount === 5) {
                    spawnFloatingText(player.x, player.y - 30, '‚ö° ORB CHAIN!', '#ff8800', 20, 1.2);
                    shakeAmount = Math.max(shakeAmount, 3);
                }
            }
        });
        compactInPlace(scoreOrbs, o => o.life > 0);
        if (scoreOrbs.length > 50) scoreOrbs.splice(0, scoreOrbs.length - 50);
        // Orb chain timer
        if (orbChainTimer > 0) { orbChainTimer -= dt; } else { orbChainCount = 0; }
        updateParticles(dt);
        updateStars(dt);
        updateEnvironment(dt);
        // Boss update
        if (boss) {
            boss.pulse += dt * 3;
            boss.shieldAngle += dt * 2;
            boss.flashTimer = Math.max(0, boss.flashTimer - dt);
            // Slowly chase player
            const bdx = player.x - boss.x, bdy = player.y - boss.y;
            const bdist = Math.sqrt(bdx*bdx + bdy*bdy) || 1;
            boss.vx += (bdx/bdist) * boss.speed * dt * 2;
            boss.vy += (bdy/bdist) * boss.speed * dt * 2;
            const bspd = Math.sqrt(boss.vx*boss.vx + boss.vy*boss.vy);
            if (bspd > boss.speed) { boss.vx = (boss.vx/bspd)*boss.speed; boss.vy = (boss.vy/bspd)*boss.speed; }
            boss.x += boss.vx * dt; boss.y += boss.vy * dt;
            boss.trail.push({ x: boss.x, y: boss.y, life: 1 });
            if (boss.trail.length > 10) boss.trail.shift();
            boss.trail.forEach(t => t.life -= 0.08);
            // Boss collision
            const bcd = Math.sqrt((player.x-boss.x)**2 + (player.y-boss.y)**2);
            if (bcd < player.radius + boss.radius) {
                if (dash.invincible || activePowerups.shield > 0) {
                    boss.hp--;
                    boss.flashTimer = 0.3;
                    shakeAmount = 15;
                    playSound(150, 0.3, 'sawtooth', 0.2);
                    // Knockback boss
                    const kbx = boss.x - player.x, kby = boss.y - player.y;
                    const kbd = Math.sqrt(kbx*kbx + kby*kby) || 1;
                    boss.vx = (kbx/kbd) * 300; boss.vy = (kby/kbd) * 300;
                    // Hit particles
                    for (let i = 0; i < 12; i++) {
                        const a = Math.random() * Math.PI * 2, sp = 150 + Math.random() * 100;
                        particles.push({ x: boss.x, y: boss.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.6, decay: 0.025, size: 3, color: '#ff4400' });
                    }
                    spawnFloatingText(boss.x, boss.y - 30, `üí• ${boss.hp > 0 ? boss.hp + ' HP' : 'DEFEATED!'}`, '#ff8800', 22, 1.2);
                    if (boss.hp <= 0) {
                        // Boss defeated!
                        score += 1000 * wave;
                        killCount += 3;
                        spawnFloatingText(boss.x, boss.y - 60, `+${1000 * wave} BOSS KILL!`, '#ffdd00', 28, 2.5);
                        rings.push({ x: boss.x, y: boss.y, radius: 10, maxRadius: Math.max(WIDTH,HEIGHT)*0.7, speed: 400, life: 1, color: '#ff8800', width: 4 });
                        // Big explosion
                        for (let i = 0; i < 40; i++) {
                            const a = Math.random() * Math.PI * 2, sp = 100 + Math.random() * 250;
                            particles.push({ x: boss.x, y: boss.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 1.2, decay: 0.015, size: 2+Math.random()*5, color: ['#ff4400','#ffdd00','#ff8800','#ffffff'][Math.floor(Math.random()*4)] });
                        }
                        // Drop lots of orbs
                        for (let i = 0; i < 12; i++) {
                            const oa = Math.random() * Math.PI * 2, ospd = 60 + Math.random() * 100;
                            scoreOrbs.push({ x: boss.x, y: boss.y, vx: Math.cos(oa)*ospd, vy: Math.sin(oa)*ospd, life: 5, value: 50, radius: 5, pulse: Math.random() * Math.PI * 2 });
                        }
                        // Guaranteed power-up drop
                        const types = ['shield', 'slowmo', 'magnet'];
                        const colors = { shield: '#00aaff', slowmo: '#ff00ff', magnet: '#ffff00' };
                        const symbols = { shield: 'üõ°', slowmo: '‚è≥', magnet: 'üß≤' };
                        const t = types[Math.floor(Math.random() * types.length)];
                        powerups.push({ x: boss.x, y: boss.y, type: t, color: colors[t], symbol: symbols[t], radius: 14, pulse: 0, life: 10 });
                        playSound(800, 0.3, 'sine', 0.15);
                        setTimeout(() => playSound(1200, 0.2, 'sine', 0.12), 100);
                        setTimeout(() => playSound(1600, 0.15, 'sine', 0.1), 200);
                        sessionBossKilled = true; checkAchievements();
                        boss = null;
                    }
                } else {
                    endGame();
                }
            }
        }
        checkCollisions();

        // Floating texts update
        floatingTexts.forEach(ft => { ft.x += ft.vx * dt; ft.y += ft.vy * dt; ft.duration -= dt; });
        compactInPlace(floatingTexts, ft => ft.duration > 0);
        if (floatingTexts.length > 20) floatingTexts.splice(0, floatingTexts.length - 20);

        // Achievement toasts
        updateAchievementToasts(dt);

        // Edge warnings
        edgeWarnings.forEach(w => w.life -= dt * 2);
        compactInPlace(edgeWarnings, w => w.life > 0);

        // Speed lines update
        speedLines.forEach(l => l.life -= l.decay);
        compactInPlace(speedLines, l => l.life > 0);
        if (dash.active) spawnSpeedLines();

        // Proximity heartbeat ‚Äî find closest enemy, beat faster when near
        let closestEnemyDist = Infinity;
        enemies.forEach(e => {
            const dx = player.x - e.x, dy = player.y - e.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d < closestEnemyDist) closestEnemyDist = d;
        });
        if (closestEnemyDist < 150 && enemies.length > 0) {
            const closeness = 1 - closestEnemyDist / 150; // 0-1, 1 = touching
            const beatRate = 0.6 - closeness * 0.45; // 0.6s to 0.15s between beats
            proximityBeatTimer += dt;
            if (proximityBeatTimer >= beatRate) {
                proximityBeatTimer = 0;
                playProximityBeat(closeness);
            }
        } else {
            proximityBeatTimer = 0;
        }

        // Dash afterimages ‚Äî capture player ghost every few frames during dash
        if (dash.active && Math.random() < 0.7) {
            dashAfterimages.push({
                x: player.x, y: player.y,
                angle: Math.atan2(player.vy, player.vx),
                life: 0.35, maxLife: 0.35
            });
        }
        dashAfterimages.forEach(a => a.life -= dt);
        compactInPlace(dashAfterimages, a => a.life > 0);
        if (dashAfterimages.length > 15) dashAfterimages.splice(0, dashAfterimages.length - 15);

        // Danger border pulse ‚Äî intensifies with enemy count
        dangerPulse += dt * 3;

        if (shakeAmount > 0) { shakeAmount *= 0.9; if (shakeAmount < 0.1) shakeAmount = 0; }
    }

    function updateDying(dt) {
        deathSlowmo -= dt;
        const slowFactor = 0.05 + 0.15 * (1 - deathSlowmo / deathSlowmoDuration);
        // Still update particles slowly for dramatic effect
        particles.forEach(p => { p.x += p.vx * dt * slowFactor; p.y += p.vy * dt * slowFactor; p.life -= p.decay * slowFactor; });
        compactInPlace(particles, p => p.life > 0);
        // Atmospheric particles ‚Äî ambient weather per wave
        if (settings.particles && atmosphere.length < ATMO_MAX && Math.random() < 0.15) spawnAtmoParticle();
        atmosphere.forEach(a => { a.x += a.vx * dt; a.y += a.vy * dt; a.vx += (Math.random()-0.5) * 2 * dt; a.life -= dt; });
        compactInPlace(atmosphere, a => a.life > 0 && a.x > -20 && a.x < WIDTH+20 && a.y > -20 && a.y < HEIGHT+20);
        // Death shards ‚Äî spin and drift
        deathShards.forEach(s => {
            s.x += s.vx * dt * slowFactor;
            s.y += s.vy * dt * slowFactor;
            s.rotation += s.rotSpeed * dt * slowFactor;
            s.life -= s.decay * slowFactor;
            s.vx *= 0.995; s.vy *= 0.995;
        });
        compactInPlace(deathShards, s => s.life > 0);
        // Enemies slow to crawl
        enemies.forEach(e => { e.x += e.vx * dt * slowFactor; e.y += e.vy * dt * slowFactor; });
        laserBarriers.forEach(lb => { lb.angle += lb.rotSpeed * dt * slowFactor; lb.life -= dt * slowFactor; });
        updateStars(dt * slowFactor);
        if (shakeAmount > 0) { shakeAmount *= 0.95; if (shakeAmount < 0.1) shakeAmount = 0; }
        if (deathSlowmo <= 0) finalizeDeath();
    }

    function updatePlayer(dt) {
        const accel = 800, maxSpeed = dash.active ? dash.speed : 400, friction = 0.85;
        if (keys['w'] || keys['arrowup']) player.vy -= accel * dt;
        if (keys['s'] || keys['arrowdown']) player.vy += accel * dt;
        if (keys['a'] || keys['arrowleft']) player.vx -= accel * dt;
        if (keys['d'] || keys['arrowright']) player.vx += accel * dt;

        if (mouse.active && gameState === 'playing') {
            const dx = mouse.x - player.x, dy = mouse.y - player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 5) { player.vx += (dx/dist)*accel*dt*0.5; player.vy += (dy/dist)*accel*dt*0.5; }
        }
        if (touch.active) {
            const dx = touch.x - player.x, dy = touch.y - player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 5) { player.vx += (dx/dist)*accel*dt; player.vy += (dy/dist)*accel*dt; }
        }

        player.vx *= friction; player.vy *= friction;
        const speed = Math.sqrt(player.vx*player.vx + player.vy*player.vy);
        if (speed > maxSpeed) { player.vx = (player.vx/speed)*maxSpeed; player.vy = (player.vy/speed)*maxSpeed; }

        player.x += player.vx * dt;
        player.y += player.vy * dt;
        const oldX = player.x, oldY = player.y;
        player.x = Math.max(player.radius, Math.min(WIDTH - player.radius, player.x));
        player.y = Math.max(player.radius, Math.min(HEIGHT - player.radius, player.y));
        // Wall sparks on edge collision
        const wallSpeed = Math.sqrt(player.vx*player.vx + player.vy*player.vy);
        if (wallSpeed > 80 && (player.x !== oldX || player.y !== oldY)) {
            const wx = player.x !== oldX ? player.x : player.x;
            const wy = player.y !== oldY ? player.y : player.y;
            for (let i = 0; i < 4; i++) {
                const a = Math.random() * Math.PI * 2;
                const sp = 60 + Math.random() * 100;
                particles.push({ x: wx, y: wy, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.3, decay: 0.04, size: 1.5, color: '#00ff88' });
            }
            shakeAmount = Math.max(shakeAmount, 2);
            playWallSparkSound();
        }

        player.trail.push({ x: player.x, y: player.y, life: 1 });
        if (player.trail.length > (dash.active ? 25 : 15)) player.trail.shift();
        player.trail.forEach(t => t.life -= 0.05);
    }

    function spawnEnemy() {
        const r = Math.random();
        // Sniper spawns from wave 3+, 12% chance
        const burstThresh = dailyMods.burstChance >= 0 ? (1 - dailyMods.burstChance) : 0.8;
        const type = (wave >= 3 && r < 0.12) ? 'sniper' : r < 0.5 ? 'basic' : r < burstThresh ? 'homing' : 'burst';
        const side = Math.floor(Math.random() * 4);
        let x, y;
        if (side === 0) { x = Math.random() * WIDTH; y = -20; }
        else if (side === 1) { x = WIDTH + 20; y = Math.random() * HEIGHT; }
        else if (side === 2) { x = Math.random() * WIDTH; y = HEIGHT + 20; }
        else { x = -20; y = Math.random() * HEIGHT; }

        const dx = player.x - x, dy = player.y - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const speed = (type === 'sniper' ? 20 * difficulty : (50 + Math.random() * 50) * difficulty) * dailyMods.enemySpeedMult;

        const colors = { basic: '#ff0044', homing: '#ffaa00', burst: '#ff00ff', sniper: '#ff4444' };
        const radii = { basic: 8 * dailyMods.enemyRadiusMult, homing: 10 * dailyMods.enemyRadiusMult, burst: 12 * dailyMods.enemyRadiusMult, sniper: 9 * dailyMods.enemyRadiusMult };

        enemies.push({
            x, y, vx: (dx/dist)*speed, vy: (dy/dist)*speed,
            type, radius: radii[type], color: colors[type], grazed: false,
            burstTimer: type === 'burst' ? 2 + Math.random() : 0,
            // Sniper: locks position, charges laser sight, then fires fast projectile
            sniperPhase: type === 'sniper' ? 'approach' : null,
            sniperTimer: type === 'sniper' ? 1.5 : 0, // approach time
            sniperAimX: 0, sniperAimY: 0, sniperChargeTime: 1.2,
            trail: []
        });
        playSound(type === 'sniper' ? 200 : 400, 0.05, 'sine', 0.02);
        // Edge warning
        edgeWarnings.push({ x, y, life: 0.5, color: colors[type] || '#ff0044' });
    }

    function updateEnemies(dt) {
        const toAdd = [];
        enemies.forEach(e => {
            if (e.type === 'homing') {
                const dx = player.x - e.x, dy = player.y - e.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const turnSpeed = 100 * difficulty;
                e.vx += (dx/dist)*turnSpeed*dt; e.vy += (dy/dist)*turnSpeed*dt;
                const sp = Math.sqrt(e.vx*e.vx + e.vy*e.vy);
                const ms = 200 * difficulty;
                if (sp > ms) { e.vx = (e.vx/sp)*ms; e.vy = (e.vy/sp)*ms; }
            }
            if (e.type === 'burst') {
                e.burstTimer -= dt;
                if (e.burstTimer <= 0) {
                    for (let i = 0; i < 4; i++) {
                        const a = (Math.PI * 2 / 4) * i;
                        toAdd.push({
                            x: e.x, y: e.y,
                            vx: Math.cos(a) * 150 * difficulty, vy: Math.sin(a) * 150 * difficulty,
                            type: 'basic', radius: 5, color: '#ff66ff', grazed: false, burstTimer: 0, trail: []
                        });
                    }
                    for (let i = 0; i < 8; i++) {
                        const a = Math.random() * Math.PI * 2;
                        particles.push({ x: e.x, y: e.y, vx: Math.cos(a)*120, vy: Math.sin(a)*120, life: 0.5, decay: 0.03, size: 2, color: '#ff00ff' });
                    }
                    playSound(300, 0.15, 'square', 0.08);
                    e.life = 0;
                }
            }
            // Sniper enemy: approach ‚Üí lock ‚Üí charge (laser sight) ‚Üí fire fast bullet
            if (e.type === 'sniper' && e.sniperPhase) {
                if (e.sniperPhase === 'approach') {
                    e.sniperTimer -= dt;
                    if (e.sniperTimer <= 0) {
                        e.sniperPhase = 'charge';
                        e.sniperTimer = e.sniperChargeTime;
                        e.vx = 0; e.vy = 0; // Stop moving
                        // Lock aim at player's current position
                        e.sniperAimX = player.x; e.sniperAimY = player.y;
                        playSound(150, 0.3, 'sawtooth', 0.04); // Charging sound
                    }
                } else if (e.sniperPhase === 'charge') {
                    e.sniperTimer -= dt;
                    // Update aim to track player slowly during charge (slight tracking)
                    const aimDx = player.x - e.sniperAimX, aimDy = player.y - e.sniperAimY;
                    e.sniperAimX += aimDx * dt * 0.8;
                    e.sniperAimY += aimDy * dt * 0.8;
                    if (e.sniperTimer <= 0) {
                        // Fire!
                        const fdx = e.sniperAimX - e.x, fdy = e.sniperAimY - e.y;
                        const fd = Math.sqrt(fdx*fdx + fdy*fdy) || 1;
                        const bulletSpeed = 500 * difficulty;
                        toAdd.push({
                            x: e.x, y: e.y,
                            vx: (fdx/fd)*bulletSpeed, vy: (fdy/fd)*bulletSpeed,
                            type: 'basic', radius: 5, color: '#ff6666', grazed: false, burstTimer: 0, trail: []
                        });
                        // Fire VFX
                        playSound(800, 0.08, 'square', 0.15);
                        shakeAmount = Math.max(shakeAmount, 4);
                        for (let i = 0; i < 6; i++) {
                            const a = Math.atan2(fdy, fdx) + (Math.random()-0.5)*0.5;
                            const sp = 100 + Math.random()*100;
                            particles.push({ x: e.x, y: e.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.3, decay: 0.04, size: 2, color: '#ff4444' });
                        }
                        e.life = 0; // Sniper disappears after firing
                    }
                }
            }
            e.x += e.vx * dt; e.y += e.vy * dt;
            // Enemy trail
            e.trail.push({ x: e.x, y: e.y, life: 1 });
            if (e.trail.length > 8) e.trail.shift();
            e.trail.forEach(t => t.life -= 0.12);
        });
        compactInPlace(enemies, e => e.life !== 0 && e.x > -100 && e.x < WIDTH+100 && e.y > -100 && e.y < HEIGHT+100);
        enemies.push(...toAdd);
    }

    function updatePowerups(dt) {
        powerups.forEach(p => {
            p.life -= dt; p.pulse += dt * 3;
            // Magnet effect ‚Äî pull toward player
            if (activePowerups.magnet > 0) {
                const dx = player.x - p.x, dy = player.y - p.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 10 && dist < 300) {
                    p.x += (dx/dist) * 200 * dt;
                    p.y += (dy/dist) * 200 * dt;
                }
            }
        });
        compactInPlace(powerups, p => p.life > 0);
    }

    function updateParticles(dt) {
        particles.forEach(p => { p.x += p.vx*dt; p.y += p.vy*dt; p.vx *= 0.98; p.vy *= 0.98; p.life -= p.decay; });
        compactInPlace(particles, p => p.life > 0);
        // Cap particles to prevent memory issues during intense gameplay
        const maxParticles = settings.particles ? 200 : 50;
        if (particles.length > maxParticles) particles.splice(0, particles.length - maxParticles);
        // Blast rings
        blastRings.forEach(br => br.life -= dt);
        compactInPlace(blastRings, br => br.life > 0);
    }

    // === ENVIRONMENT ATMOSPHERE SYSTEM ===
    // Wave-dependent weather: aurora bands + lightning on high waves
    let envLightning = { active: false, timer: 0, alpha: 0, nextStrike: 3 + Math.random() * 5 };
    let auroraPhase = 0;

    function updateEnvironment(dt) {
        auroraPhase += dt * 0.4;
        // Lightning system ‚Äî triggers on wave 7+ with dramatic flash + sound
        if (wave >= 7 && gameState === 'playing') {
            envLightning.nextStrike -= dt;
            if (envLightning.nextStrike <= 0) {
                envLightning.active = true;
                envLightning.timer = 0.35;
                envLightning.alpha = 0.5 + Math.random() * 0.3;
                envLightning.nextStrike = 4 + Math.random() * 8 - Math.min(wave * 0.3, 3);
                // Thunder sound ‚Äî low rumble
                if (audioCtx && !muted) {
                    const noise = audioCtx.createOscillator();
                    const g = audioCtx.createGain();
                    noise.type = 'sawtooth';
                    noise.frequency.setValueAtTime(60, audioCtx.currentTime);
                    noise.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.4);
                    g.gain.setValueAtTime(0.06 * masterVolume, audioCtx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
                    noise.connect(g); g.connect(audioCtx.destination);
                    noise.start(); noise.stop(audioCtx.currentTime + 0.5);
                }
            }
            if (envLightning.timer > 0) envLightning.timer -= dt;
        }
    }

    function renderAurora() {
        if (gameState !== 'playing' && gameState !== 'dying') return;
        // Aurora bands ‚Äî wave-colored sine waves across the top third
        const bands = Math.min(3, 1 + Math.floor(wave / 3));
        const baseHue = ((wave - 1) * 40) % 360;
        ctx.save();
        for (let b = 0; b < bands; b++) {
            const yBase = HEIGHT * (0.08 + b * 0.07);
            const hue = (baseHue + b * 60) % 360;
            const amp = 15 + Math.sin(auroraPhase * 0.7 + b) * 8;
            const alpha = 0.025 + flowZoneIntensity * 0.02;
            ctx.beginPath();
            ctx.moveTo(0, yBase);
            for (let x = 0; x <= WIDTH; x += 8) {
                const y = yBase + Math.sin(x * 0.008 + auroraPhase + b * 1.5) * amp
                    + Math.sin(x * 0.003 - auroraPhase * 0.6) * amp * 0.5;
                ctx.lineTo(x, y);
            }
            ctx.lineTo(WIDTH, 0);
            ctx.lineTo(0, 0);
            ctx.closePath();
            ctx.fillStyle = `hsla(${hue}, 80%, 55%, ${alpha})`;
            ctx.fill();
        }
        ctx.restore();

        // Lightning flash overlay
        if (envLightning.timer > 0) {
            const t = envLightning.timer / 0.35;
            // Double-flash pattern (realistic lightning)
            const flash = t > 0.7 ? (t - 0.7) / 0.3 : t < 0.3 ? t / 0.3 * 0.4 : 0;
            if (flash > 0) {
                ctx.fillStyle = `rgba(180,200,255,${flash * envLightning.alpha * 0.15})`;
                ctx.fillRect(0, 0, WIDTH, HEIGHT);
            }
        }
    }

    function updateStars(dt) {
        stars.forEach(s => {
            s.y += s.speed;
            s.twinkle += s.twinkleSpeed * dt;
            // Parallax: deeper layers react slightly to player movement
            if (gameState === 'playing' && s.layer > 0) {
                s.x -= player.vx * dt * s.layer * 0.015;
            }
            if (s.y > HEIGHT) { s.y = 0; s.x = Math.random() * WIDTH; }
            if (s.x < 0) s.x = WIDTH;
            if (s.x > WIDTH) s.x = 0;
        });
    }

    function checkCollisions() {
        // Enemy collisions
        enemies.forEach(e => {
            const dx = player.x - e.x, dy = player.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < player.radius + e.radius) {
                if (dash.invincible || activePowerups.shield > 0) {
                    // Destroy enemy ‚Äî satisfying explosion
                    e.life = 0; killCount++; waveKills++;
                    if (dash.invincible) sessionDashKill = true;
                    killStreak++; killStreakTimer = 1.5;
                    scoreMultTarget = Math.min(MULT_MAX, scoreMultTarget + 0.25); scoreMultDecayTimer = MULT_DECAY_DELAY; scoreMultPulse = 0.5;
                    if (killStreak === 3) { killStreakAnnounce = 'TRIPLE KILL!'; killStreakAnnounceTimer = 1.2; playSound(1000, 0.15, 'square', 0.1); }
                    else if (killStreak === 5) { killStreakAnnounce = 'RAMPAGE!'; killStreakAnnounceTimer = 1.2; playSound(1200, 0.2, 'square', 0.12); }
                    else if (killStreak >= 8) { killStreakAnnounce = 'UNSTOPPABLE!'; killStreakAnnounceTimer = 1.5; playSound(1500, 0.25, 'square', 0.15); }
                    shakeAmount = 10;
                    // Type-specific death effects
                    if (e.type === 'burst') {
                        // Starburst: 3 rings expanding outward
                        for (let ring = 0; ring < 3; ring++) {
                            for (let i = 0; i < 8; i++) {
                                const a = (Math.PI * 2 / 8) * i + ring * 0.3;
                                const sp = 120 + ring * 80;
                                particles.push({ x: e.x, y: e.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.8, decay: 0.018, size: 3 + Math.random()*2, color: ['#ff00ff','#ff44aa','#ff88cc'][ring] });
                            }
                        }
                    } else if (e.type === 'homing') {
                        // Spiral outward
                        for (let i = 0; i < 20; i++) {
                            const a = (Math.PI * 2 / 20) * i;
                            const sp = 100 + i * 15;
                            const spin = a + i * 0.4;
                            particles.push({ x: e.x, y: e.y, vx: Math.cos(spin)*sp, vy: Math.sin(spin)*sp, life: 0.9, decay: 0.018, size: 2 + Math.random()*2, color: i % 2 ? '#ffaa00' : '#ffdd44' });
                        }
                    } else if (e.type === 'sniper') {
                        // Laser flash ‚Äî lines radiating out
                        for (let i = 0; i < 6; i++) {
                            const a = (Math.PI / 3) * i;
                            for (let j = 0; j < 4; j++) {
                                const sp = 150 + j * 60;
                                particles.push({ x: e.x, y: e.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.5, decay: 0.025, size: 1.5, color: '#ff4444' });
                            }
                        }
                        flashColor = '#ff2222'; flashAlpha = 0.15;
                    } else {
                        // Default ring burst for basic enemies
                        for (let i = 0; i < 16; i++) {
                            const a = (Math.PI * 2 / 16) * i;
                            const sp = 180 + Math.random() * 80;
                            particles.push({ x: e.x, y: e.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.7, decay: 0.02, size: 2 + Math.random()*3, color: e.color });
                        }
                    }
                    // Center flash
                    particles.push({ x: e.x, y: e.y, vx: 0, vy: 0, life: 0.4, decay: 0.04, size: e.radius * 3, color: '#fff' });
                    // Score popup
                    particles.push({ x: e.x, y: e.y - 15, vx: 0, vy: -70, life: 1, decay: 0.02, size: 0, color: '#ffff00', text: '+100' });
                    playSound(500, 0.1, 'square', 0.12);
                    setTimeout(() => playSound(700, 0.08, 'sine', 0.08), 50);
                    score += 100;
                    // Spawn score orbs from killed enemy
                    const orbCount = 2 + Math.floor(Math.random() * 2);
                    for (let oi = 0; oi < orbCount; oi++) {
                        const oa = Math.random() * Math.PI * 2;
                        const ospd = 40 + Math.random() * 80;
                        scoreOrbs.push({ x: e.x, y: e.y, vx: Math.cos(oa)*ospd, vy: Math.sin(oa)*ospd, life: 4, value: 25, radius: 4, pulse: Math.random() * Math.PI * 2 });
                    }
                } else {
                    endGame();
                }
            }
            // Graze
            const grazeDist = (player.radius + e.radius + 25) * grazeExpand * dailyMods.grazeRangeMult;
            if (!e.grazed && dist < grazeDist && dist > player.radius + e.radius) {
                e.grazed = true; grazeCount++; waveGrazes++; comboCount++; comboTimer = 2 * dailyMods.comboTimerMult;
                // Score multiplier boost
                scoreMultTarget = Math.min(MULT_MAX, scoreMultTarget + 0.15); scoreMultDecayTimer = MULT_DECAY_DELAY; scoreMultPulse = 0.5;
                if (comboCount > comboBest) comboBest = comboCount;
                checkAchievements();
                playGrazeStreakSound(comboCount);
                // Hit freeze ‚Äî brief pause for game feel (scales with combo)
                hitFreezeTimer = Math.min(0.06, 0.03 + comboCount * 0.003);
                // Combo announcement
                const cAnn = getComboAnnouncement(comboCount);
                if (cAnn) {
                    comboAnnounce = cAnn.text; comboAnnounceTimer = 1.5; comboAnnounceColor = cAnn.color; comboAnnounceScale = 1.5;
                    playSound(cAnn.sound, 0.12, 'square', 0.1);
                    shakeAmount = Math.max(shakeAmount, 3 + comboCount * 0.5);
                }
                // Near-death bullet time ‚Äî very close grazes trigger micro slow-mo
                const closeness = dist - (player.radius + e.radius);
                if (closeness < 8) {
                    bulletTime = bulletTimeDuration;
                    flashColor = '#ffffff'; flashAlpha = 0.25;
                    shakeAmount = Math.max(shakeAmount, 6);
                    // Perfect dodge reward ‚Äî bonus score + dramatic feedback
                    const dodgeBonus = Math.floor(100 * scoreMult * (closeness < 3 ? 2 : 1));
                    score += dodgeBonus;
                    perfectDodgeCount++;
                    const dodgeLabel = closeness < 3 ? '‚ö° PERFECT DODGE!' : '‚úß CLOSE CALL!';
                    const dodgeColor = closeness < 3 ? '#ffffff' : '#ccddff';
                    particles.push({ x: player.x, y: player.y - player.radius - 20, vx: 0, vy: -100, life: 1.2, decay: 0.018, size: 0, color: dodgeColor, text: dodgeLabel });
                    particles.push({ x: player.x + 20, y: player.y - player.radius - 8, vx: 30, vy: -60, life: 0.8, decay: 0.025, size: 0, color: '#ffdd00', text: `+${dodgeBonus}` });
                    // Extra dramatic particles for near-death
                    for (let nd = 0; nd < 10; nd++) {
                        const na = Math.random()*Math.PI*2, ns = Math.random()*200+80;
                        particles.push({ x: player.x, y: player.y, vx: Math.cos(na)*ns, vy: Math.sin(na)*ns, life: 0.5, decay: 0.03, size: 1+Math.random()*2, color: '#ffffff' });
                    }
                    // Perfect dodge sound ‚Äî ascending chime
                    playSound(1400, 0.08, 'sine', 0.12);
                    setTimeout(() => playSound(1800, 0.06, 'sine', 0.08), 40);
                    setTimeout(() => playSound(2200, 0.04, 'sine', 0.06), 80);
                } else {
                    flashColor = '#00ffff'; flashAlpha = 0.1 + comboCount * 0.02;
                }
                const mx = (player.x+e.x)/2, my = (player.y+e.y)/2;
                for (let p = 0; p < 6; p++) {
                    const a = Math.random()*Math.PI*2, sp = Math.random()*120+40;
                    particles.push({ x: mx, y: my, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.6, decay: 0.025, size: Math.random()*3+1, color: comboCount>3?'#ffff00':'#00ffff' });
                }
                particles.push({ x: mx, y: my-10, vx: 0, vy: -80, life: 0.8, decay: 0.025, size: 0, color: comboCount>3?'#ffff00':'#00ffff', text: comboCount>1?`x${comboCount}`:'+50' });
            }
        });
        compactInPlace(enemies, e => e.life !== 0);

        // Danger proximity ‚Äî smoothed measure of nearest enemy distance
        let minEnemyDist = 999;
        for (let i = 0; i < enemies.length; i++) {
            const dx = enemies[i].x - player.x, dy = enemies[i].y - player.y;
            const d = Math.sqrt(dx*dx + dy*dy) - enemies[i].radius - player.radius;
            if (d < minEnemyDist) minEnemyDist = d;
        }
        const targetDanger = minEnemyDist < 80 ? Math.max(0, 1 - minEnemyDist / 80) : 0;
        dangerProximity += (targetDanger - dangerProximity) * dt * 8;

        // Power-up collisions (iterate backwards for safe splice)
        for (let i = powerups.length - 1; i >= 0; i--) {
            const p = powerups[i];
            const dx = player.x - p.x, dy = player.y - p.y;
            if (Math.sqrt(dx*dx + dy*dy) < player.radius + p.radius) {
                collectPowerup(p);
                powerups.splice(i, 1);
            }
        }
    }

    // ============================================
    // RENDERING
    // ============================================
    function render() {
        // Dynamic background ‚Äî shifts hue with wave
        const isActive = (gameState === 'playing' || gameState === 'dying') && !paused;
        if (isActive) {
            const isDying = gameState === 'dying';
            const flowActive = flowZoneIntensity > 0.05;
            const flowKey = flowActive ? Math.floor(flowZoneIntensity * 10) : 0;
            if (!cachedBgGrad || bgGradWave !== wave || bgGradW !== WIDTH || bgGradH !== HEIGHT || bgGradDying !== isDying || (flowActive && bgGradFlow !== flowKey)) {
                const baseHue = isDying ? 0 : ((wave - 1) * 30) % 360;
                const waveHue = flowActive ? baseHue + flowZoneHueShift * 0.5 : baseHue;
                const sat = isDying ? '60%' : flowActive ? `${40 + flowZoneIntensity * 35}%` : '40%';
                const light = flowActive ? `${4 + flowZoneIntensity * 3}%` : '4%';
                cachedBgGrad = ctx.createRadialGradient(WIDTH/2, HEIGHT/2, 0, WIDTH/2, HEIGHT/2, HEIGHT * 0.9);
                cachedBgGrad.addColorStop(0, `hsla(${waveHue}, ${sat}, ${light}, 1)`);
                cachedBgGrad.addColorStop(0.5, `hsla(${waveHue + 20}, 50%, 2%, 1)`);
                cachedBgGrad.addColorStop(1, '#000');
                bgGradWave = wave; bgGradW = WIDTH; bgGradH = HEIGHT; bgGradDying = isDying; bgGradFlow = flowKey;
            }
            ctx.fillStyle = cachedBgGrad;
        } else {
            ctx.fillStyle = '#000';
        }
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        if (shakeAmount > 0 && settings.shake) { ctx.save(); ctx.translate((Math.random()-0.5)*shakeAmount, (Math.random()-0.5)*shakeAmount); }

        // Beat pulse overlay (subtle background throb)
        if (isActive && beatPulse > 0 && !muted) {
            ctx.fillStyle = `rgba(0,255,136,${beatPulse * 0.04})`;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
        }

        // Grid ‚Äî scrolls with player movement for parallax depth
        if (isActive) {
            const gridSize = 50;
            const gox = (-player.x * 0.15) % gridSize, goy = (-player.y * 0.15) % gridSize;
            const gridAlpha = 0.04 + flowZoneIntensity * 0.06;
            const gridHue = flowZoneIntensity > 0.05 ? `hsla(${(flowZoneHueShift * 2) % 360}, 100%, 60%, ${gridAlpha})` : `rgba(0,255,136,${gridAlpha})`;
            ctx.strokeStyle = gridHue; ctx.lineWidth = 1;
            for (let x = gox; x < WIDTH; x += gridSize) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,HEIGHT); ctx.stroke(); }
            for (let y = goy; y < HEIGHT; y += gridSize) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(WIDTH,y); ctx.stroke(); }
        }

        // Stars (parallax layers with twinkling)
        stars.forEach(s => {
            const baseAlpha = s.layer === 0 ? 0.3 : s.layer === 1 ? 0.5 : 0.8;
            const twinkleAlpha = baseAlpha * (0.5 + 0.5 * Math.sin(s.twinkle));
            ctx.fillStyle = `rgba(255,255,255,${twinkleAlpha})`;
            const twinkleSize = s.size * (0.8 + 0.2 * Math.sin(s.twinkle * 1.3));
            ctx.fillRect(s.x, s.y, twinkleSize, twinkleSize);
        });

        // Atmospheric weather particles
        if (isActive && atmosphere.length > 0) {
            atmosphere.forEach(a => {
                const alpha = Math.min(1, a.life / a.maxLife) * Math.min(1, (a.maxLife - a.life) * 3);
                if (alpha <= 0) return;
                ctx.globalAlpha = alpha;
                if (a.glow > 0) { ctx.shadowBlur = a.glow; ctx.shadowColor = a.color; }
                ctx.fillStyle = a.color;
                ctx.beginPath(); ctx.arc(a.x, a.y, a.size, 0, Math.PI * 2); ctx.fill();
                if (a.glow > 0) ctx.shadowBlur = 0;
            });
            ctx.globalAlpha = 1;
        }

        // Nebula clouds
        renderNebulae();

        // Aurora atmosphere
        renderAurora();

        // Attract mode enemies (menu/gameover background)
        if (gameState === 'menu' || gameState === 'gameover') renderAttractMode();

        // Gravity Wells rendering
        if (isActive && gravityWells.length > 0) {
            gravityWells.forEach(gw => {
                const active = gw.age > gw.warmup;
                const fadeIn = Math.min(1, gw.age / gw.warmup);
                const fadeOut = gw.life < 1 ? gw.life : 1;
                const alpha = fadeIn * fadeOut;
                ctx.save();
                ctx.translate(gw.x, gw.y);
                // Spinning rings
                for (let r = 0; r < 3; r++) {
                    const ringRadius = (gw.radius * 0.3) + r * (gw.radius * 0.2);
                    const ringAlpha = alpha * (active ? 0.4 : 0.15) * (1 - r * 0.25);
                    ctx.beginPath();
                    ctx.arc(0, 0, ringRadius, gw.angle + r * 0.8, gw.angle + r * 0.8 + Math.PI * 1.4);
                    ctx.strokeStyle = active ? `rgba(255,68,170,${ringAlpha})` : `rgba(255,68,170,${ringAlpha * 0.5})`;
                    ctx.lineWidth = 2 - r * 0.5;
                    ctx.shadowBlur = active ? 15 : 5;
                    ctx.shadowColor = '#ff44aa';
                    ctx.stroke();
                }
                // Center glow
                const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, gw.radius * 0.25);
                grad.addColorStop(0, `rgba(255,68,170,${alpha * (active ? 0.3 : 0.1)})`);
                grad.addColorStop(1, 'rgba(255,68,170,0)');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(0, 0, gw.radius * 0.25, 0, Math.PI * 2); ctx.fill();
                // Outer danger zone indicator
                if (active) {
                    ctx.beginPath(); ctx.arc(0, 0, gw.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255,68,170,${alpha * 0.08})`;
                    ctx.lineWidth = 1; ctx.setLineDash([5, 10]); ctx.stroke(); ctx.setLineDash([]);
                }
                ctx.shadowBlur = 0;
                ctx.restore();
            });
        }

        if (isActive) {
            // Ghost replay ‚Äî previous run's path
            if (ghostPlayback && ghostPlayback.length > 9 && settings.particles) {
                const gIdx = ghostFrame * 3;
                if (gIdx + 2 < ghostPlayback.length) {
                    const gx = ghostPlayback[gIdx], gy = ghostPlayback[gIdx+1], ga = ghostPlayback[gIdx+2];
                    // Draw ghost ship (faint, slightly smaller)
                    ctx.save();
                    ctx.globalAlpha = 0.15 + Math.sin(gameTime * 3) * 0.05;
                    ctx.translate(gx, gy); ctx.rotate(ga);
                    const gr = player.radius * 0.85;
                    ctx.strokeStyle = '#00ff88';
                    ctx.lineWidth = 1;
                    ctx.shadowBlur = 8; ctx.shadowColor = '#00ff8844';
                    ctx.beginPath();
                    ctx.moveTo(gr * 1.3, 0); ctx.lineTo(-gr * 0.8, -gr * 0.9);
                    ctx.lineTo(-gr * 0.4, 0); ctx.lineTo(-gr * 0.8, gr * 0.9);
                    ctx.closePath(); ctx.stroke();
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    // Ghost label (first 3 seconds only)
                    if (ghostFrame < 45) {
                        ctx.save();
                        ctx.globalAlpha = Math.max(0, 0.4 - ghostFrame / 112);
                        ctx.fillStyle = '#00ff88';
                        ctx.font = '10px Courier New';
                        ctx.textAlign = 'center';
                        ctx.fillText('GHOST', gx, gy - gr - 8);
                        ctx.restore();
                    }
                    ghostFrame++;
                }
            }

            // Player trail
            player.trail.forEach(t => {
                if (t.life > 0) {
                    ctx.globalAlpha = t.life * (dash.active ? 0.8 : 0.5);
                    ctx.fillStyle = dash.active ? '#88ffcc' : '#00ff88';
                    ctx.beginPath(); ctx.arc(t.x, t.y, player.radius * t.life * (dash.active ? 0.7 : 0.5), 0, Math.PI*2); ctx.fill();
                }
            });
            ctx.globalAlpha = 1;

            // Dash afterimages
            dashAfterimages.forEach(a => {
                const alpha = (a.life / a.maxLife) * 0.4;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(a.x, a.y);
                ctx.rotate(a.angle);
                ctx.fillStyle = '#00ff88';
                ctx.shadowBlur = 15; ctx.shadowColor = '#00ff88';
                const r = player.radius;
                ctx.beginPath();
                ctx.moveTo(r * 1.3, 0);
                ctx.lineTo(-r * 0.8, -r * 0.9);
                ctx.lineTo(-r * 0.4, 0);
                ctx.lineTo(-r * 0.8, r * 0.9);
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            // Shield visual
            if (activePowerups.shield > 0) {
                ctx.strokeStyle = '#00aaff';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.4 + Math.sin(gameTime * 6) * 0.2;
                ctx.shadowBlur = 15; ctx.shadowColor = '#00aaff';
                ctx.beginPath(); ctx.arc(player.x, player.y, player.radius + 10, 0, Math.PI*2); ctx.stroke();
                ctx.globalAlpha = 1; ctx.shadowBlur = 0;
            }

            // Dash invincibility glow
            if (dash.invincible) {
                ctx.strokeStyle = '#88ffcc'; ctx.lineWidth = 3; ctx.globalAlpha = 0.6;
                ctx.beginPath(); ctx.arc(player.x, player.y, player.radius + 6, 0, Math.PI*2); ctx.stroke();
                ctx.globalAlpha = 1;
            }

            // Player aura ring ‚Äî pulses with score multiplier
            if (scoreMult > 1.2) {
                const auraRadius = player.radius * (2 + scoreMult * 0.4);
                const auraAlpha = Math.min(0.25, (scoreMult - 1) * 0.08) * (0.6 + 0.4 * Math.sin(gameTime * 4));
                const multColors = ['#00ff88', '#00ffcc', '#ffaa00', '#ff44aa'];
                const ci = Math.min(Math.floor((scoreMult - 1) / 1.2), multColors.length - 1);
                ctx.beginPath(); ctx.arc(player.x, player.y, auraRadius, 0, Math.PI * 2);
                ctx.strokeStyle = multColors[ci]; ctx.lineWidth = 1.5; ctx.globalAlpha = auraAlpha;
                ctx.shadowBlur = 15; ctx.shadowColor = multColors[ci]; ctx.stroke();
                ctx.shadowBlur = 0; ctx.globalAlpha = 1;
            }

            // Edge proximity warning ‚Äî player glows warm when near walls
            const edgeMargin = 60;
            const edgeProxL = Math.max(0, 1 - player.x / edgeMargin);
            const edgeProxR = Math.max(0, 1 - (WIDTH - player.x) / edgeMargin);
            const edgeProxT = Math.max(0, 1 - player.y / edgeMargin);
            const edgeProxB = Math.max(0, 1 - (HEIGHT - player.y) / edgeMargin);
            const edgeProx = Math.max(edgeProxL, edgeProxR, edgeProxT, edgeProxB);
            if (edgeProx > 0) {
                const epAlpha = edgeProx * 0.35 * (0.6 + 0.4 * Math.sin(gameTime * 8));
                ctx.globalAlpha = epAlpha;
                ctx.fillStyle = '#ff4400';
                ctx.shadowBlur = 30; ctx.shadowColor = '#ff4400';
                ctx.beginPath(); ctx.arc(player.x, player.y, player.radius + 15 + edgeProx * 10, 0, Math.PI * 2); ctx.fill();
                ctx.shadowBlur = 0; ctx.globalAlpha = 1;
            }

            // Combo timer ring ‚Äî shows remaining time to chain next graze
            if (comboCount > 0 && comboTimer > 0) {
                const comboRingRadius = player.radius + 20;
                const comboFrac = comboTimer / 2; // 2s max
                const comboArc = comboFrac * Math.PI * 2;
                const comboRingColor = comboCount >= 10 ? '#ff00ff' : comboCount >= 5 ? '#ffaa00' : '#00ffff';
                const ringAlpha = 0.3 + comboFrac * 0.5;
                // Background ring (dark)
                ctx.beginPath(); ctx.arc(player.x, player.y, comboRingRadius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255,255,255,0.06)`; ctx.lineWidth = 3; ctx.stroke();
                // Active ring (draining clockwise from top)
                ctx.beginPath(); ctx.arc(player.x, player.y, comboRingRadius, -Math.PI/2, -Math.PI/2 + comboArc);
                ctx.strokeStyle = comboRingColor; ctx.lineWidth = 3; ctx.globalAlpha = ringAlpha;
                ctx.shadowBlur = 8; ctx.shadowColor = comboRingColor; ctx.stroke();
                ctx.shadowBlur = 0; ctx.globalAlpha = 1;
                // Combo count indicator at ring tip
                if (comboCount > 1) {
                    const tipAngle = -Math.PI/2 + comboArc;
                    const tipX = player.x + Math.cos(tipAngle) * comboRingRadius;
                    const tipY = player.y + Math.sin(tipAngle) * comboRingRadius;
                    ctx.fillStyle = comboRingColor; ctx.globalAlpha = ringAlpha;
                    ctx.beginPath(); ctx.arc(tipX, tipY, 4, 0, Math.PI * 2); ctx.fill();
                    ctx.globalAlpha = 1;
                }
            }

            // Flow Zone aura ‚Äî expanding concentric rings during high combo
            if (flowZoneIntensity > 0.05) {
                ctx.save();
                const fzHue = (flowZoneHueShift * 3) % 360;
                const ringCount = flowZoneIntensity > 0.6 ? 3 : flowZoneIntensity > 0.3 ? 2 : 1;
                for (let r = 0; r < ringCount; r++) {
                    const phase = (gameTime * (1.5 + r * 0.5) + r * 2.1) % 1;
                    const radius = player.radius + 20 + phase * 60 * (1 + flowZoneIntensity);
                    const alpha = (1 - phase) * flowZoneIntensity * 0.25;
                    ctx.beginPath(); ctx.arc(player.x, player.y, radius, 0, Math.PI * 2);
                    ctx.strokeStyle = `hsla(${fzHue + r * 40}, 100%, 65%, ${alpha})`;
                    ctx.lineWidth = 2 - phase * 1.5; ctx.stroke();
                }
                // Flow Zone radial glow behind player
                const glowR = player.radius * (3 + flowZoneIntensity * 2 + Math.sin(gameTime * 3) * 0.5);
                const glowGrad = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, glowR);
                glowGrad.addColorStop(0, `hsla(${fzHue}, 100%, 60%, ${flowZoneIntensity * 0.15})`);
                glowGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = glowGrad; ctx.fillRect(player.x - glowR, player.y - glowR, glowR * 2, glowR * 2);
                ctx.restore();
            }

            // Player (rotating triangle)
            ctx.save();
            ctx.translate(player.x, player.y);
            const angle = Math.atan2(player.vy, player.vx) || 0;
            ctx.rotate(angle);
            const comboGlow = Math.min(comboCount, 10);
            const baseShipColor = getShipColor(xpData.level);
            const playerHue = comboGlow > 5 ? `hsl(${160 - comboGlow * 8}, 100%, 60%)` : (activePowerups.shield > 0 ? '#44ccff' : baseShipColor);
            ctx.shadowBlur = 25 + comboGlow * 3; ctx.shadowColor = playerHue;
            ctx.fillStyle = playerHue;
            const r = player.radius;
            ctx.beginPath();
            ctx.moveTo(r * 1.3, 0);
            ctx.lineTo(-r * 0.8, -r * 0.9);
            ctx.lineTo(-r * 0.4, 0);
            ctx.lineTo(-r * 0.8, r * 0.9);
            ctx.closePath();
            ctx.fill();
            // Core glow
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(0, 0, r * 0.3, 0, Math.PI*2); ctx.fill();
            // Engine glow
            ctx.fillStyle = dash.active ? '#88ffcc' : 'rgba(0,255,136,0.5)';
            ctx.beginPath(); ctx.arc(-r * 0.5, 0, r * 0.25 + Math.random() * 2, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
            ctx.restore();

            // Speed lines
            speedLines.forEach(l => {
                ctx.globalAlpha = l.life * 0.6;
                ctx.strokeStyle = '#88ffcc'; ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(l.x, l.y);
                ctx.lineTo(l.x + Math.cos(l.angle)*l.length, l.y + Math.sin(l.angle)*l.length);
                ctx.stroke();
            });
            ctx.globalAlpha = 1;

            // Gravity wells
            gravityWells.forEach(gw => {
                const fade = gw.life / gw.maxLife;
                const r = gw.radius;
                ctx.save();
                // Outer ring
                ctx.strokeStyle = `rgba(170,0,255,${fade * 0.4})`;
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(gw.x, gw.y, r, 0, Math.PI * 2); ctx.stroke();
                // Spiral arms
                ctx.strokeStyle = `rgba(170,0,255,${fade * 0.6})`;
                ctx.lineWidth = 1.5;
                for (let arm = 0; arm < 3; arm++) {
                    ctx.beginPath();
                    const baseA = gw.angle + (Math.PI * 2 / 3) * arm;
                    for (let t = 0; t < 1; t += 0.02) {
                        const a = baseA + t * Math.PI * 2;
                        const sr = r * t;
                        const px = gw.x + Math.cos(a) * sr, py = gw.y + Math.sin(a) * sr;
                        t === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
                    }
                    ctx.stroke();
                }
                // Core glow
                const grad = ctx.createRadialGradient(gw.x, gw.y, 0, gw.x, gw.y, 30);
                grad.addColorStop(0, `rgba(170,0,255,${fade * 0.8})`);
                grad.addColorStop(1, 'rgba(170,0,255,0)');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(gw.x, gw.y, 30, 0, Math.PI * 2); ctx.fill();
                ctx.restore();
            });

            // Laser barriers
            laserBarriers.forEach(lb => {
                const cos = Math.cos(lb.angle), sin = Math.sin(lb.angle);
                const ax = lb.cx - cos * lb.halfLen, ay = lb.cy - sin * lb.halfLen;
                const bx = lb.cx + cos * lb.halfLen, by = lb.cy + sin * lb.halfLen;
                const isActive = lb.warmup <= 0;
                const fadeIn = Math.min(1, (lb.maxLife - lb.life) / 0.5);
                const fadeOut = Math.min(1, lb.life / 0.5);
                const alpha = fadeIn * fadeOut;
                ctx.save();
                if (isActive) {
                    // Lethal ‚Äî bright red with glow
                    ctx.strokeStyle = `rgba(255,34,68,${alpha * 0.9})`;
                    ctx.shadowColor = '#ff2244';
                    ctx.shadowBlur = 15;
                    ctx.lineWidth = lb.width;
                } else {
                    // Warning phase ‚Äî flickering yellow dashed
                    const flicker = Math.sin(lb.warmup * 20) > 0 ? 0.6 : 0.2;
                    ctx.strokeStyle = `rgba(255,221,0,${alpha * flicker})`;
                    ctx.shadowColor = '#ffdd00';
                    ctx.shadowBlur = 8;
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([8, 8]);
                }
                ctx.beginPath();
                ctx.moveTo(ax, ay);
                ctx.lineTo(bx, by);
                ctx.stroke();
                // Anchor point glow
                if (isActive) {
                    ctx.fillStyle = `rgba(255,34,68,${alpha * 0.6})`;
                    ctx.beginPath(); ctx.arc(lb.cx, lb.cy, 5, 0, Math.PI * 2); ctx.fill();
                }
                ctx.restore();
            });

            // Enemies (trails first, then bodies)
            let enemyIdx = 0;
            enemies.forEach(e => {
                const useShadow = enemyIdx < 10; // Limit shadowBlur to first 10 enemies for perf
                enemyIdx++;
                // Enemy trail
                e.trail.forEach(t => {
                    if (t.life > 0) {
                        ctx.globalAlpha = t.life * 0.3;
                        ctx.fillStyle = e.color;
                        ctx.beginPath(); ctx.arc(t.x, t.y, e.radius * t.life * 0.6, 0, Math.PI*2); ctx.fill();
                    }
                });
                ctx.globalAlpha = 1;
                if (useShadow) { ctx.shadowBlur = 15; ctx.shadowColor = e.color; }
                ctx.fillStyle = e.color;
                if (e.type === 'homing') {
                    // Diamond shape for homing
                    ctx.save(); ctx.translate(e.x, e.y);
                    ctx.rotate(Math.atan2(e.vy, e.vx));
                    ctx.beginPath();
                    ctx.moveTo(e.radius * 1.3, 0);
                    ctx.lineTo(0, -e.radius * 0.8);
                    ctx.lineTo(-e.radius * 0.8, 0);
                    ctx.lineTo(0, e.radius * 0.8);
                    ctx.closePath(); ctx.fill();
                    ctx.restore();
                } else if (e.type === 'burst') {
                    // Star shape for burst
                    ctx.save(); ctx.translate(e.x, e.y);
                    ctx.rotate(gameTime * 2);
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const a1 = (Math.PI * 2 / 5) * i - Math.PI / 2;
                        const a2 = a1 + Math.PI / 5;
                        ctx.lineTo(Math.cos(a1) * e.radius * 1.2, Math.sin(a1) * e.radius * 1.2);
                        ctx.lineTo(Math.cos(a2) * e.radius * 0.5, Math.sin(a2) * e.radius * 0.5);
                    }
                    ctx.closePath(); ctx.fill();
                    ctx.restore();
                } else {
                    // Circle for basic
                    ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2); ctx.fill();
                }
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.beginPath(); ctx.arc(e.x, e.y, e.radius * 0.4, 0, Math.PI*2); ctx.fill();
                // Burst timer visual
                if (e.type === 'burst' && e.burstTimer < 1) {
                    ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5 + Math.sin(gameTime * 15) * 0.5;
                    ctx.beginPath(); ctx.arc(e.x, e.y, e.radius + 5 + Math.sin(gameTime*10)*3, 0, Math.PI*2); ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                // Sniper laser sight ‚Äî red dashed line from sniper to aim point during charge
                if (e.type === 'sniper' && e.sniperPhase === 'charge') {
                    const chargeProgress = 1 - (e.sniperTimer / e.sniperChargeTime);
                    const laserAlpha = 0.15 + chargeProgress * 0.6;
                    const laserWidth = 1 + chargeProgress * 2;
                    ctx.save();
                    ctx.globalAlpha = laserAlpha;
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = laserWidth;
                    ctx.shadowBlur = 8 + chargeProgress * 15;
                    ctx.shadowColor = '#ff0000';
                    ctx.setLineDash([8, 6]);
                    ctx.lineDashOffset = -gameTime * 80;
                    ctx.beginPath();
                    ctx.moveTo(e.x, e.y);
                    ctx.lineTo(e.sniperAimX, e.sniperAimY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.shadowBlur = 0;
                    // Crosshair at aim point
                    if (chargeProgress > 0.3) {
                        const chSize = 8 + chargeProgress * 6;
                        ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 1.5;
                        ctx.globalAlpha = laserAlpha * 0.8;
                        ctx.beginPath(); ctx.arc(e.sniperAimX, e.sniperAimY, chSize, 0, Math.PI*2); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(e.sniperAimX - chSize - 4, e.sniperAimY); ctx.lineTo(e.sniperAimX + chSize + 4, e.sniperAimY); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(e.sniperAimX, e.sniperAimY - chSize - 4); ctx.lineTo(e.sniperAimX, e.sniperAimY + chSize + 4); ctx.stroke();
                    }
                    ctx.restore();
                }
                // Sniper body ‚Äî crosshair/scope shape
                if (e.type === 'sniper') {
                    ctx.save(); ctx.translate(e.x, e.y);
                    ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 2;
                    if (useShadow) { ctx.shadowBlur = 12; ctx.shadowColor = '#ff4444'; }
                    ctx.beginPath(); ctx.arc(0, 0, e.radius, 0, Math.PI*2); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(-e.radius*1.4, 0); ctx.lineTo(e.radius*1.4, 0); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, -e.radius*1.4); ctx.lineTo(0, e.radius*1.4); ctx.stroke();
                    ctx.fillStyle = '#ff4444'; ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();
                    ctx.shadowBlur = 0; ctx.restore();
                }
            });
            ctx.shadowBlur = 0;

            // Boss rendering
            if (boss) {
                // Trail
                boss.trail.forEach(t => {
                    if (t.life > 0) {
                        ctx.globalAlpha = t.life * 0.2;
                        ctx.fillStyle = '#ff4400';
                        ctx.beginPath(); ctx.arc(t.x, t.y, boss.radius * t.life * 0.5, 0, Math.PI*2); ctx.fill();
                    }
                });
                ctx.globalAlpha = 1;
                // Rotating shield ring
                ctx.save(); ctx.translate(boss.x, boss.y); ctx.rotate(boss.shieldAngle);
                ctx.strokeStyle = boss.flashTimer > 0 ? '#ffffff' : '#ff6600';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 20; ctx.shadowColor = '#ff4400';
                for (let i = 0; i < 3; i++) {
                    const a = (Math.PI * 2 / 3) * i;
                    ctx.beginPath(); ctx.arc(0, 0, boss.radius + 8 + Math.sin(boss.pulse)*3, a, a + 1.2); ctx.stroke();
                }
                // Body ‚Äî pulsing hexagon
                const br = boss.radius + Math.sin(boss.pulse) * 2;
                ctx.fillStyle = boss.flashTimer > 0 ? '#ffffff' : '#ff2200';
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const a = (Math.PI * 2 / 6) * i - Math.PI / 6;
                    ctx[i===0?'moveTo':'lineTo'](Math.cos(a)*br, Math.sin(a)*br);
                }
                ctx.closePath(); ctx.fill();
                // Core
                ctx.fillStyle = '#ffcc00'; ctx.shadowBlur = 10; ctx.shadowColor = '#ffcc00';
                ctx.beginPath(); ctx.arc(0, 0, br * 0.35, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
                // HP bar above boss
                const hpW = 50, hpH = 5;
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(boss.x - hpW/2, boss.y - boss.radius - 18, hpW, hpH);
                ctx.fillStyle = boss.hp > boss.maxHp/2 ? '#ff8800' : '#ff2200';
                ctx.fillRect(boss.x - hpW/2, boss.y - boss.radius - 18, hpW * (boss.hp/boss.maxHp), hpH);
                ctx.strokeStyle = '#ff6600'; ctx.lineWidth = 1;
                ctx.strokeRect(boss.x - hpW/2, boss.y - boss.radius - 18, hpW, hpH);
            }

            // Power-ups
            powerups.forEach(p => {
                const s = Math.sin(p.pulse) * 3;
                ctx.globalAlpha = p.life < 3 ? 0.3 + Math.sin(gameTime*10)*0.3 : 0.9;
                ctx.shadowBlur = 12; ctx.shadowColor = p.color;
                ctx.strokeStyle = p.color; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.radius + s, 0, Math.PI*2); ctx.stroke();
                ctx.font = '16px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.fillText(p.symbol, p.x, p.y);
                ctx.shadowBlur = 0;
            });
            ctx.globalAlpha = 1;

            // Score orbs
            scoreOrbs.forEach(o => {
                const glow = 0.5 + Math.sin(o.pulse) * 0.3;
                ctx.globalAlpha = Math.min(1, o.life) * glow;
                ctx.fillStyle = '#ffdd00';
                ctx.shadowBlur = 10; ctx.shadowColor = '#ffdd00';
                ctx.beginPath(); ctx.arc(o.x, o.y, o.radius + Math.sin(o.pulse) * 1.5, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(o.x, o.y, o.radius * 0.4, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
            });
            ctx.globalAlpha = 1;

            // Off-screen enemy warning indicators
            if (settings.particles) {
                const edgePad = 24, arrowSize = 8;
                enemies.forEach(e => {
                    const offL = e.x < -e.radius, offR = e.x > WIDTH + e.radius;
                    const offT = e.y < -e.radius, offB = e.y > HEIGHT + e.radius;
                    if (!offL && !offR && !offT && !offB) return;
                    // Only warn for enemies within ~300px of viewport edge
                    const dx = e.x < 0 ? -e.x : e.x > WIDTH ? e.x - WIDTH : 0;
                    const dy = e.y < 0 ? -e.y : e.y > HEIGHT ? e.y - HEIGHT : 0;
                    if (dx > 300 || dy > 300) return;
                    const clampX = Math.max(edgePad, Math.min(WIDTH - edgePad, e.x));
                    const clampY = Math.max(edgePad, Math.min(HEIGHT - edgePad, e.y));
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const alpha = Math.max(0.15, 0.7 - dist / 400);
                    const angle = Math.atan2(e.y - clampY, e.x - clampX);
                    const isBoss = e.radius > 20;
                    const col = isBoss ? '#ff6600' : e.color || '#ff0044';
                    ctx.save();
                    ctx.translate(clampX, clampY);
                    ctx.rotate(angle);
                    ctx.globalAlpha = alpha * (0.7 + 0.3 * Math.sin(gameTime * 6));
                    ctx.fillStyle = col;
                    ctx.shadowBlur = 8; ctx.shadowColor = col;
                    const sz = isBoss ? arrowSize * 1.4 : arrowSize;
                    ctx.beginPath();
                    ctx.moveTo(sz, 0);
                    ctx.lineTo(-sz * 0.6, -sz * 0.7);
                    ctx.lineTo(-sz * 0.6, sz * 0.7);
                    ctx.closePath();
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.restore();
                });
            }

            // Dash cooldown indicator (ring around player)
            if (dash.cooldown > 0) {
                const pct = 1 - dash.cooldown / dash.cooldownTime;
                ctx.strokeStyle = 'rgba(0,255,136,0.3)'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(player.x, player.y, player.radius + 18, -Math.PI/2, -Math.PI/2 + Math.PI*2*pct); ctx.stroke();
            }
            // Dash ready flash ‚Äî bright green ring burst when dash becomes available
            if (dashReadyFlash > 0) {
                const t = dashReadyFlash / 0.4;
                const expandR = player.radius + 18 + (1 - t) * 8;
                ctx.strokeStyle = `rgba(0,255,136,${t * 0.8})`; ctx.lineWidth = 2 + t * 2;
                ctx.shadowBlur = 15 * t; ctx.shadowColor = '#00ff88';
                ctx.beginPath(); ctx.arc(player.x, player.y, expandR, 0, Math.PI * 2); ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Combo timer bar ‚Äî drains urgently below player
            if (comboCount > 0 && comboTimer > 0) {
                const barW = 40 + comboCount * 4, barH = 3;
                const barX = player.x - barW/2, barY = player.y + player.radius + 22;
                const pct = comboTimer / 2;
                const barColor = pct > 0.5 ? '#00ffff' : pct > 0.25 ? '#ffaa00' : '#ff0044';
                ctx.globalAlpha = 0.7;
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(barX, barY, barW, barH);
                ctx.fillStyle = barColor;
                ctx.shadowBlur = 6; ctx.shadowColor = barColor;
                ctx.fillRect(barX, barY, barW * pct, barH);
                ctx.shadowBlur = 0; ctx.globalAlpha = 1;
            }

            // Combo streak ring ‚Äî grows and glows with combo count
            if (comboCount > 1 && comboTimer > 0) {
                const comboRing = player.radius + 24 + comboCount * 2;
                const comboAlpha = Math.min(0.6, 0.15 + comboCount * 0.05) * (comboTimer / 2);
                const hue = comboCount > 5 ? `hsl(${60 - comboCount * 3}, 100%, 60%)` : '#00ffff';
                ctx.strokeStyle = hue;
                ctx.lineWidth = 1 + comboCount * 0.3;
                ctx.globalAlpha = comboAlpha;
                ctx.shadowBlur = 10 + comboCount * 2; ctx.shadowColor = hue;
                ctx.beginPath(); ctx.arc(player.x, player.y, comboRing, 0, Math.PI*2); ctx.stroke();
                // Combo text above player
                if (comboCount >= 3) {
                    ctx.font = `bold ${14 + comboCount}px Courier New`; ctx.textAlign = 'center';
                    ctx.fillStyle = hue;
                    ctx.fillText(`x${comboCount}`, player.x, player.y - comboRing - 8);
                }
                ctx.globalAlpha = 1; ctx.shadowBlur = 0;
            }
        }

        // Particles
        particles.forEach(p => {
            ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
            if (p.text) {
                ctx.font = 'bold 16px Courier New'; ctx.textAlign = 'center';
                ctx.shadowBlur = 8; ctx.shadowColor = p.color;
                ctx.fillText(p.text, p.x, p.y); ctx.shadowBlur = 0;
            } else {
                ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
            }
        });
        ctx.globalAlpha = 1;

        // Blast rings
        blastRings.forEach(br => {
            const progress = 1 - br.life / 0.6;
            const r = br.maxRadius * progress;
            ctx.globalAlpha = br.life * 1.5;
            ctx.strokeStyle = br.color;
            ctx.lineWidth = 4 * (1 - progress) + 1;
            ctx.shadowBlur = 15; ctx.shadowColor = br.color;
            ctx.beginPath(); ctx.arc(br.x, br.y, r, 0, Math.PI * 2); ctx.stroke();
            // Inner ring
            ctx.globalAlpha = br.life * 0.5;
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(br.x, br.y, r * 0.7, 0, Math.PI * 2); ctx.stroke();
            ctx.shadowBlur = 0;
        });
        ctx.globalAlpha = 1;

        // Death shards ‚Äî spinning triangle fragments
        deathShards.forEach(s => {
            ctx.save();
            ctx.globalAlpha = Math.min(1, s.life * 1.5);
            ctx.translate(s.x, s.y);
            ctx.rotate(s.rotation);
            ctx.fillStyle = s.color;
            ctx.shadowBlur = 12; ctx.shadowColor = s.color;
            ctx.beginPath();
            ctx.moveTo(s.size, 0);
            ctx.lineTo(-s.size * 0.6, -s.size * 0.7);
            ctx.lineTo(-s.size * 0.6, s.size * 0.7);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.restore();
        });
        ctx.globalAlpha = 1;

        // Floating texts
        floatingTexts.forEach(ft => {
            const alpha = Math.min(1, ft.duration / (ft.maxDuration * 0.3));
            ctx.globalAlpha = alpha;
            ctx.font = `bold ${ft.size}px Courier New`;
            ctx.textAlign = 'center';
            ctx.fillStyle = ft.color;
            ctx.shadowBlur = 10; ctx.shadowColor = ft.color;
            ctx.fillText(ft.text, ft.x, ft.y);
            ctx.shadowBlur = 0;
        });
        ctx.globalAlpha = 1;

        // Achievement toasts
        renderAchievementToasts(ctx);

        // Screen flash
        if (flashAlpha > 0) {
            ctx.fillStyle = flashColor || '#fff'; ctx.globalAlpha = flashAlpha;
            ctx.fillRect(0, 0, WIDTH, HEIGHT); ctx.globalAlpha = 1; flashAlpha -= 0.015;
        }

        // Slow-mo tint
        if (activePowerups.slowmo > 0) {
            ctx.fillStyle = '#ff00ff'; ctx.globalAlpha = 0.06;
            ctx.fillRect(0, 0, WIDTH, HEIGHT); ctx.globalAlpha = 1;
        }

        // Bullet time tint ‚Äî white-blue pulse for near-death moments
        if (bulletTime > 0) {
            const btIntensity = bulletTime / bulletTimeDuration;
            ctx.fillStyle = '#aaddff'; ctx.globalAlpha = btIntensity * 0.12;
            ctx.fillRect(0, 0, WIDTH, HEIGHT); ctx.globalAlpha = 1;
            // Radial lines from player for dramatic effect
            if (gameState === 'playing') {
                ctx.globalAlpha = btIntensity * 0.3;
                ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1;
                for (let i = 0; i < 12; i++) {
                    const a = (Math.PI*2/12)*i + gameTime;
                    ctx.beginPath();
                    ctx.moveTo(player.x + Math.cos(a)*30, player.y + Math.sin(a)*30);
                    ctx.lineTo(player.x + Math.cos(a)*80, player.y + Math.sin(a)*80);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }
        }

        // Danger vignette ‚Äî radial darkening when enemies are very close
        if (isActive && dangerProximity > 0.1) {
            const vigAlpha = dangerProximity * 0.35;
            const vigGrad = ctx.createRadialGradient(player.x, player.y, HEIGHT * 0.2, player.x, player.y, HEIGHT * 0.7);
            vigGrad.addColorStop(0, 'rgba(0,0,0,0)');
            vigGrad.addColorStop(0.6, 'rgba(0,0,0,0)');
            vigGrad.addColorStop(1, `rgba(180,0,0,${vigAlpha})`);
            ctx.fillStyle = vigGrad;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
        }

        // Edge warnings
        if (isActive) {
            edgeWarnings.forEach(w => {
                // Clamp to screen edge
                let wx = Math.max(30, Math.min(WIDTH - 30, w.x));
                let wy = Math.max(30, Math.min(HEIGHT - 30, w.y));
                ctx.globalAlpha = w.life * 0.8;
                ctx.fillStyle = w.color;
                ctx.shadowBlur = 15; ctx.shadowColor = w.color;
                // Draw warning triangle
                ctx.save(); ctx.translate(wx, wy);
                const a = Math.atan2(HEIGHT/2 - wy, WIDTH/2 - wx);
                ctx.rotate(a);
                ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-6, -7); ctx.lineTo(-6, 7); ctx.closePath(); ctx.fill();
                ctx.restore();
                ctx.shadowBlur = 0;
            });
            ctx.globalAlpha = 1;

            // Danger border ‚Äî red glow intensifies with enemy count (cached gradients)
            if (enemies.length > 3) {
                buildDangerGradients();
                const intensity = Math.min(0.4, (enemies.length - 3) * 0.03) * (0.6 + Math.sin(dangerPulse) * 0.4);
                ctx.globalAlpha = intensity;
                ctx.fillStyle = cachedDanger.left; ctx.fillRect(0, 0, 40, HEIGHT);
                ctx.fillStyle = cachedDanger.right; ctx.fillRect(WIDTH-40, 0, 40, HEIGHT);
                ctx.fillStyle = cachedDanger.top; ctx.fillRect(0, 0, WIDTH, 40);
                ctx.fillStyle = cachedDanger.bottom; ctx.fillRect(0, HEIGHT-40, WIDTH, 40);
                ctx.globalAlpha = 1;
            }

            // Vignette (cached)
            if (!cachedVignette || vignetteW !== WIDTH || vignetteH !== HEIGHT) {
                cachedVignette = ctx.createRadialGradient(WIDTH/2, HEIGHT/2, HEIGHT*0.3, WIDTH/2, HEIGHT/2, HEIGHT*0.8);
                cachedVignette.addColorStop(0, 'transparent');
                cachedVignette.addColorStop(1, 'rgba(0,0,0,0.5)');
                vignetteW = WIDTH; vignetteH = HEIGHT;
            }
            ctx.fillStyle = cachedVignette;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Flow Zone screen edge glow ‚Äî positive energy borders during combo streaks
            if (flowZoneIntensity > 0.05) {
                const fzH = (flowZoneHueShift * 2) % 360;
                const fzAlpha = flowZoneIntensity * 0.15 * (0.7 + 0.3 * Math.sin(gameTime * 4));
                const edgeW = 30 + flowZoneIntensity * 20;
                ctx.globalAlpha = fzAlpha;
                const fzL = ctx.createLinearGradient(0,0,edgeW,0); fzL.addColorStop(0,`hsl(${fzH},100%,60%)`); fzL.addColorStop(1,'transparent');
                ctx.fillStyle = fzL; ctx.fillRect(0,0,edgeW,HEIGHT);
                const fzR = ctx.createLinearGradient(WIDTH,0,WIDTH-edgeW,0); fzR.addColorStop(0,`hsl(${fzH+60},100%,60%)`); fzR.addColorStop(1,'transparent');
                ctx.fillStyle = fzR; ctx.fillRect(WIDTH-edgeW,0,edgeW,HEIGHT);
                const fzT = ctx.createLinearGradient(0,0,0,edgeW); fzT.addColorStop(0,`hsl(${fzH+120},100%,60%)`); fzT.addColorStop(1,'transparent');
                ctx.fillStyle = fzT; ctx.fillRect(0,0,WIDTH,edgeW);
                const fzB = ctx.createLinearGradient(0,HEIGHT,0,HEIGHT-edgeW); fzB.addColorStop(0,`hsl(${fzH+180},100%,60%)`); fzB.addColorStop(1,'transparent');
                ctx.fillStyle = fzB; ctx.fillRect(0,HEIGHT-edgeW,WIDTH,edgeW);
                ctx.globalAlpha = 1;
            }
        }

        // Score multiplier bar (bottom-right, vertical)
        if (scoreMult > 1.05 && gameState === 'playing') {
            ctx.save();
            const barX = WIDTH - 30, barY = HEIGHT * 0.3, barH = HEIGHT * 0.4, barW = 8;
            const fillH = barH * Math.min(1, (scoreMult - 1) / (MULT_MAX - 1));
            const mC = scoreMult >= 4 ? '#ff00ff' : scoreMult >= 3 ? '#ffaa00' : scoreMult >= 2 ? '#00ffff' : '#00ff88';
            // Track bg
            ctx.globalAlpha = 0.2; ctx.fillStyle = '#ffffff'; ctx.fillRect(barX - barW/2, barY, barW, barH);
            // Fill
            ctx.globalAlpha = 0.8 + scoreMultPulse * 0.2;
            ctx.fillStyle = mC; ctx.shadowBlur = 12 + scoreMultPulse * 20; ctx.shadowColor = mC;
            ctx.fillRect(barX - barW/2, barY + barH - fillH, barW, fillH);
            // Label
            ctx.shadowBlur = 8; ctx.font = 'bold 14px Courier New'; ctx.textAlign = 'center';
            ctx.fillStyle = mC; ctx.fillText('x' + scoreMult.toFixed(1), barX, barY - 8);
            ctx.restore();
        }

        // Edge warning arrows for off-screen enemies
        if (gameState === 'playing') {
            const margin = 40;
            enemies.forEach(e => {
                if (e.x >= margin && e.x <= WIDTH - margin && e.y >= margin && e.y <= HEIGHT - margin) return;
                const dx = e.x - player.x, dy = e.y - player.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > WIDTH * 0.8) return; // too far, don't warn
                const angle = Math.atan2(dy, dx);
                const arrowX = Math.max(20, Math.min(WIDTH - 20, e.x < 0 ? 15 : e.x > WIDTH ? WIDTH - 15 : e.x));
                const arrowY = Math.max(20, Math.min(HEIGHT - 20, e.y < 0 ? 15 : e.y > HEIGHT ? HEIGHT - 15 : e.y));
                ctx.save();
                ctx.translate(arrowX, arrowY); ctx.rotate(angle);
                ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.008) * 0.3;
                ctx.fillStyle = '#ff4444'; ctx.shadowBlur = 8; ctx.shadowColor = '#ff4444';
                ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-6, -6); ctx.lineTo(-6, 6); ctx.closePath(); ctx.fill();
                ctx.restore();
            });
        }

        // Expanding rings
        rings.forEach(r => {
            ctx.globalAlpha = r.life * 0.7;
            ctx.strokeStyle = r.color;
            ctx.lineWidth = r.width * r.life;
            ctx.shadowBlur = 15; ctx.shadowColor = r.color;
            ctx.beginPath(); ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2); ctx.stroke();
            ctx.shadowBlur = 0;
        });
        ctx.globalAlpha = 1;

        // Wave announcement with enemy preview hint
        if (waveAnnounceTimer > 0 && gameState === 'playing') {
            ctx.save();
            const isPerfect = waveAnnounce.includes('PERFECT');
            const isBoss = waveAnnounce.includes('BOSS');
            const isWave = waveAnnounce.startsWith('WAVE');
            const announceColor = isPerfect ? '#ffdd00' : isBoss ? '#ff2200' : '#00ff88';
            const maxTime = isPerfect ? 2.2 : isBoss ? 2.5 : 1.8;
            const elapsed = maxTime - waveAnnounceTimer;
            // Scale-in punch: start at 2x, spring to 1x
            const spring = elapsed < 0.15 ? 1.8 - (elapsed / 0.15) * 0.8 : 1.0 + Math.sin((elapsed - 0.15) * 12) * 0.06 * Math.max(0, 1 - (elapsed - 0.15) * 3);
            const fadeAlpha = Math.min(1, waveAnnounceTimer * 2);
            ctx.globalAlpha = fadeAlpha;
            ctx.translate(WIDTH/2, HEIGHT/2);
            ctx.scale(spring, spring);
            const baseSize = isPerfect ? 48 : isBoss ? 42 : 64;
            ctx.font = `bold ${baseSize}px Courier New`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillStyle = announceColor; ctx.shadowBlur = 30 + elapsed * 20; ctx.shadowColor = announceColor;
            ctx.fillText(waveAnnounce, 0, 0);
            // Difficulty tier subtitle
            const tier = getDifficultyTier(wave);
            if (isWave && wave > 1 && elapsed > 0.2) {
                const subAlpha = Math.min(1, (elapsed - 0.2) * 4) * fadeAlpha;
                ctx.globalAlpha = subAlpha * 0.8;
                ctx.font = 'bold 18px Courier New'; ctx.fillStyle = tier.color;
                ctx.shadowBlur = 15; ctx.shadowColor = tier.color;
                const hint = wave >= 8 ? 'üíÄ NIGHTMARE' : wave >= 5 ? '‚ö† Snipers active' : wave >= 3 ? '‚ö† Burst enemies' : '‚Äî Stay sharp ‚Äî';
                ctx.fillText(hint, 0, 38);
            }
            ctx.restore();
        }

        // Wave break stats + countdown bar
        if (waveBreak && waveBreakStats && gameState === 'playing') {
            ctx.save();
            const breakAlpha = Math.min(1, waveBreakTimer * 3); // fade in
            ctx.globalAlpha = breakAlpha * 0.9;
            ctx.font = '18px Courier New'; ctx.textAlign = 'center';
            const statColor = waveBreakStats.perfect ? '#ffdd00' : '#88ffcc';
            ctx.fillStyle = statColor; ctx.shadowBlur = 10; ctx.shadowColor = waveBreakStats.perfect ? '#ffdd00' : '#00ff88';
            const perfText = waveBreakStats.perfect ? '  ‚òÖ PERFECT' : '';
            ctx.fillText(`Kills: ${waveBreakStats.kills}  |  Grazes: ${waveBreakStats.grazes}${perfText}`, WIDTH/2, HEIGHT/2 + 40);
            // Countdown bar
            const barW = 200, barH = 4;
            const pct = waveBreakTimer / waveBreakDuration;
            ctx.globalAlpha = breakAlpha * 0.6;
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(WIDTH/2 - barW/2, HEIGHT/2 + 55, barW, barH);
            ctx.fillStyle = '#00ff88';
            ctx.fillRect(WIDTH/2 - barW/2, HEIGHT/2 + 55, barW * pct, barH);
            ctx.restore();
        }

        // Kill streak announcement
        if (killStreakAnnounceTimer > 0 && gameState === 'playing') {
            ctx.save(); ctx.globalAlpha = Math.min(1, killStreakAnnounceTimer);
            const scale = 1 + (1 - Math.min(1, killStreakAnnounceTimer)) * 0.3;
            ctx.font = `bold ${Math.floor(36 * scale)}px Courier New`; ctx.textAlign = 'center';
            ctx.fillStyle = '#ff8800'; ctx.shadowBlur = 20; ctx.shadowColor = '#ff8800';
            ctx.fillText(killStreakAnnounce, WIDTH/2, HEIGHT/2 + 60); ctx.restore();
        }

        // Combo graze announcement (fighting game style)
        if (comboAnnounceTimer > 0 && gameState === 'playing') {
            ctx.save();
            ctx.globalAlpha = Math.min(1, comboAnnounceTimer * 1.5);
            const cSize = Math.floor(42 * comboAnnounceScale);
            ctx.font = `bold ${cSize}px Courier New`; ctx.textAlign = 'center';
            ctx.fillStyle = comboAnnounceColor;
            ctx.shadowBlur = 25; ctx.shadowColor = comboAnnounceColor;
            ctx.fillText(comboAnnounce, WIDTH/2, HEIGHT * 0.3);
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // Flow Zone indicator
        if (flowZoneIntensity > 0.1 && gameState === 'playing') {
            ctx.save();
            const fzLabel = flowZoneIntensity > 0.85 ? '‚ú¶ TRANSCENDENT ‚ú¶' : flowZoneIntensity > 0.55 ? '‚ö° DEEP FLOW ‚ö°' : '‚óà FLOW ZONE ‚óà';
            const fzHue = (flowZoneHueShift * 3) % 360;
            const fzPulse = 0.7 + 0.3 * Math.sin(gameTime * 5);
            ctx.globalAlpha = flowZoneIntensity * fzPulse;
            ctx.font = 'bold 14px Courier New'; ctx.textAlign = 'center';
            ctx.fillStyle = `hsl(${fzHue}, 100%, 70%)`;
            ctx.shadowBlur = 15; ctx.shadowColor = `hsl(${fzHue}, 100%, 60%)`;
            ctx.fillText(fzLabel, WIDTH / 2, HEIGHT - 25);
            ctx.shadowBlur = 0; ctx.restore();
        }

        // Wave progress bar ‚Äî enhanced bar at top of screen
        if (isActive && !waveBreak) {
            const barY = 1, barH = 5;
            const pct = Math.min(1, waveTimer / waveDuration);
            const tier = getDifficultyTier(wave);
            // Background track
            ctx.fillStyle = 'rgba(255,255,255,0.08)';
            ctx.fillRect(0, barY, WIDTH, barH);
            // Half and three-quarter tick marks
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(WIDTH * 0.5 - 1, barY, 2, barH);
            ctx.fillRect(WIDTH * 0.75 - 1, barY, 2, barH);
            ctx.fillRect(WIDTH * 0.25 - 1, barY, 2, barH);
            // Progress fill with tier color
            ctx.fillStyle = tier.color;
            ctx.globalAlpha = 0.6 + Math.sin(gameTime * 3) * 0.1;
            ctx.fillRect(0, barY, WIDTH * pct, barH);
            // Bright leading edge with glow
            if (pct > 0.01) {
                ctx.shadowBlur = 12; ctx.shadowColor = tier.color;
                ctx.fillStyle = '#ffffff';
                ctx.globalAlpha = 0.8;
                ctx.fillRect(WIDTH * pct - 6, barY, 6, barH);
                ctx.shadowBlur = 0;
            }
            // Pulsing warning when wave almost done (>80%)
            if (pct > 0.8) {
                const urgency = (pct - 0.8) / 0.2;
                ctx.globalAlpha = urgency * 0.3 * (0.5 + 0.5 * Math.sin(gameTime * 10));
                ctx.fillStyle = tier.color;
                ctx.fillRect(0, barY, WIDTH, barH);
            }
            ctx.globalAlpha = 1;
        }

        // Mini-map radar ‚Äî bottom-left, shows enemy positions relative to player
        if (isActive && enemies.length > 0) {
            const radarR = 32, radarX = 46, radarY = HEIGHT - 46;
            const radarRange = 600; // game units visible on radar
            ctx.save();
            // Radar background
            ctx.globalAlpha = 0.25;
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.arc(radarX, radarY, radarR + 2, 0, Math.PI * 2); ctx.fill();
            ctx.globalAlpha = 0.35;
            ctx.strokeStyle = '#00ff88'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(radarX, radarY, radarR, 0, Math.PI * 2); ctx.stroke();
            // Range rings
            ctx.globalAlpha = 0.12; ctx.strokeStyle = '#00ff88'; ctx.lineWidth = 0.5;
            ctx.beginPath(); ctx.arc(radarX, radarY, radarR * 0.5, 0, Math.PI * 2); ctx.stroke();
            // Sweep line (rotating)
            const sweepAngle = gameTime * 2.5;
            ctx.globalAlpha = 0.2; ctx.strokeStyle = '#00ff88'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(radarX, radarY);
            ctx.lineTo(radarX + Math.cos(sweepAngle) * radarR, radarY + Math.sin(sweepAngle) * radarR);
            ctx.stroke();
            // Player dot (center)
            ctx.globalAlpha = 0.9; ctx.fillStyle = '#00ff88';
            ctx.beginPath(); ctx.arc(radarX, radarY, 2, 0, Math.PI * 2); ctx.fill();
            // Enemy dots
            enemies.forEach(e => {
                const dx = (e.x - player.x) / radarRange * radarR;
                const dy = (e.y - player.y) / radarRange * radarR;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > radarR - 2) return; // outside radar range
                const dotAlpha = 0.8 - dist / radarR * 0.4;
                ctx.globalAlpha = dotAlpha;
                ctx.fillStyle = e.type === 'sniper' ? '#ff4444' : e.type === 'burst' ? '#ff00ff' : e.type === 'homing' ? '#ffaa00' : e.color;
                const dotSize = e.type === 'sniper' || e.type === 'burst' ? 2.5 : 1.8;
                ctx.beginPath(); ctx.arc(radarX + dx, radarY + dy, dotSize, 0, Math.PI * 2); ctx.fill();
            });
            // Boss dot (larger, pulsing)
            if (boss) {
                const bdx = (boss.x - player.x) / radarRange * radarR;
                const bdy = (boss.y - player.y) / radarRange * radarR;
                if (Math.sqrt(bdx*bdx + bdy*bdy) <= radarR) {
                    ctx.globalAlpha = 0.9; ctx.fillStyle = '#ff2200';
                    ctx.shadowBlur = 6; ctx.shadowColor = '#ff2200';
                    ctx.beginPath(); ctx.arc(radarX + bdx, radarY + bdy, 3.5 + Math.sin(gameTime * 5) * 1, 0, Math.PI * 2); ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
            // Power-up dots
            powerups.forEach(p => {
                const pdx = (p.x - player.x) / radarRange * radarR;
                const pdy = (p.y - player.y) / radarRange * radarR;
                if (Math.sqrt(pdx*pdx + pdy*pdy) > radarR) return;
                ctx.globalAlpha = 0.7; ctx.fillStyle = '#00ffcc';
                ctx.beginPath(); ctx.arc(radarX + pdx, radarY + pdy, 2, 0, Math.PI * 2); ctx.fill();
            });
            ctx.restore();
        }

        // CRT scanline overlay (cached offscreen canvas)
        if (isActive && settings.crt) {
            buildScanlines();
            ctx.drawImage(cachedScanlines, 0, 0);
        }

        if (shakeAmount > 0 && settings.shake) ctx.restore();
    }

    init();
    </script>
</body>
</html>
