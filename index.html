<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NEON SURVIVE ‚Äî Self-Improving Game v31 ü•â</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéÆ</text></svg>">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0f;
            color: #00ff88;
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none; user-select: none;
        }
        #gameCanvas { display: block; background: #000; cursor: none; touch-action: none; }
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .hud { position: absolute; top: 20px; left: 20px; font-size: 18px; text-shadow: 0 0 10px #00ff88; pointer-events: none; }
        .hud-right { position: absolute; top: 20px; right: 20px; text-align: right; font-size: 14px; opacity: 0.7; }
        .hud-bottom { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 13px; opacity: 0.6; text-align: center; pointer-events: none; }
        #menu {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: all;
        }
        #menu.hidden { display: none; }
        .title {
            font-size: 72px; font-weight: bold;
            text-shadow: 0 0 20px #00ff88, 0 0 40px #00ff88;
            margin-bottom: 20px; animation: pulse 2s infinite;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .subtitle { font-size: 18px; opacity: 0.8; margin-bottom: 40px; }
        .high-score { font-size: 24px; margin-bottom: 30px; }
        .start-btn {
            padding: 15px 40px; font-size: 24px; font-family: 'Courier New', monospace;
            background: transparent; color: #00ff88; border: 2px solid #00ff88;
            cursor: pointer; transition: all 0.3s; text-shadow: 0 0 10px #00ff88;
            pointer-events: all;
        }
        .start-btn:hover { background: #00ff88; color: #000; box-shadow: 0 0 20px #00ff88; }
        .start-btn { touch-action: manipulation; min-height: 48px; }
        .controls { margin-top: 30px; font-size: 14px; opacity: 0.6; text-align: center; }
        #gameOver {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: all;
        }
        #gameOver.show { display: flex; }
        .game-over-title { font-size: 64px; color: #ff0044; text-shadow: 0 0 20px #ff0044; margin-bottom: 30px; }
        .final-score { font-size: 32px; margin-bottom: 40px; text-align: center; line-height: 1.6; }
        .info-section { max-width: 800px; margin: 40px auto; padding: 20px; background: rgba(0,255,136,0.05); border: 1px solid #00ff88; width: calc(100% - 30px); position: relative; z-index: 1; }
        #menu:not(.hidden) ~ .info-section, #menu:not(.hidden) ~ .footer { display: none; }
        .info-section h2 { margin-bottom: 15px; text-shadow: 0 0 10px #00ff88; }
        .info-section p { line-height: 1.6; opacity: 0.8; }
        .footer { text-align: center; padding: 20px; opacity: 0.5; font-size: 12px; }
        #pauseOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100; pointer-events: all;
        }
        #pauseOverlay.show { display: flex; }
        .pause-title { font-size: 64px; color: #00ff88; text-shadow: 0 0 30px #00ff88; margin-bottom: 20px; }
        .pause-hint { font-size: 16px; opacity: 0.6; margin-top: 20px; }
        #pauseBtn {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            font-family: 'Courier New', monospace; font-size: 18px;
            background: transparent; color: #00ff88; border: 1px solid rgba(0,255,136,0.3);
            padding: 5px 15px; cursor: pointer; z-index: 50; display: none; opacity: 0.5;
            transition: opacity 0.2s;
        }
        #pauseBtn:hover { opacity: 1; }
        #settingsPanel {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%);
            background: rgba(0,0,0,0.95); border: 1px solid #00ff88; padding: 30px;
            z-index: 200; display: none; min-width: 280px; max-width: 340px;
            box-shadow: 0 0 30px rgba(0,255,136,0.3);
        }
        #settingsPanel.show { display: block; }
        #settingsPanel h2 { color: #00ff88; text-shadow: 0 0 10px #00ff88; margin-bottom: 20px; font-size: 24px; text-align: center; }
        .setting-row { display: flex; justify-content: space-between; align-items: center; margin: 14px 0; font-size: 14px; }
        .setting-row label { opacity: 0.8; }
        .setting-toggle {
            width: 44px; height: 24px; background: rgba(255,255,255,0.1); border: 1px solid #00ff88;
            border-radius: 12px; cursor: pointer; position: relative; transition: background 0.2s;
        }
        .setting-toggle.on { background: rgba(0,255,136,0.3); }
        .setting-toggle::after {
            content: ''; position: absolute; top: 2px; left: 2px; width: 18px; height: 18px;
            background: #00ff88; border-radius: 50%; transition: transform 0.2s;
        }
        .setting-toggle.on::after { transform: translateX(20px); }
        .settings-close {
            display: block; margin: 20px auto 0; padding: 8px 24px; font-family: 'Courier New', monospace;
            font-size: 16px; background: transparent; color: #00ff88; border: 1px solid #00ff88;
            cursor: pointer; transition: all 0.2s;
        }
        .settings-close:hover { background: #00ff88; color: #000; }
        @media (max-width: 768px) {
            .title { font-size: 42px; }
            .game-over-title { font-size: 42px; }
            .hud { font-size: 14px; top: 10px; left: 10px; }
            .hud-right { font-size: 12px; top: 10px; right: 10px; }
        }
        @media (max-width: 420px) {
            .title { font-size: 32px; }
            .subtitle { font-size: 14px; }
            .game-over-title { font-size: 32px; }
            .high-score { font-size: 18px; }
            .start-btn { font-size: 20px; padding: 12px 30px; }
            .hud { font-size: 12px; top: 8px; left: 8px; max-width: 60%; }
            .hud-right { font-size: 10px; top: 8px; right: 8px; }
            .hud-bottom { font-size: 11px; bottom: 12px; }
            .controls { font-size: 12px; margin-top: 20px; }
            .info-section { padding: 15px; font-size: 13px; }
            .info-section h2 { font-size: 18px; }
            #pauseBtn { font-size: 14px; padding: 4px 10px; top: 10px; left: auto; right: 60px; transform: none; }
            #muteBtn { right: 10px !important; font-size: 14px !important; padding: 4px 8px !important; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="overlay">
        <div class="hud"><div id="scoreDisplay">TIME: 0.0s | GRAZE: 0</div></div>
        <div class="hud-right"><div>Iteration #30 ü•â</div><div>Grade: 92/100</div></div>
        <div class="hud-bottom" id="powerupHud"></div>
    </div>
    <div id="menu">
        <div class="title">NEON SURVIVE</div>
        <div class="subtitle">Self-Improving Game v31 ü•â Bronze Milestone!</div>
        <div class="high-score" id="highScoreDisplay">HIGH SCORE: 0</div>
        <button class="start-btn" id="startBtn">START</button>
        <div class="controls">
            MOUSE / WASD / ARROW KEYS / TOUCH<br>
            SPACE / DOUBLE-TAP to DASH<br>
            Dodge enemies. Graze for bonus points. Collect power-ups. Survive.
        </div>
        <button class="start-btn" style="margin-top:12px;font-size:16px;padding:8px 20px;opacity:0.7" onclick="openSettings()">‚öô SETTINGS</button>
        <div style="margin-top:15px;font-size:28px;animation:pulse 2s infinite;text-shadow:0 0 20px #cd7f32,0 0 40px #cd7f32;">ü•â BRONZE MILESTONE ‚Äî 25 Iterations!</div>
        <div id="lifetimeStats" style="margin-top:25px;font-size:12px;opacity:0.5;text-align:center;line-height:1.8;"></div>
    </div>
    <button id="pauseBtn" onclick="togglePause()">‚ùö‚ùö PAUSE</button>
    <button id="muteBtn" onclick="toggleMute()" style="position:fixed;top:20px;right:120px;font-family:'Courier New',monospace;font-size:18px;background:transparent;color:#00ff88;border:1px solid rgba(0,255,136,0.3);padding:5px 10px;cursor:pointer;z-index:50;display:none;opacity:0.5;transition:opacity 0.2s;">üîä</button>
    <div id="pauseOverlay">
        <div class="pause-title">PAUSED</div>
        <button class="start-btn" onclick="togglePause()">RESUME</button>
        <button class="start-btn" style="margin-top:10px;font-size:16px;padding:8px 20px;opacity:0.7" onclick="openSettings()">‚öô SETTINGS</button>
        <div class="pause-hint">Press P or ESC to resume</div>
    </div>
    <div id="gameOver">
        <div class="game-over-title">GAME OVER</div>
        <div class="final-score" id="finalScore">SCORE: 0</div>
        <button class="start-btn" id="restartBtn">PLAY AGAIN</button>
        <div style="margin-top:12px;font-size:12px;opacity:0.4;">Press R / ENTER / SPACE to retry</div>
    </div>
    <div id="settingsPanel">
        <h2>‚öô SETTINGS</h2>
        <div class="setting-row"><label>CRT Scanlines</label><div class="setting-toggle on" id="toggleCRT" onclick="toggleSetting('crt')"></div></div>
        <div class="setting-row"><label>Screen Shake</label><div class="setting-toggle on" id="toggleShake" onclick="toggleSetting('shake')"></div></div>
        <div class="setting-row"><label>Particles</label><div class="setting-toggle on" id="toggleParticles" onclick="toggleSetting('particles')"></div></div>
        <div class="setting-row"><label>Volume</label><input type="range" min="0" max="100" id="volumeSlider" style="width:100px;accent-color:#00ff88;cursor:pointer;" oninput="setVolume(this.value)"><span id="volumeLabel" style="font-size:12px;opacity:0.6;min-width:30px;text-align:right;">80%</span></div>
        <button class="settings-close" onclick="closeSettings()">DONE</button>
    </div>
    <div class="info-section">
        <h2>About This Game</h2>
        <p>This is a <strong>self-improving autonomous game</strong>. Every 7 minutes, an AI agent evaluates the current version, grades it, and automatically generates improvements. The game evolves itself over time.</p>
        <p style="margin-top:10px;">You are playing <strong>Iteration #31</strong> ü•â <em>Bronze Milestone!</em> Check back regularly to see how it transforms itself.</p>
        <p style="margin-top:10px;"><a href="https://game.theselfimprovingpage.com" target="_blank" style="color:#00ffff;">üï∞Ô∏è Explore the Time Machine</a> ‚Äî browse every version and see the evolution history.</p>
    </div>
    <div class="footer">
        Iteration #31 ü•â | Grade: 94/100 | Last Updated: <span id="timestamp"></span>
        <br><a href="https://game.theselfimprovingpage.com" target="_blank" style="color:#00ff88;opacity:0.7;text-decoration:underline;">üï∞Ô∏è Time Machine ‚Äî See how this game evolved</a>
    </div>
    <script>
    // ============================================
    // NEON SURVIVE ‚Äî Iteration 31 (Mini-Boss System)
    // ============================================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    let WIDTH, HEIGHT;
    // Settings
    let settings = JSON.parse(localStorage.getItem('neonSurviveSettings') || '{"crt":true,"shake":true,"particles":true,"volume":80}');
    if (settings.volume === undefined) settings.volume = 80;
    let masterVolume = settings.volume / 100;
    function saveSettings() { localStorage.setItem('neonSurviveSettings', JSON.stringify(settings)); }
    function toggleSetting(key) {
        settings[key] = !settings[key]; saveSettings();
        document.getElementById('toggle' + key.charAt(0).toUpperCase() + key.slice(1)).classList.toggle('on', settings[key]);
    }
    function setVolume(val) { settings.volume = parseInt(val); masterVolume = settings.volume / 100; saveSettings(); document.getElementById('volumeLabel').textContent = val + '%'; }
    function openSettings() { document.getElementById('settingsPanel').classList.add('show'); document.getElementById('volumeSlider').value = settings.volume; document.getElementById('volumeLabel').textContent = settings.volume + '%'; }
    function closeSettings() { document.getElementById('settingsPanel').classList.remove('show'); }
    // Init toggles on load
    setTimeout(() => {
        ['crt','shake','particles'].forEach(k => {
            const el = document.getElementById('toggle' + k.charAt(0).toUpperCase() + k.slice(1));
            if (el) el.classList.toggle('on', settings[k]);
        });
    }, 0);

    // Perfect wave tracking
    let perfectWaveEligible = true; // reset each wave, lost if hit (but we don't have HP, so it's about grazes)

    let gameState = 'menu';
    let paused = false;
    let killCount = 0;
    let score = 0, grazeCount = 0, gameTime = 0, difficulty = 1;
    let highScore = localStorage.getItem('neonSurviveHighScore') || 0;
    let newHighScore = false;

    // Lifetime stats
    let lifetime = JSON.parse(localStorage.getItem('neonSurviveLifetime') || '{"games":0,"bestWave":0,"totalKills":0,"totalGrazes":0,"totalTime":0,"bestCombo":0}');
    function saveLifetime() { localStorage.setItem('neonSurviveLifetime', JSON.stringify(lifetime)); }

    // Hit freeze (game feel juice)
    let hitFreezeTimer = 0;

    // Wave progress bar
    // (rendered in render(), uses waveTimer/waveDuration)

    // Orb collection chain
    let orbChainCount = 0, orbChainTimer = 0;

    // Edge warnings
    let edgeWarnings = [];

    // Ambient beat
    let beatInterval = null, beatOsc = null, beatGain = null;

    // Cached vignette
    let cachedVignette = null, vignetteW = 0, vignetteH = 0;

    // Cached background gradient
    let cachedBgGrad = null, bgGradWave = -1, bgGradW = 0, bgGradH = 0, bgGradDying = false;

    // Cached CRT scanline overlay
    let cachedScanlines = null, scanW = 0, scanH = 0;
    function buildScanlines() {
        if (scanW === WIDTH && scanH === HEIGHT && cachedScanlines) return;
        const oc = document.createElement('canvas');
        oc.width = WIDTH; oc.height = HEIGHT;
        const octx = oc.getContext('2d');
        octx.fillStyle = 'rgba(0,0,0,0.03)';
        for (let y = 0; y < HEIGHT; y += 4) octx.fillRect(0, y, WIDTH, 2);
        cachedScanlines = oc; scanW = WIDTH; scanH = HEIGHT;
    }

    // Cached danger border gradients
    let cachedDanger = { w: 0, h: 0, left: null, right: null, top: null, bottom: null };
    function buildDangerGradients() {
        if (cachedDanger.w === WIDTH && cachedDanger.h === HEIGHT) return;
        const dg = ctx.createLinearGradient(0, 0, 40, 0);
        dg.addColorStop(0, '#ff0044'); dg.addColorStop(1, 'transparent');
        const dg2 = ctx.createLinearGradient(WIDTH, 0, WIDTH-40, 0);
        dg2.addColorStop(0, '#ff0044'); dg2.addColorStop(1, 'transparent');
        const dg3 = ctx.createLinearGradient(0, 0, 0, 40);
        dg3.addColorStop(0, '#ff0044'); dg3.addColorStop(1, 'transparent');
        const dg4 = ctx.createLinearGradient(0, HEIGHT, 0, HEIGHT-40);
        dg4.addColorStop(0, '#ff0044'); dg4.addColorStop(1, 'transparent');
        cachedDanger = { w: WIDTH, h: HEIGHT, left: dg, right: dg2, top: dg3, bottom: dg4 };
    }

    // Danger border
    let dangerPulse = 0;

    // Mobile detection
    const isMobile = /Android|iPhone|iPad|iPod|webOS/i.test(navigator.userAgent) || window.innerWidth < 768;

    // Player
    let player = { x: 0, y: 0, vx: 0, vy: 0, radius: 12, trail: [] };

    // Dash
    let dash = { active: false, timer: 0, cooldown: 0, duration: 0.15, cooldownTime: 1.2, speed: 1200, invincible: false };
    let lastTapTime = 0;

    // Entities
    let enemies = [], particles = [], stars = [], powerups = [];
    // Score orbs ‚Äî dropped by killed enemies
    let scoreOrbs = [];

    // Mini-boss system ‚Äî spawns every 5 waves
    let boss = null;
    function spawnBoss(bossWave) {
        const side = Math.floor(Math.random() * 4);
        let x, y;
        if (side === 0) { x = WIDTH / 2; y = -40; }
        else if (side === 1) { x = WIDTH + 40; y = HEIGHT / 2; }
        else if (side === 2) { x = WIDTH / 2; y = HEIGHT + 40; }
        else { x = -40; y = HEIGHT / 2; }
        const hp = 3 + Math.floor(bossWave / 5);
        boss = {
            x, y, radius: 28, color: '#ff2200', hp, maxHp: hp,
            vx: 0, vy: 0, speed: 30 + bossWave * 2, pulse: 0,
            shieldAngle: 0, flashTimer: 0, trail: []
        };
        waveAnnounce = '‚ö† BOSS INCOMING ‚ö†'; waveAnnounceTimer = 2.5;
        playSound(100, 0.4, 'sawtooth', 0.15);
        setTimeout(() => playSound(80, 0.5, 'sawtooth', 0.12), 200);
    }

    // Floating text popups (score, combo, etc.)
    let floatingTexts = [];
    function spawnFloatingText(x, y, text, color = '#00ff88', size = 18, duration = 1.0) {
        floatingTexts.push({ x, y, text, color, size, duration, maxDuration: duration, vy: -80 - Math.random() * 30, vx: (Math.random() - 0.5) * 40 });
    }

    // Combo announcement system ‚Äî fighting game style
    let comboAnnounce = '', comboAnnounceTimer = 0, comboAnnounceColor = '#00ffff', comboAnnounceScale = 1;
    function getComboAnnouncement(combo) {
        if (combo >= 20) return { text: '‚ò†Ô∏è GODLIKE!', color: '#ff00ff', sound: 2000 };
        if (combo >= 15) return { text: 'üî• LEGENDARY!', color: '#ffdd00', sound: 1800 };
        if (combo >= 10) return { text: '‚ö° ULTRA!', color: '#ff8800', sound: 1600 };
        if (combo >= 7) return { text: 'üí• MEGA!', color: '#ff4400', sound: 1400 };
        if (combo >= 5) return { text: 'SUPER!', color: '#ffaa00', sound: 1200 };
        if (combo >= 3) return { text: 'TRIPLE!', color: '#00ffff', sound: 1000 };
        return null;
    }

    // Game history (last 5 games stored in localStorage)
    let gameHistory = JSON.parse(localStorage.getItem('neonSurviveHistory') || '[]');

    // Input
    let keys = {}, mouse = { x: 0, y: 0, active: false }, touch = { x: 0, y: 0, active: false };

    // Timing
    let lastSpawn = 0, spawnInterval = 1000, lastPowerupSpawn = 0;

    // Effects
    let shakeAmount = 0, flashColor = null, flashAlpha = 0;
    // Kill streak
    let killStreak = 0, killStreakTimer = 0, killStreakAnnounce = '', killStreakAnnounceTimer = 0;
    // Ring explosions (wave clear, death)
    let rings = [];
    // Death slowmo
    let deathSlowmo = 0, deathSlowmoDuration = 1.2;

    // Near-death bullet time
    let bulletTime = 0, bulletTimeDuration = 0.12;

    // Proximity heartbeat
    let proximityBeatTimer = 0, lastProximityBeat = 0;

    // Dash afterimages
    let dashAfterimages = [];

    // Nebula clouds ‚Äî procedural drifting background patches
    let nebulae = [];
    function initNebulae() {
        const colors = ['rgba(0,100,255,', 'rgba(100,0,200,', 'rgba(0,200,100,', 'rgba(200,50,100,'];
        for (let i = 0; i < 5; i++) {
            nebulae.push({
                x: Math.random() * 2000 - 500, y: Math.random() * 2000 - 500,
                radius: 150 + Math.random() * 250,
                color: colors[Math.floor(Math.random() * colors.length)],
                vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
                phase: Math.random() * Math.PI * 2
            });
        }
    }
    function updateNebulae(dt) {
        nebulae.forEach(n => {
            n.x += n.vx * dt; n.y += n.vy * dt; n.phase += dt * 0.3;
            if (n.x < -n.radius * 2) n.x = WIDTH + n.radius;
            if (n.x > WIDTH + n.radius * 2) n.x = -n.radius;
            if (n.y < -n.radius * 2) n.y = HEIGHT + n.radius;
            if (n.y > HEIGHT + n.radius * 2) n.y = -n.radius;
        });
    }
    // Pre-rendered nebula canvases (avoid per-frame createRadialGradient)
    let nebulaCanvases = [];
    function buildNebulaCanvases() {
        nebulaCanvases = nebulae.map(n => {
            const size = Math.ceil((n.radius + 25) * 2);
            const oc = document.createElement('canvas');
            oc.width = size; oc.height = size;
            const octx = oc.getContext('2d');
            const cx = size / 2, cy = size / 2;
            const grad = octx.createRadialGradient(cx, cy, 0, cx, cy, size / 2);
            grad.addColorStop(0, n.color + '0.03)');
            grad.addColorStop(0.5, n.color + '0.015)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            octx.fillStyle = grad;
            octx.fillRect(0, 0, size, size);
            return oc;
        });
    }
    function renderNebulae() {
        nebulae.forEach((n, i) => {
            if (!nebulaCanvases[i]) return;
            const pulseScale = 1 + Math.sin(n.phase) * 0.08;
            const alpha = 0.6 + Math.sin(n.phase) * 0.3;
            ctx.globalAlpha = alpha;
            const oc = nebulaCanvases[i];
            const w = oc.width * pulseScale, h = oc.height * pulseScale;
            ctx.drawImage(oc, n.x - w/2, n.y - h/2, w, h);
        });
        ctx.globalAlpha = 1;
    }

    // Attract mode (menu background)
    let attractEnemies = [];
    function updateAttractMode(dt) {
        if (Math.random() < dt * 1.5) {
            const side = Math.floor(Math.random() * 4);
            let x, y, vx, vy;
            const sp = 60 + Math.random() * 100;
            if (side === 0) { x = Math.random() * WIDTH; y = -15; vx = (Math.random()-0.5)*80; vy = sp; }
            else if (side === 1) { x = WIDTH+15; y = Math.random() * HEIGHT; vx = -sp; vy = (Math.random()-0.5)*80; }
            else if (side === 2) { x = Math.random() * WIDTH; y = HEIGHT+15; vx = (Math.random()-0.5)*80; vy = -sp; }
            else { x = -15; y = Math.random() * HEIGHT; vx = sp; vy = (Math.random()-0.5)*80; }
            const colors = ['#ff0044','#ffaa00','#ff00ff','#00aaff'];
            attractEnemies.push({ x, y, vx, vy, radius: 5+Math.random()*6, color: colors[Math.floor(Math.random()*4)], trail: [] });
        }
        attractEnemies.forEach(e => {
            e.x += e.vx * dt; e.y += e.vy * dt;
            e.trail.push({ x: e.x, y: e.y, life: 1 });
            if (e.trail.length > 6) e.trail.shift();
            e.trail.forEach(t => t.life -= 0.15);
        });
        attractEnemies = attractEnemies.filter(e => e.x > -50 && e.x < WIDTH+50 && e.y > -50 && e.y < HEIGHT+50);
    }
    function renderAttractMode() {
        attractEnemies.forEach(e => {
            e.trail.forEach(t => {
                if (t.life > 0) { ctx.globalAlpha = t.life * 0.15; ctx.fillStyle = e.color; ctx.beginPath(); ctx.arc(t.x, t.y, e.radius * t.life * 0.5, 0, Math.PI*2); ctx.fill(); }
            });
            ctx.globalAlpha = 0.3; ctx.fillStyle = e.color; ctx.shadowBlur = 10; ctx.shadowColor = e.color;
            ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
        });
        ctx.globalAlpha = 1;
    }

    // Difficulty tier names
    function getDifficultyTier(wave) {
        if (wave <= 2) return { name: 'EASY', color: '#00ff88' };
        if (wave <= 4) return { name: 'MEDIUM', color: '#00aaff' };
        if (wave <= 6) return { name: 'HARD', color: '#ffaa00' };
        if (wave <= 9) return { name: 'INSANE', color: '#ff4400' };
        return { name: 'NIGHTMARE', color: '#ff0044' };
    }

    // Death tips based on stats
    function getDeathTip(wave, grazeCount, comboBest, killCount, gameTime) {
        if (wave <= 1 && gameTime < 10) return "üí° Tip: Use WASD/mouse to move. Get close to enemies without touching to GRAZE for points!";
        if (grazeCount < 3 && wave <= 2) return "üí° Tip: Fly close to enemies to graze them ‚Äî it's risky but earns big points and combos!";
        if (comboBest < 3 && wave >= 3) return "üí° Tip: Chain grazes within 2s for combo multipliers. The closer the graze, the more dramatic!";
        if (killCount === 0 && wave >= 2) return "üí° Tip: Dash through enemies (SPACE/double-tap) or use Shield power-ups to destroy them!";
        if (wave >= 5) return "üí° Tip: Watch for sniper laser sights! Move perpendicular to the beam to dodge.";
        if (wave >= 3) return "üí° Tip: Purple burst enemies explode into 4 projectiles ‚Äî keep your distance!";
        return "üí° Tip: Collect power-ups during wave breaks for an edge in the next wave.";
    }

    // Performance rank system
    function getPerformanceRank(wave, score, grazes, comboBest, kills) {
        let pts = 0;
        pts += Math.min(40, wave * 5);           // waves survived (max 40)
        pts += Math.min(25, score / 200);         // score (max 25)
        pts += Math.min(15, grazes * 1.5);        // grazing skill (max 15)
        pts += Math.min(10, comboBest * 2);       // combo mastery (max 10)
        pts += Math.min(10, kills * 1);            // kills (max 10)
        if (pts >= 90) return { rank: 'S', color: '#ffdd00', glow: '#ffdd00' };
        if (pts >= 75) return { rank: 'A', color: '#00ff88', glow: '#00ff88' };
        if (pts >= 55) return { rank: 'B', color: '#00aaff', glow: '#00aaff' };
        if (pts >= 35) return { rank: 'C', color: '#ffaa00', glow: '#ffaa00' };
        if (pts >= 20) return { rank: 'D', color: '#ff6600', glow: '#ff6600' };
        return { rank: 'F', color: '#ff0044', glow: '#ff0044' };
    }

    // Speed lines during dash
    let speedLines = [];
    function spawnSpeedLines() {
        for (let i = 0; i < 5; i++) {
            const angle = Math.atan2(player.vy, player.vx) + Math.PI + (Math.random()-0.5)*0.8;
            speedLines.push({
                x: player.x + (Math.random()-0.5)*30,
                y: player.y + (Math.random()-0.5)*30,
                angle, length: 20 + Math.random()*40, life: 0.2 + Math.random()*0.15, decay: 0.04
            });
        }
    }

    // Wave system
    let wave = 1, waveTimer = 0, waveDuration = 8, waveBreak = false, waveBreakTimer = 0, waveBreakDuration = 2;
    let waveAnnounce = '', waveAnnounceTimer = 0;
    let waveKills = 0, waveGrazes = 0; // per-wave stats
    let waveBreakStats = null; // {kills, grazes, wave} shown during break
    let beatPulse = 0; // 0-1 pulse synced to beat timing

    // Combo system
    let comboCount = 0, comboTimer = 0, comboBest = 0;

    // Score multiplier ‚Äî builds with activity, decays when idle
    let scoreMult = 1, scoreMultTarget = 1, scoreMultDecayTimer = 0;
    const MULT_DECAY_DELAY = 3; // seconds of no activity before decay starts
    const MULT_MAX = 5;
    let scoreMultPulse = 0; // visual pulse when multiplier increases

    // Active power-ups
    let activePowerups = { shield: 0, slowmo: 0, magnet: 0 };

    // Audio
    let audioCtx = null;
    function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

    function playSound(freq, duration, type = 'sine', volume = 0.1) {
        if (!audioCtx || muted) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.value = volume * masterVolume;
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + duration);
    }

    // Ambient beat system
    let beatBPM = 80, beatPlaying = false;
    function startBeat() {
        if (!audioCtx || beatPlaying) return;
        beatPlaying = true;
        function scheduleBeat() {
            if (!beatPlaying) return;
            const bpm = beatBPM + (wave - 1) * 8;
            const interval = 60000 / bpm;
            // Kick
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(80, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.12);
            gain.gain.setValueAtTime(0.08 * masterVolume, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.2);
            beatPulse = 1; // Trigger visual pulse on each beat
            beatInterval = setTimeout(scheduleBeat, interval);
        }
        scheduleBeat();
    }
    function stopBeat() { beatPlaying = false; if (beatInterval) clearTimeout(beatInterval); }

    // Dash sound ‚Äî whoosh
    function playDashSound() {
        if (!audioCtx || muted) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(300, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.15);
        gain.gain.setValueAtTime(0.15 * masterVolume, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.2);
    }

    // Power-up pickup sound
    function playPowerupSound() {
        playSound(800, 0.1, 'sine', 0.15);
        setTimeout(() => playSound(1200, 0.1, 'sine', 0.12), 60);
        setTimeout(() => playSound(1600, 0.15, 'sine', 0.1), 120);
    }

    // Dramatic death explosion sound
    function playDeathSound() {
        if (!audioCtx) return;
        // Low rumble
        const osc1 = audioCtx.createOscillator();
        const g1 = audioCtx.createGain();
        osc1.type = 'sawtooth';
        osc1.frequency.setValueAtTime(80, audioCtx.currentTime);
        osc1.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.8);
        g1.gain.setValueAtTime(0.2 * masterVolume, audioCtx.currentTime);
        g1.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);
        osc1.connect(g1); g1.connect(audioCtx.destination);
        osc1.start(); osc1.stop(audioCtx.currentTime + 0.9);
        // Noise burst
        const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/data.length, 2);
        const noise = audioCtx.createBufferSource();
        const g2 = audioCtx.createGain();
        noise.buffer = buf;
        g2.gain.setValueAtTime(0.15 * masterVolume, audioCtx.currentTime);
        g2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
        noise.connect(g2); g2.connect(audioCtx.destination);
        noise.start();
        // Descending tone
        setTimeout(() => { playSound(400, 0.4, 'sine', 0.1); }, 200);
        setTimeout(() => { playSound(200, 0.5, 'sine', 0.08); }, 400);
    }

    // Graze streak sound ‚Äî rising pitch with combo
    function playGrazeStreakSound(combo) {
        if (!audioCtx) return;
        const baseFreq = 600 + Math.min(combo, 15) * 80;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(baseFreq, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.3, audioCtx.currentTime + 0.08);
        g.gain.setValueAtTime((0.06 + Math.min(combo, 10) * 0.01) * masterVolume, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.2);
    }

    // Proximity heartbeat sound ‚Äî low thump when enemies are close
    function playProximityBeat(closeness) {
        if (!audioCtx || muted) return;
        const vol = 0.03 + closeness * 0.08;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(55, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.12);
        g.gain.setValueAtTime(vol * masterVolume, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.2);
    }

    // Wall spark sound
    function playWallSparkSound() {
        if (!audioCtx || muted) return;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(1200, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(400, audioCtx.currentTime + 0.06);
        g.gain.setValueAtTime(0.04 * masterVolume, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.06);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.08);
    }

    // Orb collect sound ‚Äî short sparkle
    function playOrbCollectSound() {
        if (!audioCtx || muted) return;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(900 + Math.random() * 400, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(1800, audioCtx.currentTime + 0.06);
        g.gain.setValueAtTime(0.05 * masterVolume, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.1);
    }

    // Wave clear fanfare
    function playWaveClearSound() {
        if (!audioCtx) return;
        const notes = [523, 659, 784, 1047]; // C5 E5 G5 C6
        notes.forEach((f, i) => {
            setTimeout(() => playSound(f, 0.25, 'sine', 0.1), i * 80);
        });
    }

    // Bass drone ‚Äî sustained tension note that increases with wave
    let bassDrone = null, bassDroneGain = null;
    function startBassDrone() {
        if (!audioCtx || bassDrone) return;
        bassDrone = audioCtx.createOscillator();
        bassDroneGain = audioCtx.createGain();
        bassDrone.type = 'sine';
        bassDrone.frequency.value = 40;
        bassDroneGain.gain.value = 0.03 * masterVolume;
        bassDrone.connect(bassDroneGain);
        bassDroneGain.connect(audioCtx.destination);
        bassDrone.start();
    }
    function updateBassDrone(wave) {
        if (!bassDrone || !bassDroneGain) return;
        bassDrone.frequency.value = 35 + wave * 5;
        bassDroneGain.gain.value = Math.min(0.06, 0.02 + wave * 0.005) * masterVolume;
    }
    function stopBassDrone() {
        if (bassDrone) { try { bassDrone.stop(); } catch(e){} bassDrone = null; bassDroneGain = null; }
    }

    // Arpeggio melody system
    let arpPlaying = false, arpTimeout = null, arpStep = 0;
    let muted = localStorage.getItem('neonSurviveMuted') === 'true';
    const arpScales = [
        [261, 329, 392, 523, 659], // C major pentatonic
        [293, 349, 440, 523, 659], // D minor-ish
        [330, 392, 494, 587, 659], // E phrygian feel
        [349, 440, 523, 659, 698], // F lydian feel
    ];
    function startArp() {
        if (arpPlaying || muted) return;
        arpPlaying = true; arpStep = 0;
        function scheduleArpNote() {
            if (!arpPlaying || !audioCtx || muted) return;
            const scaleIdx = Math.min(wave - 1, arpScales.length - 1);
            const scale = arpScales[scaleIdx];
            const note = scale[arpStep % scale.length];
            const octave = Math.floor(arpStep / scale.length) % 2 === 0 ? 1 : 2;
            const freq = note * octave;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'triangle';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.04 * masterVolume, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.25);
            arpStep++;
            const bpm = beatBPM + (wave - 1) * 8;
            arpTimeout = setTimeout(scheduleArpNote, (60000 / bpm) / 2);
        }
        scheduleArpNote();
    }
    function stopArp() { arpPlaying = false; if (arpTimeout) clearTimeout(arpTimeout); }

    function toggleMute() {
        muted = !muted;
        localStorage.setItem('neonSurviveMuted', muted);
        document.getElementById('muteBtn').textContent = muted ? 'üîá' : 'üîä';
        if (muted) { stopBeat(); stopArp(); stopBassDrone(); if (audioCtx) audioCtx.suspend(); }
        else if (gameState === 'playing' && !paused) { if (audioCtx) audioCtx.resume(); startBeat(); startArp(); startBassDrone(); }
    }

    // ============================================
    // INIT
    // ============================================
    function resizeCanvas() {
        WIDTH = window.innerWidth; HEIGHT = window.innerHeight;
        canvas.width = WIDTH; canvas.height = HEIGHT;
    }

    function init() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        // 3-layer parallax starfield
        for (let i = 0; i < 60; i++) {
            stars.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, size: 0.5 + Math.random(), speed: 0.05 + Math.random() * 0.15, layer: 0 });
        }
        for (let i = 0; i < 40; i++) {
            stars.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, size: 1 + Math.random(), speed: 0.2 + Math.random() * 0.3, layer: 1 });
        }
        for (let i = 0; i < 15; i++) {
            stars.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, size: 2 + Math.random() * 1.5, speed: 0.5 + Math.random() * 0.5, layer: 2 });
        }
        initNebulae();
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);
        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ' && gameState === 'playing' && !paused) { e.preventDefault(); tryDash(); }
            if ((e.key === 'p' || e.key === 'Escape') && gameState === 'playing') { e.preventDefault(); togglePause(); }
            if ((e.key === 'Enter' || e.key === ' ' || e.key === 'r') && gameState === 'gameover') { e.preventDefault(); startGame(); }
        });
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        canvas.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; mouse.active = true; });
        canvas.addEventListener('touchstart', e => {
            handleTouch(e);
            const now = Date.now();
            if (now - lastTapTime < 300) tryDash();
            lastTapTime = now;
        });
        canvas.addEventListener('touchmove', handleTouch);
        canvas.addEventListener('touchend', () => touch.active = false);
        // Prevent scroll during gameplay
        document.body.addEventListener('touchmove', e => { if (gameState === 'playing') e.preventDefault(); }, { passive: false });
        document.getElementById('highScoreDisplay').textContent = `HIGH SCORE: ${Math.floor(highScore)}`;
        updateLifetimeDisplay();
        document.getElementById('timestamp').textContent = new Date().toLocaleString();
        requestAnimationFrame(gameLoop);
    }

    function handleTouch(e) {
        e.preventDefault();
        touch.x = e.touches[0].clientX;
        touch.y = e.touches[0].clientY;
        touch.active = true;
    }

    // ============================================
    // DASH
    // ============================================
    function tryDash() {
        if (dash.cooldown > 0 || dash.active) return;
        dash.active = true;
        dash.timer = dash.duration;
        dash.cooldown = dash.cooldownTime;
        dash.invincible = true;
        playDashSound();
        shakeAmount = 5;
        flashColor = '#00ff88'; flashAlpha = 0.15;
        spawnSpeedLines();
        // Dash trail burst
        for (let i = 0; i < 8; i++) {
            const a = Math.random() * Math.PI * 2;
            particles.push({
                x: player.x, y: player.y,
                vx: Math.cos(a) * 200, vy: Math.sin(a) * 200,
                life: 0.4, decay: 0.025, size: 3, color: '#00ff88'
            });
        }
    }

    // ============================================
    // GAME CONTROL
    // ============================================
    function togglePause() {
        if (gameState !== 'playing') return;
        paused = !paused;
        document.getElementById('pauseOverlay').classList.toggle('show', paused);
        if (paused) { stopBeat(); stopArp(); if (audioCtx) audioCtx.suspend(); }
        else { if (!muted) { startBeat(); startArp(); if (audioCtx) audioCtx.resume(); } }
    }

    function startGame() {
        initAudio();
        if (!muted) { startBeat(); startBassDrone(); startArp(); }
        document.getElementById('muteBtn').style.display = 'block';
        document.getElementById('muteBtn').textContent = muted ? 'üîá' : 'üîä';
        gameState = 'playing'; score = 0; grazeCount = 0; gameTime = 0; difficulty = 1; orbChainCount = 0; orbChainTimer = 0; hitFreezeTimer = 0;
        player.x = WIDTH / 2; player.y = HEIGHT / 2; player.vx = 0; player.vy = 0; player.trail = [];
        enemies = []; particles = []; powerups = []; scoreOrbs = []; boss = null;
        lastSpawn = 0; lastPowerupSpawn = 0;
        wave = 1; waveTimer = 0; waveBreak = false; waveBreakTimer = 0;
        comboCount = 0; comboTimer = 0; comboBest = 0; killCount = 0; killStreak = 0; killStreakTimer = 0;
        scoreMult = 1; scoreMultTarget = 1; scoreMultDecayTimer = 0; scoreMultPulse = 0;
        paused = false; newHighScore = false; document.getElementById('pauseOverlay').classList.remove('show');
        document.getElementById('pauseBtn').style.display = 'block';
        dash.active = false; dash.timer = 0; dash.cooldown = 0; dash.invincible = false;
        activePowerups = { shield: 0, slowmo: 0, magnet: 0 };
        waveAnnounce = 'WAVE 1'; waveAnnounceTimer = 1.5;
        document.getElementById('menu').classList.add('hidden');
        document.getElementById('gameOver').classList.remove('show');
        document.querySelectorAll('.info-section,.footer').forEach(el => el.style.display = 'none');
        document.body.style.overflow = 'hidden';
    }

    function endGame() {
        gameState = 'dying'; deathSlowmo = deathSlowmoDuration;
        shakeAmount = 25;
        // Death ring
        rings.push({ x: player.x, y: player.y, radius: 5, maxRadius: Math.max(WIDTH, HEIGHT) * 0.8, speed: 300, life: 1, color: '#ff0044', width: 4 });
        // Initial burst
        for (let i = 0; i < 30; i++) {
            const a = Math.random() * Math.PI * 2, sp = Math.random() * 300 + 50;
            particles.push({ x: player.x, y: player.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 1.5, decay: 0.012, size: Math.random()*5+2, color: Math.random()>0.5?'#ff0044':'#ff8800' });
        }
        playDeathSound();
    }

    function updateLifetimeDisplay() {
        const el = document.getElementById('lifetimeStats');
        if (el && lifetime.games > 0) {
            el.innerHTML = `GAMES: ${lifetime.games} | BEST WAVE: ${lifetime.bestWave} | KILLS: ${lifetime.totalKills} | GRAZES: ${lifetime.totalGrazes} | BEST COMBO: x${lifetime.bestCombo}`;
        }
    }

    function finalizeDeath() {
        gameState = 'gameover'; stopBeat(); stopBassDrone(); stopArp();
        document.getElementById('pauseBtn').style.display = 'none';
        document.body.style.overflow = '';
        // Update lifetime stats
        lifetime.games++;
        lifetime.bestWave = Math.max(lifetime.bestWave, wave);
        lifetime.totalKills += killCount;
        lifetime.totalGrazes += grazeCount;
        lifetime.totalTime += gameTime;
        lifetime.bestCombo = Math.max(lifetime.bestCombo, comboBest);
        saveLifetime();
        updateLifetimeDisplay();
        // Final explosion burst
        for (let i = 0; i < 40; i++) {
            const a = Math.random() * Math.PI * 2, sp = Math.random() * 200 + 80;
            particles.push({ x: player.x, y: player.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 1, decay: 0.02, size: Math.random()*4+1, color: Math.random()>0.3?'#ff0044':'#ffffff' });
        }
        flashColor = '#ff0044'; flashAlpha = 0.6;
        if (score > highScore) { highScore = score; localStorage.setItem('neonSurviveHighScore', highScore); }
        const survivalTime = gameTime.toFixed(1);
        const rankInfo = getPerformanceRank(wave, score, grazeCount, comboBest, killCount);
        const tier = getDifficultyTier(wave);
        const tip = getDeathTip(wave, grazeCount, comboBest, killCount, gameTime);
        const isNewHS = score > (localStorage.getItem('neonSurviveHighScore') || 0);
        const newHSBadge = isNewHS ? '<div style="color:#ffff00;font-size:18px;margin-top:5px;animation:pulse 1s infinite">‚òÖ NEW HIGH SCORE ‚òÖ</div>' : '';
        const grazesPerSec = gameTime > 0 ? (grazeCount / gameTime).toFixed(1) : '0.0';
        // Save game to history
        gameHistory.push({ rank: rankInfo.rank, score: Math.floor(score), wave, time: survivalTime, grazes: grazeCount, kills: killCount, combo: comboBest });
        if (gameHistory.length > 10) gameHistory = gameHistory.slice(-10);
        localStorage.setItem('neonSurviveHistory', JSON.stringify(gameHistory));
        // Build history display (last 5)
        const historyHtml = gameHistory.length > 1 ? '<div style="margin-top:18px;font-size:12px;opacity:0.45;line-height:1.7">' +
            'RECENT: ' + gameHistory.slice(-6, -1).reverse().map(h => `<span style="color:${h.rank==='S'||h.rank==='S+'?'#ffff00':h.rank==='A'?'#00ff88':'#aaa'}">${h.rank}</span>`).join(' ‚Üí ') +
            '</div>' : '';
        document.getElementById('finalScore').innerHTML = `<div style="font-size:80px;color:${rankInfo.color};text-shadow:0 0 30px ${rankInfo.glow},0 0 60px ${rankInfo.glow};margin-bottom:5px;animation:pulse 1s infinite">${rankInfo.rank}</div>SCORE: ${Math.floor(score)}${newHSBadge}<div style="margin-top:12px;font-size:16px;opacity:0.8;line-height:1.8">Wave ${wave} <span style="color:${tier.color}">[${tier.name}]</span> | ${survivalTime}s<br>${grazeCount} grazes (${grazesPerSec}/s) | ${killCount} kills | Best combo: x${comboBest}</div>${historyHtml}<div style="margin-top:15px;font-size:13px;opacity:0.55;max-width:400px;line-height:1.5">${tip}</div>`;
        setTimeout(() => document.getElementById('gameOver').classList.add('show'), 800);
    }

    // ============================================
    // POWER-UPS
    // ============================================
    function spawnPowerup() {
        const types = ['shield', 'slowmo', 'magnet'];
        const colors = { shield: '#00aaff', slowmo: '#ff00ff', magnet: '#ffff00' };
        const symbols = { shield: 'üõ°', slowmo: '‚è≥', magnet: 'üß≤' };
        const type = types[Math.floor(Math.random() * types.length)];
        powerups.push({
            x: Math.random() * (WIDTH - 100) + 50,
            y: Math.random() * (HEIGHT - 100) + 50,
            type, color: colors[type], symbol: symbols[type],
            radius: 15, life: 10, pulse: 0
        });
    }

    function collectPowerup(p) {
        activePowerups[p.type] = p.type === 'shield' ? 5 : p.type === 'slowmo' ? 4 : 6;
        playPowerupSound();
        flashColor = p.color; flashAlpha = 0.2;
        // Pickup particles
        for (let i = 0; i < 12; i++) {
            const a = Math.random() * Math.PI * 2;
            particles.push({ x: p.x, y: p.y, vx: Math.cos(a)*150, vy: Math.sin(a)*150, life: 0.6, decay: 0.03, size: 2, color: p.color });
        }
        particles.push({ x: p.x, y: p.y - 15, vx: 0, vy: -60, life: 1, decay: 0.02, size: 0, color: p.color, text: p.type.toUpperCase() });
    }

    // ============================================
    // GAME LOOP
    // ============================================
    let lastTime = 0;
    function gameLoop(timestamp) {
        requestAnimationFrame(gameLoop);
        const rawDt = lastTime ? (timestamp - lastTime) / 1000 : 1/60;
        lastTime = timestamp;
        const dt = Math.min(rawDt, 1/30); // Cap dt to prevent physics jumps

        // Hit freeze ‚Äî skip update for juicy pause on graze
        if (hitFreezeTimer > 0) { hitFreezeTimer -= rawDt; }
        if (gameState === 'playing' && !paused && hitFreezeTimer <= 0) update(dt, timestamp);
        if (gameState === 'dying') updateDying(dt);
        if (gameState === 'menu' || gameState === 'gameover') updateAttractMode(dt);
        updateNebulae(dt);
        // Update rings always
        rings.forEach(r => { r.radius += r.speed * dt; r.life -= dt / (r.maxRadius / r.speed); });
        rings = rings.filter(r => r.life > 0 && r.radius < r.maxRadius);
        render();
    }

    function update(dt, timestamp) {
        // Bullet time tick
        if (bulletTime > 0) bulletTime -= dt;
        const btMult = bulletTime > 0 ? 0.15 : 1;
        const timeMult = (activePowerups.slowmo > 0 ? 0.5 : 1) * btMult;
        const eDt = dt * timeMult; // Enemy delta time (slowed)
        gameTime += dt;

        // Wave system
        waveTimer += dt;
        if (waveBreak) {
            waveBreakTimer += dt;
            if (waveBreakTimer >= waveBreakDuration) {
                waveBreak = false; waveBreakTimer = 0; waveTimer = 0; wave++;
                const waveHints = wave >= 5 ? '‚ö† Snipers active' : wave >= 3 ? '‚ö† Burst enemies' : '';
                waveAnnounce = `WAVE ${wave}`; waveAnnounceTimer = 1.8;
                waveKills = 0; waveGrazes = 0; waveBreakStats = null;
                playSound(600, 0.2, 'square', 0.08);
                setTimeout(() => playSound(800, 0.2, 'square', 0.08), 100);
                updateBassDrone(wave);
                // Boss every 5 waves
                if (wave % 5 === 0 && !boss) { setTimeout(() => { if (gameState === 'playing') spawnBoss(wave); }, 1500); }
            }
        } else if (waveTimer >= waveDuration) {
            waveBreak = true; waveBreakTimer = 0;
            waveBreakStats = { wave, kills: waveKills, grazes: waveGrazes };
            // Perfect wave bonus ‚Äî 5+ grazes in a wave
            const isPerfectWave = waveGrazes >= 5;
            waveBreakStats.perfect = isPerfectWave;
            waveAnnounce = isPerfectWave ? '‚òÖ PERFECT WAVE ‚òÖ' : 'CLEAR!'; waveAnnounceTimer = isPerfectWave ? 2.2 : 1.5;
            flashColor = isPerfectWave ? '#ffdd00' : '#00ff88'; flashAlpha = isPerfectWave ? 0.5 : 0.3;
            playWaveClearSound();
            if (isPerfectWave) {
                // Perfect wave rewards: bonus score + brief shield
                score += 500 * wave;
                activePowerups.shield = Math.max(activePowerups.shield, 3);
                spawnFloatingText(WIDTH/2, HEIGHT/2 + 70, `+${500 * wave} BONUS!`, '#ffdd00', 22, 2);
                // Extra celebration sounds
                setTimeout(() => playSound(1047, 0.2, 'sine', 0.12), 300);
                setTimeout(() => playSound(1319, 0.3, 'sine', 0.1), 500);
                // Golden particles burst
                for (let i = 0; i < 25; i++) {
                    const a = Math.random() * Math.PI * 2, sp = 100 + Math.random() * 200;
                    particles.push({ x: player.x, y: player.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 1.2, decay: 0.015, size: 2 + Math.random()*3, color: Math.random() > 0.5 ? '#ffdd00' : '#ffffff' });
                }
            }
            // Expanding ring VFX
            const ringColor = isPerfectWave ? '#ffdd00' : '#00ff88';
            rings.push({ x: player.x, y: player.y, radius: 20, maxRadius: Math.max(WIDTH, HEIGHT) * 0.6, speed: 600, life: 1, color: ringColor, width: 3 });
            rings.push({ x: player.x, y: player.y, radius: 10, maxRadius: Math.max(WIDTH, HEIGHT) * 0.4, speed: 450, life: 1, color: isPerfectWave ? '#fff' : '#00ffcc', width: 2 });
            // Spawn bonus orb during wave break
            powerups.push({
                x: WIDTH/2 + (Math.random()-0.5)*200, y: HEIGHT/2 + (Math.random()-0.5)*200,
                type: 'shield', color: '#00ffcc', symbol: '‚≠ê',
                radius: 18, life: waveBreakDuration + 0.5, pulse: 0
            });
        }
        if (waveAnnounceTimer > 0) waveAnnounceTimer -= dt;

        difficulty = 1 + (wave - 1) * 0.3 + gameTime * 0.02;
        spawnInterval = waveBreak ? 99999 : Math.max(250, 900 - wave * 60);

        // Combo timer
        if (comboTimer > 0) { comboTimer -= dt; if (comboTimer <= 0) comboCount = 0; }
        // Kill streak timer
        if (killStreakTimer > 0) { killStreakTimer -= dt; if (killStreakTimer <= 0) killStreak = 0; }
        if (killStreakAnnounceTimer > 0) killStreakAnnounceTimer -= dt;
        if (comboAnnounceTimer > 0) { comboAnnounceTimer -= dt; comboAnnounceScale = Math.max(1, comboAnnounceScale - dt * 2); }

        // Beat pulse decay
        if (beatPulse > 0) beatPulse = Math.max(0, beatPulse - dt * 5);

        // Dash update
        if (dash.active) { dash.timer -= dt; if (dash.timer <= 0) { dash.active = false; dash.invincible = false; } }
        if (dash.cooldown > 0) dash.cooldown -= dt;

        // Power-up timers
        for (const k in activePowerups) { if (activePowerups[k] > 0) activePowerups[k] -= dt; }

        // Score multiplier update
        if (scoreMultDecayTimer > 0) { scoreMultDecayTimer -= dt; }
        else { scoreMultTarget = Math.max(1, scoreMultTarget - dt * 0.3); }
        scoreMult += (scoreMultTarget - scoreMult) * dt * 5; // smooth lerp
        if (scoreMultPulse > 0) scoreMultPulse -= dt * 2;

        // Score
        const comboMult = Math.max(1, comboCount);
        score = (gameTime * 10 + grazeCount * 50 * comboMult) * scoreMult;
        // New high score detection
        if (!newHighScore && score > highScore && highScore > 0) {
            newHighScore = true;
            flashColor = '#ffff00'; flashAlpha = 0.4;
            shakeAmount = 8;
            playSound(880, 0.2, 'sine', 0.12);
            setTimeout(() => playSound(1100, 0.2, 'sine', 0.1), 100);
            setTimeout(() => playSound(1320, 0.3, 'sine', 0.1), 200);
            for (let i = 0; i < 20; i++) {
                const a = Math.random() * Math.PI * 2;
                particles.push({ x: player.x, y: player.y, vx: Math.cos(a)*200, vy: Math.sin(a)*200, life: 1.2, decay: 0.015, size: 3, color: '#ffff00' });
            }
            particles.push({ x: WIDTH/2, y: HEIGHT/3, vx: 0, vy: -30, life: 2, decay: 0.012, size: 0, color: '#ffff00', text: '‚òÖ NEW HIGH SCORE ‚òÖ' });
        }
        const comboMult2 = comboCount > 1 ? ` | x${comboCount} COMBO` : '';
        const dashText = dash.cooldown > 0 ? ` | DASH: ${dash.cooldown.toFixed(1)}s` : ' | DASH: ‚úì';
        const tier = getDifficultyTier(wave);
        const multColor = scoreMult >= 4 ? '#ff00ff' : scoreMult >= 3 ? '#ffaa00' : scoreMult >= 2 ? '#00ffff' : '#00ff88';
        const multText = scoreMult > 1.05 ? ` | <span style="color:${multColor};text-shadow:0 0 8px ${multColor}">x${scoreMult.toFixed(1)}</span>` : '';
        document.getElementById('scoreDisplay').innerHTML = `WAVE ${wave} <span style="color:${tier.color};font-size:0.8em">[${tier.name}]</span> | ${Math.floor(score)} pts${multText} | GRAZE: ${grazeCount}${comboMult2}${dashText}`;

        // Power-up HUD
        const pTexts = [];
        if (activePowerups.shield > 0) pTexts.push(`üõ° ${activePowerups.shield.toFixed(1)}s`);
        if (activePowerups.slowmo > 0) pTexts.push(`‚è≥ ${activePowerups.slowmo.toFixed(1)}s`);
        if (activePowerups.magnet > 0) pTexts.push(`üß≤ ${activePowerups.magnet.toFixed(1)}s`);
        document.getElementById('powerupHud').textContent = pTexts.join('  ');

        updatePlayer(dt);

        // Spawn enemies
        if (timestamp - lastSpawn > spawnInterval) { spawnEnemy(); lastSpawn = timestamp; }

        // Spawn power-ups (every 8-12 seconds)
        if (timestamp - lastPowerupSpawn > 8000 + Math.random() * 4000) {
            if (powerups.length < 3) spawnPowerup();
            lastPowerupSpawn = timestamp;
        }

        updateEnemies(eDt);
        updatePowerups(dt);
        // Score orbs update
        scoreOrbs.forEach(o => {
            o.vx *= 0.96; o.vy *= 0.96;
            o.x += o.vx * dt; o.y += o.vy * dt;
            o.life -= dt; o.pulse += dt * 4;
            // Magnet toward player when close or magnet active
            const odx = player.x - o.x, ody = player.y - o.y;
            const odist = Math.sqrt(odx*odx + ody*ody);
            const magnetRange = activePowerups.magnet > 0 ? 300 : 80;
            if (odist < magnetRange && odist > 5) {
                const pull = activePowerups.magnet > 0 ? 350 : 150;
                o.vx += (odx/odist) * pull * dt;
                o.vy += (ody/odist) * pull * dt;
            }
            // Collection
            if (odist < player.radius + o.radius + 8) {
                score += o.value;
                o.life = 0;
                playOrbCollectSound();
                // Orb chain tracking
                orbChainCount++; orbChainTimer = 0.5;
                const chainBonus = orbChainCount >= 5 ? 3 : orbChainCount >= 3 ? 2 : 1;
                const orbText = orbChainCount >= 3 ? `+${o.value}x${chainBonus}` : `+${o.value}`;
                if (chainBonus > 1) score += o.value * (chainBonus - 1); // bonus score
                particles.push({ x: o.x, y: o.y - 8, vx: 0, vy: -50, life: 0.6, decay: 0.03, size: 0, color: orbChainCount >= 5 ? '#ff8800' : '#ffdd00', text: orbText });
                const sparkCount = 3 + (orbChainCount >= 3 ? 4 : 0);
                for (let si = 0; si < sparkCount; si++) {
                    const sa = Math.random() * Math.PI * 2;
                    const sspd = orbChainCount >= 3 ? 120 : 60;
                    particles.push({ x: o.x, y: o.y, vx: Math.cos(sa)*sspd, vy: Math.sin(sa)*sspd, life: 0.3 + (orbChainCount >= 3 ? 0.2 : 0), decay: 0.04, size: 2, color: orbChainCount >= 5 ? '#ff8800' : '#ffdd00' });
                }
                if (orbChainCount === 5) {
                    spawnFloatingText(player.x, player.y - 30, '‚ö° ORB CHAIN!', '#ff8800', 20, 1.2);
                    shakeAmount = Math.max(shakeAmount, 3);
                }
            }
        });
        scoreOrbs = scoreOrbs.filter(o => o.life > 0);
        if (scoreOrbs.length > 50) scoreOrbs.splice(0, scoreOrbs.length - 50);
        // Orb chain timer
        if (orbChainTimer > 0) { orbChainTimer -= dt; } else { orbChainCount = 0; }
        updateParticles(dt);
        updateStars(dt);
        // Boss update
        if (boss) {
            boss.pulse += dt * 3;
            boss.shieldAngle += dt * 2;
            boss.flashTimer = Math.max(0, boss.flashTimer - dt);
            // Slowly chase player
            const bdx = player.x - boss.x, bdy = player.y - boss.y;
            const bdist = Math.sqrt(bdx*bdx + bdy*bdy) || 1;
            boss.vx += (bdx/bdist) * boss.speed * dt * 2;
            boss.vy += (bdy/bdist) * boss.speed * dt * 2;
            const bspd = Math.sqrt(boss.vx*boss.vx + boss.vy*boss.vy);
            if (bspd > boss.speed) { boss.vx = (boss.vx/bspd)*boss.speed; boss.vy = (boss.vy/bspd)*boss.speed; }
            boss.x += boss.vx * dt; boss.y += boss.vy * dt;
            boss.trail.push({ x: boss.x, y: boss.y, life: 1 });
            if (boss.trail.length > 10) boss.trail.shift();
            boss.trail.forEach(t => t.life -= 0.08);
            // Boss collision
            const bcd = Math.sqrt((player.x-boss.x)**2 + (player.y-boss.y)**2);
            if (bcd < player.radius + boss.radius) {
                if (dash.invincible || activePowerups.shield > 0) {
                    boss.hp--;
                    boss.flashTimer = 0.3;
                    shakeAmount = 15;
                    playSound(150, 0.3, 'sawtooth', 0.2);
                    // Knockback boss
                    const kbx = boss.x - player.x, kby = boss.y - player.y;
                    const kbd = Math.sqrt(kbx*kbx + kby*kby) || 1;
                    boss.vx = (kbx/kbd) * 300; boss.vy = (kby/kbd) * 300;
                    // Hit particles
                    for (let i = 0; i < 12; i++) {
                        const a = Math.random() * Math.PI * 2, sp = 150 + Math.random() * 100;
                        particles.push({ x: boss.x, y: boss.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.6, decay: 0.025, size: 3, color: '#ff4400' });
                    }
                    spawnFloatingText(boss.x, boss.y - 30, `üí• ${boss.hp > 0 ? boss.hp + ' HP' : 'DEFEATED!'}`, '#ff8800', 22, 1.2);
                    if (boss.hp <= 0) {
                        // Boss defeated!
                        score += 1000 * wave;
                        killCount += 3;
                        spawnFloatingText(boss.x, boss.y - 60, `+${1000 * wave} BOSS KILL!`, '#ffdd00', 28, 2.5);
                        rings.push({ x: boss.x, y: boss.y, radius: 10, maxRadius: Math.max(WIDTH,HEIGHT)*0.7, speed: 400, life: 1, color: '#ff8800', width: 4 });
                        // Big explosion
                        for (let i = 0; i < 40; i++) {
                            const a = Math.random() * Math.PI * 2, sp = 100 + Math.random() * 250;
                            particles.push({ x: boss.x, y: boss.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 1.2, decay: 0.015, size: 2+Math.random()*5, color: ['#ff4400','#ffdd00','#ff8800','#ffffff'][Math.floor(Math.random()*4)] });
                        }
                        // Drop lots of orbs
                        for (let i = 0; i < 12; i++) {
                            const oa = Math.random() * Math.PI * 2, ospd = 60 + Math.random() * 100;
                            scoreOrbs.push({ x: boss.x, y: boss.y, vx: Math.cos(oa)*ospd, vy: Math.sin(oa)*ospd, life: 5, value: 50, radius: 5, pulse: Math.random() * Math.PI * 2 });
                        }
                        // Guaranteed power-up drop
                        const types = ['shield', 'slowmo', 'magnet'];
                        const colors = { shield: '#00aaff', slowmo: '#ff00ff', magnet: '#ffff00' };
                        const symbols = { shield: 'üõ°', slowmo: '‚è≥', magnet: 'üß≤' };
                        const t = types[Math.floor(Math.random() * types.length)];
                        powerups.push({ x: boss.x, y: boss.y, type: t, color: colors[t], symbol: symbols[t], radius: 14, pulse: 0, life: 10 });
                        playSound(800, 0.3, 'sine', 0.15);
                        setTimeout(() => playSound(1200, 0.2, 'sine', 0.12), 100);
                        setTimeout(() => playSound(1600, 0.15, 'sine', 0.1), 200);
                        boss = null;
                    }
                } else {
                    endGame();
                }
            }
        }
        checkCollisions();

        // Floating texts update
        floatingTexts.forEach(ft => { ft.x += ft.vx * dt; ft.y += ft.vy * dt; ft.duration -= dt; });
        floatingTexts = floatingTexts.filter(ft => ft.duration > 0);
        if (floatingTexts.length > 20) floatingTexts.splice(0, floatingTexts.length - 20);

        // Edge warnings
        edgeWarnings.forEach(w => w.life -= dt * 2);
        edgeWarnings = edgeWarnings.filter(w => w.life > 0);

        // Speed lines update
        speedLines.forEach(l => l.life -= l.decay);
        speedLines = speedLines.filter(l => l.life > 0);
        if (dash.active) spawnSpeedLines();

        // Proximity heartbeat ‚Äî find closest enemy, beat faster when near
        let closestEnemyDist = Infinity;
        enemies.forEach(e => {
            const dx = player.x - e.x, dy = player.y - e.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d < closestEnemyDist) closestEnemyDist = d;
        });
        if (closestEnemyDist < 150 && enemies.length > 0) {
            const closeness = 1 - closestEnemyDist / 150; // 0-1, 1 = touching
            const beatRate = 0.6 - closeness * 0.45; // 0.6s to 0.15s between beats
            proximityBeatTimer += dt;
            if (proximityBeatTimer >= beatRate) {
                proximityBeatTimer = 0;
                playProximityBeat(closeness);
            }
        } else {
            proximityBeatTimer = 0;
        }

        // Dash afterimages ‚Äî capture player ghost every few frames during dash
        if (dash.active && Math.random() < 0.7) {
            dashAfterimages.push({
                x: player.x, y: player.y,
                angle: Math.atan2(player.vy, player.vx),
                life: 0.35, maxLife: 0.35
            });
        }
        dashAfterimages.forEach(a => a.life -= dt);
        dashAfterimages = dashAfterimages.filter(a => a.life > 0);
        if (dashAfterimages.length > 15) dashAfterimages.splice(0, dashAfterimages.length - 15);

        // Danger border pulse ‚Äî intensifies with enemy count
        dangerPulse += dt * 3;

        if (shakeAmount > 0) { shakeAmount *= 0.9; if (shakeAmount < 0.1) shakeAmount = 0; }
    }

    function updateDying(dt) {
        deathSlowmo -= dt;
        const slowFactor = 0.05 + 0.15 * (1 - deathSlowmo / deathSlowmoDuration);
        // Still update particles slowly for dramatic effect
        particles.forEach(p => { p.x += p.vx * dt * slowFactor; p.y += p.vy * dt * slowFactor; p.life -= p.decay * slowFactor; });
        particles = particles.filter(p => p.life > 0);
        // Enemies slow to crawl
        enemies.forEach(e => { e.x += e.vx * dt * slowFactor; e.y += e.vy * dt * slowFactor; });
        updateStars(dt * slowFactor);
        if (shakeAmount > 0) { shakeAmount *= 0.95; if (shakeAmount < 0.1) shakeAmount = 0; }
        if (deathSlowmo <= 0) finalizeDeath();
    }

    function updatePlayer(dt) {
        const accel = 800, maxSpeed = dash.active ? dash.speed : 400, friction = 0.85;
        if (keys['w'] || keys['arrowup']) player.vy -= accel * dt;
        if (keys['s'] || keys['arrowdown']) player.vy += accel * dt;
        if (keys['a'] || keys['arrowleft']) player.vx -= accel * dt;
        if (keys['d'] || keys['arrowright']) player.vx += accel * dt;

        if (mouse.active && gameState === 'playing') {
            const dx = mouse.x - player.x, dy = mouse.y - player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 5) { player.vx += (dx/dist)*accel*dt*0.5; player.vy += (dy/dist)*accel*dt*0.5; }
        }
        if (touch.active) {
            const dx = touch.x - player.x, dy = touch.y - player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 5) { player.vx += (dx/dist)*accel*dt; player.vy += (dy/dist)*accel*dt; }
        }

        player.vx *= friction; player.vy *= friction;
        const speed = Math.sqrt(player.vx*player.vx + player.vy*player.vy);
        if (speed > maxSpeed) { player.vx = (player.vx/speed)*maxSpeed; player.vy = (player.vy/speed)*maxSpeed; }

        player.x += player.vx * dt;
        player.y += player.vy * dt;
        const oldX = player.x, oldY = player.y;
        player.x = Math.max(player.radius, Math.min(WIDTH - player.radius, player.x));
        player.y = Math.max(player.radius, Math.min(HEIGHT - player.radius, player.y));
        // Wall sparks on edge collision
        const wallSpeed = Math.sqrt(player.vx*player.vx + player.vy*player.vy);
        if (wallSpeed > 80 && (player.x !== oldX || player.y !== oldY)) {
            const wx = player.x !== oldX ? player.x : player.x;
            const wy = player.y !== oldY ? player.y : player.y;
            for (let i = 0; i < 4; i++) {
                const a = Math.random() * Math.PI * 2;
                const sp = 60 + Math.random() * 100;
                particles.push({ x: wx, y: wy, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.3, decay: 0.04, size: 1.5, color: '#00ff88' });
            }
            shakeAmount = Math.max(shakeAmount, 2);
            playWallSparkSound();
        }

        player.trail.push({ x: player.x, y: player.y, life: 1 });
        if (player.trail.length > (dash.active ? 25 : 15)) player.trail.shift();
        player.trail.forEach(t => t.life -= 0.05);
    }

    function spawnEnemy() {
        const r = Math.random();
        // Sniper spawns from wave 3+, 12% chance
        const type = (wave >= 3 && r < 0.12) ? 'sniper' : r < 0.5 ? 'basic' : r < 0.8 ? 'homing' : 'burst';
        const side = Math.floor(Math.random() * 4);
        let x, y;
        if (side === 0) { x = Math.random() * WIDTH; y = -20; }
        else if (side === 1) { x = WIDTH + 20; y = Math.random() * HEIGHT; }
        else if (side === 2) { x = Math.random() * WIDTH; y = HEIGHT + 20; }
        else { x = -20; y = Math.random() * HEIGHT; }

        const dx = player.x - x, dy = player.y - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const speed = type === 'sniper' ? 20 * difficulty : (50 + Math.random() * 50) * difficulty;

        const colors = { basic: '#ff0044', homing: '#ffaa00', burst: '#ff00ff', sniper: '#ff4444' };
        const radii = { basic: 8, homing: 10, burst: 12, sniper: 9 };

        enemies.push({
            x, y, vx: (dx/dist)*speed, vy: (dy/dist)*speed,
            type, radius: radii[type], color: colors[type], grazed: false,
            burstTimer: type === 'burst' ? 2 + Math.random() : 0,
            // Sniper: locks position, charges laser sight, then fires fast projectile
            sniperPhase: type === 'sniper' ? 'approach' : null,
            sniperTimer: type === 'sniper' ? 1.5 : 0, // approach time
            sniperAimX: 0, sniperAimY: 0, sniperChargeTime: 1.2,
            trail: []
        });
        playSound(type === 'sniper' ? 200 : 400, 0.05, 'sine', 0.02);
        // Edge warning
        edgeWarnings.push({ x, y, life: 0.5, color: colors[type] || '#ff0044' });
    }

    function updateEnemies(dt) {
        const toAdd = [];
        enemies.forEach(e => {
            if (e.type === 'homing') {
                const dx = player.x - e.x, dy = player.y - e.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const turnSpeed = 100 * difficulty;
                e.vx += (dx/dist)*turnSpeed*dt; e.vy += (dy/dist)*turnSpeed*dt;
                const sp = Math.sqrt(e.vx*e.vx + e.vy*e.vy);
                const ms = 200 * difficulty;
                if (sp > ms) { e.vx = (e.vx/sp)*ms; e.vy = (e.vy/sp)*ms; }
            }
            if (e.type === 'burst') {
                e.burstTimer -= dt;
                if (e.burstTimer <= 0) {
                    for (let i = 0; i < 4; i++) {
                        const a = (Math.PI * 2 / 4) * i;
                        toAdd.push({
                            x: e.x, y: e.y,
                            vx: Math.cos(a) * 150 * difficulty, vy: Math.sin(a) * 150 * difficulty,
                            type: 'basic', radius: 5, color: '#ff66ff', grazed: false, burstTimer: 0, trail: []
                        });
                    }
                    for (let i = 0; i < 8; i++) {
                        const a = Math.random() * Math.PI * 2;
                        particles.push({ x: e.x, y: e.y, vx: Math.cos(a)*120, vy: Math.sin(a)*120, life: 0.5, decay: 0.03, size: 2, color: '#ff00ff' });
                    }
                    playSound(300, 0.15, 'square', 0.08);
                    e.life = 0;
                }
            }
            // Sniper enemy: approach ‚Üí lock ‚Üí charge (laser sight) ‚Üí fire fast bullet
            if (e.type === 'sniper' && e.sniperPhase) {
                if (e.sniperPhase === 'approach') {
                    e.sniperTimer -= dt;
                    if (e.sniperTimer <= 0) {
                        e.sniperPhase = 'charge';
                        e.sniperTimer = e.sniperChargeTime;
                        e.vx = 0; e.vy = 0; // Stop moving
                        // Lock aim at player's current position
                        e.sniperAimX = player.x; e.sniperAimY = player.y;
                        playSound(150, 0.3, 'sawtooth', 0.04); // Charging sound
                    }
                } else if (e.sniperPhase === 'charge') {
                    e.sniperTimer -= dt;
                    // Update aim to track player slowly during charge (slight tracking)
                    const aimDx = player.x - e.sniperAimX, aimDy = player.y - e.sniperAimY;
                    e.sniperAimX += aimDx * dt * 0.8;
                    e.sniperAimY += aimDy * dt * 0.8;
                    if (e.sniperTimer <= 0) {
                        // Fire!
                        const fdx = e.sniperAimX - e.x, fdy = e.sniperAimY - e.y;
                        const fd = Math.sqrt(fdx*fdx + fdy*fdy) || 1;
                        const bulletSpeed = 500 * difficulty;
                        toAdd.push({
                            x: e.x, y: e.y,
                            vx: (fdx/fd)*bulletSpeed, vy: (fdy/fd)*bulletSpeed,
                            type: 'basic', radius: 5, color: '#ff6666', grazed: false, burstTimer: 0, trail: []
                        });
                        // Fire VFX
                        playSound(800, 0.08, 'square', 0.15);
                        shakeAmount = Math.max(shakeAmount, 4);
                        for (let i = 0; i < 6; i++) {
                            const a = Math.atan2(fdy, fdx) + (Math.random()-0.5)*0.5;
                            const sp = 100 + Math.random()*100;
                            particles.push({ x: e.x, y: e.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.3, decay: 0.04, size: 2, color: '#ff4444' });
                        }
                        e.life = 0; // Sniper disappears after firing
                    }
                }
            }
            e.x += e.vx * dt; e.y += e.vy * dt;
            // Enemy trail
            e.trail.push({ x: e.x, y: e.y, life: 1 });
            if (e.trail.length > 8) e.trail.shift();
            e.trail.forEach(t => t.life -= 0.12);
        });
        enemies = enemies.filter(e => e.life !== 0 && e.x > -100 && e.x < WIDTH+100 && e.y > -100 && e.y < HEIGHT+100);
        enemies.push(...toAdd);
    }

    function updatePowerups(dt) {
        powerups.forEach(p => {
            p.life -= dt; p.pulse += dt * 3;
            // Magnet effect ‚Äî pull toward player
            if (activePowerups.magnet > 0) {
                const dx = player.x - p.x, dy = player.y - p.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 10 && dist < 300) {
                    p.x += (dx/dist) * 200 * dt;
                    p.y += (dy/dist) * 200 * dt;
                }
            }
        });
        powerups = powerups.filter(p => p.life > 0);
    }

    function updateParticles(dt) {
        particles.forEach(p => { p.x += p.vx*dt; p.y += p.vy*dt; p.vx *= 0.98; p.vy *= 0.98; p.life -= p.decay; });
        particles = particles.filter(p => p.life > 0);
        // Cap particles to prevent memory issues during intense gameplay
        const maxParticles = settings.particles ? 200 : 50;
        if (particles.length > maxParticles) particles.splice(0, particles.length - maxParticles);
    }

    function updateStars(dt) {
        stars.forEach(s => {
            s.y += s.speed;
            // Parallax: deeper layers react slightly to player movement
            if (gameState === 'playing' && s.layer > 0) {
                s.x -= player.vx * dt * s.layer * 0.015;
            }
            if (s.y > HEIGHT) { s.y = 0; s.x = Math.random() * WIDTH; }
            if (s.x < 0) s.x = WIDTH;
            if (s.x > WIDTH) s.x = 0;
        });
    }

    function checkCollisions() {
        // Enemy collisions
        enemies.forEach(e => {
            const dx = player.x - e.x, dy = player.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < player.radius + e.radius) {
                if (dash.invincible || activePowerups.shield > 0) {
                    // Destroy enemy ‚Äî satisfying explosion
                    e.life = 0; killCount++; waveKills++;
                    killStreak++; killStreakTimer = 1.5;
                    scoreMultTarget = Math.min(MULT_MAX, scoreMultTarget + 0.25); scoreMultDecayTimer = MULT_DECAY_DELAY; scoreMultPulse = 0.5;
                    if (killStreak === 3) { killStreakAnnounce = 'TRIPLE KILL!'; killStreakAnnounceTimer = 1.2; playSound(1000, 0.15, 'square', 0.1); }
                    else if (killStreak === 5) { killStreakAnnounce = 'RAMPAGE!'; killStreakAnnounceTimer = 1.2; playSound(1200, 0.2, 'square', 0.12); }
                    else if (killStreak >= 8) { killStreakAnnounce = 'UNSTOPPABLE!'; killStreakAnnounceTimer = 1.5; playSound(1500, 0.25, 'square', 0.15); }
                    shakeAmount = 10;
                    // Ring burst
                    for (let i = 0; i < 16; i++) {
                        const a = (Math.PI * 2 / 16) * i;
                        const sp = 180 + Math.random() * 80;
                        particles.push({ x: e.x, y: e.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.7, decay: 0.02, size: 2 + Math.random()*3, color: e.color });
                    }
                    // Center flash
                    particles.push({ x: e.x, y: e.y, vx: 0, vy: 0, life: 0.4, decay: 0.04, size: e.radius * 3, color: '#fff' });
                    // Score popup
                    particles.push({ x: e.x, y: e.y - 15, vx: 0, vy: -70, life: 1, decay: 0.02, size: 0, color: '#ffff00', text: '+100' });
                    playSound(500, 0.1, 'square', 0.12);
                    setTimeout(() => playSound(700, 0.08, 'sine', 0.08), 50);
                    score += 100;
                    // Spawn score orbs from killed enemy
                    const orbCount = 2 + Math.floor(Math.random() * 2);
                    for (let oi = 0; oi < orbCount; oi++) {
                        const oa = Math.random() * Math.PI * 2;
                        const ospd = 40 + Math.random() * 80;
                        scoreOrbs.push({ x: e.x, y: e.y, vx: Math.cos(oa)*ospd, vy: Math.sin(oa)*ospd, life: 4, value: 25, radius: 4, pulse: Math.random() * Math.PI * 2 });
                    }
                } else {
                    endGame();
                }
            }
            // Graze
            const grazeDist = player.radius + e.radius + 25;
            if (!e.grazed && dist < grazeDist && dist > player.radius + e.radius) {
                e.grazed = true; grazeCount++; waveGrazes++; comboCount++; comboTimer = 2;
                // Score multiplier boost
                scoreMultTarget = Math.min(MULT_MAX, scoreMultTarget + 0.15); scoreMultDecayTimer = MULT_DECAY_DELAY; scoreMultPulse = 0.5;
                if (comboCount > comboBest) comboBest = comboCount;
                playGrazeStreakSound(comboCount);
                // Hit freeze ‚Äî brief pause for game feel (scales with combo)
                hitFreezeTimer = Math.min(0.06, 0.03 + comboCount * 0.003);
                // Combo announcement
                const cAnn = getComboAnnouncement(comboCount);
                if (cAnn) {
                    comboAnnounce = cAnn.text; comboAnnounceTimer = 1.5; comboAnnounceColor = cAnn.color; comboAnnounceScale = 1.5;
                    playSound(cAnn.sound, 0.12, 'square', 0.1);
                    shakeAmount = Math.max(shakeAmount, 3 + comboCount * 0.5);
                }
                // Near-death bullet time ‚Äî very close grazes trigger micro slow-mo
                const closeness = dist - (player.radius + e.radius);
                if (closeness < 8) {
                    bulletTime = bulletTimeDuration;
                    flashColor = '#ffffff'; flashAlpha = 0.25;
                    shakeAmount = Math.max(shakeAmount, 6);
                    // Extra dramatic particles for near-death
                    for (let nd = 0; nd < 10; nd++) {
                        const na = Math.random()*Math.PI*2, ns = Math.random()*200+80;
                        particles.push({ x: player.x, y: player.y, vx: Math.cos(na)*ns, vy: Math.sin(na)*ns, life: 0.5, decay: 0.03, size: 1+Math.random()*2, color: '#ffffff' });
                    }
                    playSound(1400, 0.08, 'sine', 0.12);
                } else {
                    flashColor = '#00ffff'; flashAlpha = 0.1 + comboCount * 0.02;
                }
                const mx = (player.x+e.x)/2, my = (player.y+e.y)/2;
                for (let p = 0; p < 6; p++) {
                    const a = Math.random()*Math.PI*2, sp = Math.random()*120+40;
                    particles.push({ x: mx, y: my, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.6, decay: 0.025, size: Math.random()*3+1, color: comboCount>3?'#ffff00':'#00ffff' });
                }
                particles.push({ x: mx, y: my-10, vx: 0, vy: -80, life: 0.8, decay: 0.025, size: 0, color: comboCount>3?'#ffff00':'#00ffff', text: comboCount>1?`x${comboCount}`:'+50' });
            }
        });
        enemies = enemies.filter(e => e.life !== 0);

        // Power-up collisions (iterate backwards for safe splice)
        for (let i = powerups.length - 1; i >= 0; i--) {
            const p = powerups[i];
            const dx = player.x - p.x, dy = player.y - p.y;
            if (Math.sqrt(dx*dx + dy*dy) < player.radius + p.radius) {
                collectPowerup(p);
                powerups.splice(i, 1);
            }
        }
    }

    // ============================================
    // RENDERING
    // ============================================
    function render() {
        // Dynamic background ‚Äî shifts hue with wave
        const isActive = (gameState === 'playing' || gameState === 'dying') && !paused;
        if (isActive) {
            const isDying = gameState === 'dying';
            if (!cachedBgGrad || bgGradWave !== wave || bgGradW !== WIDTH || bgGradH !== HEIGHT || bgGradDying !== isDying) {
                const waveHue = isDying ? 0 : ((wave - 1) * 30) % 360;
                const sat = isDying ? '60%' : '40%';
                cachedBgGrad = ctx.createRadialGradient(WIDTH/2, HEIGHT/2, 0, WIDTH/2, HEIGHT/2, HEIGHT * 0.9);
                cachedBgGrad.addColorStop(0, `hsla(${waveHue}, ${sat}, 4%, 1)`);
                cachedBgGrad.addColorStop(0.5, `hsla(${waveHue + 20}, 50%, 2%, 1)`);
                cachedBgGrad.addColorStop(1, '#000');
                bgGradWave = wave; bgGradW = WIDTH; bgGradH = HEIGHT; bgGradDying = isDying;
            }
            ctx.fillStyle = cachedBgGrad;
        } else {
            ctx.fillStyle = '#000';
        }
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        if (shakeAmount > 0 && settings.shake) { ctx.save(); ctx.translate((Math.random()-0.5)*shakeAmount, (Math.random()-0.5)*shakeAmount); }

        // Beat pulse overlay (subtle background throb)
        if (isActive && beatPulse > 0 && !muted) {
            ctx.fillStyle = `rgba(0,255,136,${beatPulse * 0.04})`;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
        }

        // Grid ‚Äî scrolls with player movement for parallax depth
        if (isActive) {
            const gridSize = 50;
            const gox = (-player.x * 0.15) % gridSize, goy = (-player.y * 0.15) % gridSize;
            ctx.strokeStyle = 'rgba(0,255,136,0.04)'; ctx.lineWidth = 1;
            for (let x = gox; x < WIDTH; x += gridSize) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,HEIGHT); ctx.stroke(); }
            for (let y = goy; y < HEIGHT; y += gridSize) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(WIDTH,y); ctx.stroke(); }
        }

        // Stars (parallax layers)
        stars.forEach(s => {
            const alpha = s.layer === 0 ? 0.3 : s.layer === 1 ? 0.5 : 0.8;
            ctx.fillStyle = `rgba(255,255,255,${alpha})`;
            ctx.fillRect(s.x, s.y, s.size, s.size);
        });

        // Nebula clouds
        renderNebulae();

        // Attract mode enemies (menu/gameover background)
        if (gameState === 'menu' || gameState === 'gameover') renderAttractMode();

        if (isActive) {
            // Player trail
            player.trail.forEach(t => {
                if (t.life > 0) {
                    ctx.globalAlpha = t.life * (dash.active ? 0.8 : 0.5);
                    ctx.fillStyle = dash.active ? '#88ffcc' : '#00ff88';
                    ctx.beginPath(); ctx.arc(t.x, t.y, player.radius * t.life * (dash.active ? 0.7 : 0.5), 0, Math.PI*2); ctx.fill();
                }
            });
            ctx.globalAlpha = 1;

            // Dash afterimages
            dashAfterimages.forEach(a => {
                const alpha = (a.life / a.maxLife) * 0.4;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(a.x, a.y);
                ctx.rotate(a.angle);
                ctx.fillStyle = '#00ff88';
                ctx.shadowBlur = 15; ctx.shadowColor = '#00ff88';
                const r = player.radius;
                ctx.beginPath();
                ctx.moveTo(r * 1.3, 0);
                ctx.lineTo(-r * 0.8, -r * 0.9);
                ctx.lineTo(-r * 0.4, 0);
                ctx.lineTo(-r * 0.8, r * 0.9);
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            // Shield visual
            if (activePowerups.shield > 0) {
                ctx.strokeStyle = '#00aaff';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.4 + Math.sin(gameTime * 6) * 0.2;
                ctx.shadowBlur = 15; ctx.shadowColor = '#00aaff';
                ctx.beginPath(); ctx.arc(player.x, player.y, player.radius + 10, 0, Math.PI*2); ctx.stroke();
                ctx.globalAlpha = 1; ctx.shadowBlur = 0;
            }

            // Dash invincibility glow
            if (dash.invincible) {
                ctx.strokeStyle = '#88ffcc'; ctx.lineWidth = 3; ctx.globalAlpha = 0.6;
                ctx.beginPath(); ctx.arc(player.x, player.y, player.radius + 6, 0, Math.PI*2); ctx.stroke();
                ctx.globalAlpha = 1;
            }

            // Player (rotating triangle)
            ctx.save();
            ctx.translate(player.x, player.y);
            const angle = Math.atan2(player.vy, player.vx) || 0;
            ctx.rotate(angle);
            const comboGlow = Math.min(comboCount, 10);
            const playerHue = comboGlow > 5 ? `hsl(${160 - comboGlow * 8}, 100%, 60%)` : (activePowerups.shield > 0 ? '#44ccff' : '#00ff88');
            ctx.shadowBlur = 25 + comboGlow * 3; ctx.shadowColor = playerHue;
            ctx.fillStyle = playerHue;
            const r = player.radius;
            ctx.beginPath();
            ctx.moveTo(r * 1.3, 0);
            ctx.lineTo(-r * 0.8, -r * 0.9);
            ctx.lineTo(-r * 0.4, 0);
            ctx.lineTo(-r * 0.8, r * 0.9);
            ctx.closePath();
            ctx.fill();
            // Core glow
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(0, 0, r * 0.3, 0, Math.PI*2); ctx.fill();
            // Engine glow
            ctx.fillStyle = dash.active ? '#88ffcc' : 'rgba(0,255,136,0.5)';
            ctx.beginPath(); ctx.arc(-r * 0.5, 0, r * 0.25 + Math.random() * 2, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
            ctx.restore();

            // Speed lines
            speedLines.forEach(l => {
                ctx.globalAlpha = l.life * 0.6;
                ctx.strokeStyle = '#88ffcc'; ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(l.x, l.y);
                ctx.lineTo(l.x + Math.cos(l.angle)*l.length, l.y + Math.sin(l.angle)*l.length);
                ctx.stroke();
            });
            ctx.globalAlpha = 1;

            // Enemies (trails first, then bodies)
            let enemyIdx = 0;
            enemies.forEach(e => {
                const useShadow = enemyIdx < 10; // Limit shadowBlur to first 10 enemies for perf
                enemyIdx++;
                // Enemy trail
                e.trail.forEach(t => {
                    if (t.life > 0) {
                        ctx.globalAlpha = t.life * 0.3;
                        ctx.fillStyle = e.color;
                        ctx.beginPath(); ctx.arc(t.x, t.y, e.radius * t.life * 0.6, 0, Math.PI*2); ctx.fill();
                    }
                });
                ctx.globalAlpha = 1;
                if (useShadow) { ctx.shadowBlur = 15; ctx.shadowColor = e.color; }
                ctx.fillStyle = e.color;
                if (e.type === 'homing') {
                    // Diamond shape for homing
                    ctx.save(); ctx.translate(e.x, e.y);
                    ctx.rotate(Math.atan2(e.vy, e.vx));
                    ctx.beginPath();
                    ctx.moveTo(e.radius * 1.3, 0);
                    ctx.lineTo(0, -e.radius * 0.8);
                    ctx.lineTo(-e.radius * 0.8, 0);
                    ctx.lineTo(0, e.radius * 0.8);
                    ctx.closePath(); ctx.fill();
                    ctx.restore();
                } else if (e.type === 'burst') {
                    // Star shape for burst
                    ctx.save(); ctx.translate(e.x, e.y);
                    ctx.rotate(gameTime * 2);
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const a1 = (Math.PI * 2 / 5) * i - Math.PI / 2;
                        const a2 = a1 + Math.PI / 5;
                        ctx.lineTo(Math.cos(a1) * e.radius * 1.2, Math.sin(a1) * e.radius * 1.2);
                        ctx.lineTo(Math.cos(a2) * e.radius * 0.5, Math.sin(a2) * e.radius * 0.5);
                    }
                    ctx.closePath(); ctx.fill();
                    ctx.restore();
                } else {
                    // Circle for basic
                    ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2); ctx.fill();
                }
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.beginPath(); ctx.arc(e.x, e.y, e.radius * 0.4, 0, Math.PI*2); ctx.fill();
                // Burst timer visual
                if (e.type === 'burst' && e.burstTimer < 1) {
                    ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5 + Math.sin(gameTime * 15) * 0.5;
                    ctx.beginPath(); ctx.arc(e.x, e.y, e.radius + 5 + Math.sin(gameTime*10)*3, 0, Math.PI*2); ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                // Sniper laser sight ‚Äî red dashed line from sniper to aim point during charge
                if (e.type === 'sniper' && e.sniperPhase === 'charge') {
                    const chargeProgress = 1 - (e.sniperTimer / e.sniperChargeTime);
                    const laserAlpha = 0.15 + chargeProgress * 0.6;
                    const laserWidth = 1 + chargeProgress * 2;
                    ctx.save();
                    ctx.globalAlpha = laserAlpha;
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = laserWidth;
                    ctx.shadowBlur = 8 + chargeProgress * 15;
                    ctx.shadowColor = '#ff0000';
                    ctx.setLineDash([8, 6]);
                    ctx.lineDashOffset = -gameTime * 80;
                    ctx.beginPath();
                    ctx.moveTo(e.x, e.y);
                    ctx.lineTo(e.sniperAimX, e.sniperAimY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.shadowBlur = 0;
                    // Crosshair at aim point
                    if (chargeProgress > 0.3) {
                        const chSize = 8 + chargeProgress * 6;
                        ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 1.5;
                        ctx.globalAlpha = laserAlpha * 0.8;
                        ctx.beginPath(); ctx.arc(e.sniperAimX, e.sniperAimY, chSize, 0, Math.PI*2); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(e.sniperAimX - chSize - 4, e.sniperAimY); ctx.lineTo(e.sniperAimX + chSize + 4, e.sniperAimY); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(e.sniperAimX, e.sniperAimY - chSize - 4); ctx.lineTo(e.sniperAimX, e.sniperAimY + chSize + 4); ctx.stroke();
                    }
                    ctx.restore();
                }
                // Sniper body ‚Äî crosshair/scope shape
                if (e.type === 'sniper') {
                    ctx.save(); ctx.translate(e.x, e.y);
                    ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 2;
                    if (useShadow) { ctx.shadowBlur = 12; ctx.shadowColor = '#ff4444'; }
                    ctx.beginPath(); ctx.arc(0, 0, e.radius, 0, Math.PI*2); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(-e.radius*1.4, 0); ctx.lineTo(e.radius*1.4, 0); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, -e.radius*1.4); ctx.lineTo(0, e.radius*1.4); ctx.stroke();
                    ctx.fillStyle = '#ff4444'; ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();
                    ctx.shadowBlur = 0; ctx.restore();
                }
            });
            ctx.shadowBlur = 0;

            // Boss rendering
            if (boss) {
                // Trail
                boss.trail.forEach(t => {
                    if (t.life > 0) {
                        ctx.globalAlpha = t.life * 0.2;
                        ctx.fillStyle = '#ff4400';
                        ctx.beginPath(); ctx.arc(t.x, t.y, boss.radius * t.life * 0.5, 0, Math.PI*2); ctx.fill();
                    }
                });
                ctx.globalAlpha = 1;
                // Rotating shield ring
                ctx.save(); ctx.translate(boss.x, boss.y); ctx.rotate(boss.shieldAngle);
                ctx.strokeStyle = boss.flashTimer > 0 ? '#ffffff' : '#ff6600';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 20; ctx.shadowColor = '#ff4400';
                for (let i = 0; i < 3; i++) {
                    const a = (Math.PI * 2 / 3) * i;
                    ctx.beginPath(); ctx.arc(0, 0, boss.radius + 8 + Math.sin(boss.pulse)*3, a, a + 1.2); ctx.stroke();
                }
                // Body ‚Äî pulsing hexagon
                const br = boss.radius + Math.sin(boss.pulse) * 2;
                ctx.fillStyle = boss.flashTimer > 0 ? '#ffffff' : '#ff2200';
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const a = (Math.PI * 2 / 6) * i - Math.PI / 6;
                    ctx[i===0?'moveTo':'lineTo'](Math.cos(a)*br, Math.sin(a)*br);
                }
                ctx.closePath(); ctx.fill();
                // Core
                ctx.fillStyle = '#ffcc00'; ctx.shadowBlur = 10; ctx.shadowColor = '#ffcc00';
                ctx.beginPath(); ctx.arc(0, 0, br * 0.35, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
                // HP bar above boss
                const hpW = 50, hpH = 5;
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(boss.x - hpW/2, boss.y - boss.radius - 18, hpW, hpH);
                ctx.fillStyle = boss.hp > boss.maxHp/2 ? '#ff8800' : '#ff2200';
                ctx.fillRect(boss.x - hpW/2, boss.y - boss.radius - 18, hpW * (boss.hp/boss.maxHp), hpH);
                ctx.strokeStyle = '#ff6600'; ctx.lineWidth = 1;
                ctx.strokeRect(boss.x - hpW/2, boss.y - boss.radius - 18, hpW, hpH);
            }

            // Power-ups
            powerups.forEach(p => {
                const s = Math.sin(p.pulse) * 3;
                ctx.globalAlpha = p.life < 3 ? 0.3 + Math.sin(gameTime*10)*0.3 : 0.9;
                ctx.shadowBlur = 12; ctx.shadowColor = p.color;
                ctx.strokeStyle = p.color; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.radius + s, 0, Math.PI*2); ctx.stroke();
                ctx.font = '16px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.fillText(p.symbol, p.x, p.y);
                ctx.shadowBlur = 0;
            });
            ctx.globalAlpha = 1;

            // Score orbs
            scoreOrbs.forEach(o => {
                const glow = 0.5 + Math.sin(o.pulse) * 0.3;
                ctx.globalAlpha = Math.min(1, o.life) * glow;
                ctx.fillStyle = '#ffdd00';
                ctx.shadowBlur = 10; ctx.shadowColor = '#ffdd00';
                ctx.beginPath(); ctx.arc(o.x, o.y, o.radius + Math.sin(o.pulse) * 1.5, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(o.x, o.y, o.radius * 0.4, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
            });
            ctx.globalAlpha = 1;

            // Dash cooldown indicator (ring around player)
            if (dash.cooldown > 0) {
                const pct = 1 - dash.cooldown / dash.cooldownTime;
                ctx.strokeStyle = 'rgba(0,255,136,0.3)'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(player.x, player.y, player.radius + 18, -Math.PI/2, -Math.PI/2 + Math.PI*2*pct); ctx.stroke();
            }

            // Combo timer bar ‚Äî drains urgently below player
            if (comboCount > 0 && comboTimer > 0) {
                const barW = 40 + comboCount * 4, barH = 3;
                const barX = player.x - barW/2, barY = player.y + player.radius + 22;
                const pct = comboTimer / 2;
                const barColor = pct > 0.5 ? '#00ffff' : pct > 0.25 ? '#ffaa00' : '#ff0044';
                ctx.globalAlpha = 0.7;
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(barX, barY, barW, barH);
                ctx.fillStyle = barColor;
                ctx.shadowBlur = 6; ctx.shadowColor = barColor;
                ctx.fillRect(barX, barY, barW * pct, barH);
                ctx.shadowBlur = 0; ctx.globalAlpha = 1;
            }

            // Combo streak ring ‚Äî grows and glows with combo count
            if (comboCount > 1 && comboTimer > 0) {
                const comboRing = player.radius + 24 + comboCount * 2;
                const comboAlpha = Math.min(0.6, 0.15 + comboCount * 0.05) * (comboTimer / 2);
                const hue = comboCount > 5 ? `hsl(${60 - comboCount * 3}, 100%, 60%)` : '#00ffff';
                ctx.strokeStyle = hue;
                ctx.lineWidth = 1 + comboCount * 0.3;
                ctx.globalAlpha = comboAlpha;
                ctx.shadowBlur = 10 + comboCount * 2; ctx.shadowColor = hue;
                ctx.beginPath(); ctx.arc(player.x, player.y, comboRing, 0, Math.PI*2); ctx.stroke();
                // Combo text above player
                if (comboCount >= 3) {
                    ctx.font = `bold ${14 + comboCount}px Courier New`; ctx.textAlign = 'center';
                    ctx.fillStyle = hue;
                    ctx.fillText(`x${comboCount}`, player.x, player.y - comboRing - 8);
                }
                ctx.globalAlpha = 1; ctx.shadowBlur = 0;
            }
        }

        // Particles
        particles.forEach(p => {
            ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
            if (p.text) {
                ctx.font = 'bold 16px Courier New'; ctx.textAlign = 'center';
                ctx.shadowBlur = 8; ctx.shadowColor = p.color;
                ctx.fillText(p.text, p.x, p.y); ctx.shadowBlur = 0;
            } else {
                ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
            }
        });
        ctx.globalAlpha = 1;

        // Floating texts
        floatingTexts.forEach(ft => {
            const alpha = Math.min(1, ft.duration / (ft.maxDuration * 0.3));
            ctx.globalAlpha = alpha;
            ctx.font = `bold ${ft.size}px Courier New`;
            ctx.textAlign = 'center';
            ctx.fillStyle = ft.color;
            ctx.shadowBlur = 10; ctx.shadowColor = ft.color;
            ctx.fillText(ft.text, ft.x, ft.y);
            ctx.shadowBlur = 0;
        });
        ctx.globalAlpha = 1;

        // Screen flash
        if (flashAlpha > 0) {
            ctx.fillStyle = flashColor || '#fff'; ctx.globalAlpha = flashAlpha;
            ctx.fillRect(0, 0, WIDTH, HEIGHT); ctx.globalAlpha = 1; flashAlpha -= 0.015;
        }

        // Slow-mo tint
        if (activePowerups.slowmo > 0) {
            ctx.fillStyle = '#ff00ff'; ctx.globalAlpha = 0.06;
            ctx.fillRect(0, 0, WIDTH, HEIGHT); ctx.globalAlpha = 1;
        }

        // Bullet time tint ‚Äî white-blue pulse for near-death moments
        if (bulletTime > 0) {
            const btIntensity = bulletTime / bulletTimeDuration;
            ctx.fillStyle = '#aaddff'; ctx.globalAlpha = btIntensity * 0.12;
            ctx.fillRect(0, 0, WIDTH, HEIGHT); ctx.globalAlpha = 1;
            // Radial lines from player for dramatic effect
            if (gameState === 'playing') {
                ctx.globalAlpha = btIntensity * 0.3;
                ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1;
                for (let i = 0; i < 12; i++) {
                    const a = (Math.PI*2/12)*i + gameTime;
                    ctx.beginPath();
                    ctx.moveTo(player.x + Math.cos(a)*30, player.y + Math.sin(a)*30);
                    ctx.lineTo(player.x + Math.cos(a)*80, player.y + Math.sin(a)*80);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }
        }

        // Edge warnings
        if (isActive) {
            edgeWarnings.forEach(w => {
                // Clamp to screen edge
                let wx = Math.max(30, Math.min(WIDTH - 30, w.x));
                let wy = Math.max(30, Math.min(HEIGHT - 30, w.y));
                ctx.globalAlpha = w.life * 0.8;
                ctx.fillStyle = w.color;
                ctx.shadowBlur = 15; ctx.shadowColor = w.color;
                // Draw warning triangle
                ctx.save(); ctx.translate(wx, wy);
                const a = Math.atan2(HEIGHT/2 - wy, WIDTH/2 - wx);
                ctx.rotate(a);
                ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-6, -7); ctx.lineTo(-6, 7); ctx.closePath(); ctx.fill();
                ctx.restore();
                ctx.shadowBlur = 0;
            });
            ctx.globalAlpha = 1;

            // Danger border ‚Äî red glow intensifies with enemy count (cached gradients)
            if (enemies.length > 3) {
                buildDangerGradients();
                const intensity = Math.min(0.4, (enemies.length - 3) * 0.03) * (0.6 + Math.sin(dangerPulse) * 0.4);
                ctx.globalAlpha = intensity;
                ctx.fillStyle = cachedDanger.left; ctx.fillRect(0, 0, 40, HEIGHT);
                ctx.fillStyle = cachedDanger.right; ctx.fillRect(WIDTH-40, 0, 40, HEIGHT);
                ctx.fillStyle = cachedDanger.top; ctx.fillRect(0, 0, WIDTH, 40);
                ctx.fillStyle = cachedDanger.bottom; ctx.fillRect(0, HEIGHT-40, WIDTH, 40);
                ctx.globalAlpha = 1;
            }

            // Vignette (cached)
            if (!cachedVignette || vignetteW !== WIDTH || vignetteH !== HEIGHT) {
                cachedVignette = ctx.createRadialGradient(WIDTH/2, HEIGHT/2, HEIGHT*0.3, WIDTH/2, HEIGHT/2, HEIGHT*0.8);
                cachedVignette.addColorStop(0, 'transparent');
                cachedVignette.addColorStop(1, 'rgba(0,0,0,0.5)');
                vignetteW = WIDTH; vignetteH = HEIGHT;
            }
            ctx.fillStyle = cachedVignette;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
        }

        // Score multiplier bar (bottom-right, vertical)
        if (scoreMult > 1.05 && gameState === 'playing') {
            ctx.save();
            const barX = WIDTH - 30, barY = HEIGHT * 0.3, barH = HEIGHT * 0.4, barW = 8;
            const fillH = barH * Math.min(1, (scoreMult - 1) / (MULT_MAX - 1));
            const mC = scoreMult >= 4 ? '#ff00ff' : scoreMult >= 3 ? '#ffaa00' : scoreMult >= 2 ? '#00ffff' : '#00ff88';
            // Track bg
            ctx.globalAlpha = 0.2; ctx.fillStyle = '#ffffff'; ctx.fillRect(barX - barW/2, barY, barW, barH);
            // Fill
            ctx.globalAlpha = 0.8 + scoreMultPulse * 0.2;
            ctx.fillStyle = mC; ctx.shadowBlur = 12 + scoreMultPulse * 20; ctx.shadowColor = mC;
            ctx.fillRect(barX - barW/2, barY + barH - fillH, barW, fillH);
            // Label
            ctx.shadowBlur = 8; ctx.font = 'bold 14px Courier New'; ctx.textAlign = 'center';
            ctx.fillStyle = mC; ctx.fillText('x' + scoreMult.toFixed(1), barX, barY - 8);
            ctx.restore();
        }

        // Edge warning arrows for off-screen enemies
        if (gameState === 'playing') {
            const margin = 40;
            enemies.forEach(e => {
                if (e.x >= margin && e.x <= WIDTH - margin && e.y >= margin && e.y <= HEIGHT - margin) return;
                const dx = e.x - player.x, dy = e.y - player.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > WIDTH * 0.8) return; // too far, don't warn
                const angle = Math.atan2(dy, dx);
                const arrowX = Math.max(20, Math.min(WIDTH - 20, e.x < 0 ? 15 : e.x > WIDTH ? WIDTH - 15 : e.x));
                const arrowY = Math.max(20, Math.min(HEIGHT - 20, e.y < 0 ? 15 : e.y > HEIGHT ? HEIGHT - 15 : e.y));
                ctx.save();
                ctx.translate(arrowX, arrowY); ctx.rotate(angle);
                ctx.globalAlpha = 0.5 + Math.sin(Date.now() * 0.008) * 0.3;
                ctx.fillStyle = '#ff4444'; ctx.shadowBlur = 8; ctx.shadowColor = '#ff4444';
                ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-6, -6); ctx.lineTo(-6, 6); ctx.closePath(); ctx.fill();
                ctx.restore();
            });
        }

        // Expanding rings
        rings.forEach(r => {
            ctx.globalAlpha = r.life * 0.7;
            ctx.strokeStyle = r.color;
            ctx.lineWidth = r.width * r.life;
            ctx.shadowBlur = 15; ctx.shadowColor = r.color;
            ctx.beginPath(); ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2); ctx.stroke();
            ctx.shadowBlur = 0;
        });
        ctx.globalAlpha = 1;

        // Wave announcement with enemy preview hint
        if (waveAnnounceTimer > 0 && gameState === 'playing') {
            ctx.save(); ctx.globalAlpha = Math.min(1, waveAnnounceTimer);
            const isPerfect = waveAnnounce.includes('PERFECT');
            const announceColor = isPerfect ? '#ffdd00' : '#00ff88';
            ctx.font = `bold ${isPerfect ? 48 : 64}px Courier New`; ctx.textAlign = 'center';
            ctx.fillStyle = announceColor; ctx.shadowBlur = 30; ctx.shadowColor = announceColor;
            ctx.fillText(waveAnnounce, WIDTH/2, HEIGHT/2);
            // Wave enemy hint
            const tier = getDifficultyTier(wave);
            if (waveAnnounce.startsWith('WAVE') && wave > 1) {
                ctx.font = '16px Courier New'; ctx.fillStyle = tier.color; ctx.globalAlpha *= 0.7;
                const hint = wave >= 5 ? '‚ö† Snipers active' : wave >= 3 ? '‚ö† Burst enemies incoming' : 'Stay sharp!';
                ctx.fillText(hint, WIDTH/2, HEIGHT/2 + 35);
            }
            ctx.restore();
        }

        // Wave break stats + countdown bar
        if (waveBreak && waveBreakStats && gameState === 'playing') {
            ctx.save();
            const breakAlpha = Math.min(1, waveBreakTimer * 3); // fade in
            ctx.globalAlpha = breakAlpha * 0.9;
            ctx.font = '18px Courier New'; ctx.textAlign = 'center';
            const statColor = waveBreakStats.perfect ? '#ffdd00' : '#88ffcc';
            ctx.fillStyle = statColor; ctx.shadowBlur = 10; ctx.shadowColor = waveBreakStats.perfect ? '#ffdd00' : '#00ff88';
            const perfText = waveBreakStats.perfect ? '  ‚òÖ PERFECT' : '';
            ctx.fillText(`Kills: ${waveBreakStats.kills}  |  Grazes: ${waveBreakStats.grazes}${perfText}`, WIDTH/2, HEIGHT/2 + 40);
            // Countdown bar
            const barW = 200, barH = 4;
            const pct = waveBreakTimer / waveBreakDuration;
            ctx.globalAlpha = breakAlpha * 0.6;
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(WIDTH/2 - barW/2, HEIGHT/2 + 55, barW, barH);
            ctx.fillStyle = '#00ff88';
            ctx.fillRect(WIDTH/2 - barW/2, HEIGHT/2 + 55, barW * pct, barH);
            ctx.restore();
        }

        // Kill streak announcement
        if (killStreakAnnounceTimer > 0 && gameState === 'playing') {
            ctx.save(); ctx.globalAlpha = Math.min(1, killStreakAnnounceTimer);
            const scale = 1 + (1 - Math.min(1, killStreakAnnounceTimer)) * 0.3;
            ctx.font = `bold ${Math.floor(36 * scale)}px Courier New`; ctx.textAlign = 'center';
            ctx.fillStyle = '#ff8800'; ctx.shadowBlur = 20; ctx.shadowColor = '#ff8800';
            ctx.fillText(killStreakAnnounce, WIDTH/2, HEIGHT/2 + 60); ctx.restore();
        }

        // Combo graze announcement (fighting game style)
        if (comboAnnounceTimer > 0 && gameState === 'playing') {
            ctx.save();
            ctx.globalAlpha = Math.min(1, comboAnnounceTimer * 1.5);
            const cSize = Math.floor(42 * comboAnnounceScale);
            ctx.font = `bold ${cSize}px Courier New`; ctx.textAlign = 'center';
            ctx.fillStyle = comboAnnounceColor;
            ctx.shadowBlur = 25; ctx.shadowColor = comboAnnounceColor;
            ctx.fillText(comboAnnounce, WIDTH/2, HEIGHT * 0.3);
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        // Wave progress bar ‚Äî thin bar at top of screen
        if (isActive && !waveBreak) {
            const barY = 2, barH = 3;
            const pct = Math.min(1, waveTimer / waveDuration);
            const tier = getDifficultyTier(wave);
            // Background track
            ctx.fillStyle = 'rgba(255,255,255,0.06)';
            ctx.fillRect(0, barY, WIDTH, barH);
            // Progress fill with tier color
            ctx.fillStyle = tier.color;
            ctx.globalAlpha = 0.5 + Math.sin(gameTime * 3) * 0.1;
            ctx.fillRect(0, barY, WIDTH * pct, barH);
            // Glow at leading edge
            if (pct > 0.01) {
                ctx.shadowBlur = 8; ctx.shadowColor = tier.color;
                ctx.fillRect(WIDTH * pct - 4, barY, 4, barH);
                ctx.shadowBlur = 0;
            }
            ctx.globalAlpha = 1;
        }

        // CRT scanline overlay (cached offscreen canvas)
        if (isActive && settings.crt) {
            buildScanlines();
            ctx.drawImage(cachedScanlines, 0, 0);
        }

        if (shakeAmount > 0 && settings.shake) ctx.restore();
    }

    init();
    </script>
</body>
</html>
