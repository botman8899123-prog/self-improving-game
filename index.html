<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NEON SURVIVE ‚Äî Self-Improving Game</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéÆ</text></svg>">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0f;
            color: #00ff88;
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none; user-select: none;
        }
        #gameCanvas { display: block; background: #000; cursor: none; touch-action: none; }
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .hud { position: absolute; top: 20px; left: 20px; font-size: 18px; text-shadow: 0 0 10px #00ff88; pointer-events: none; }
        .hud-right { position: absolute; top: 20px; right: 20px; text-align: right; font-size: 14px; opacity: 0.7; }
        .hud-bottom { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 13px; opacity: 0.6; text-align: center; pointer-events: none; }
        #menu {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: all;
        }
        #menu.hidden { display: none; }
        .title {
            font-size: 72px; font-weight: bold;
            text-shadow: 0 0 20px #00ff88, 0 0 40px #00ff88;
            margin-bottom: 20px; animation: pulse 2s infinite;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .subtitle { font-size: 18px; opacity: 0.8; margin-bottom: 40px; }
        .high-score { font-size: 24px; margin-bottom: 30px; }
        .start-btn {
            padding: 15px 40px; font-size: 24px; font-family: 'Courier New', monospace;
            background: transparent; color: #00ff88; border: 2px solid #00ff88;
            cursor: pointer; transition: all 0.3s; text-shadow: 0 0 10px #00ff88;
            pointer-events: all;
        }
        .start-btn:hover { background: #00ff88; color: #000; box-shadow: 0 0 20px #00ff88; }
        .start-btn { touch-action: manipulation; }
        .controls { margin-top: 30px; font-size: 14px; opacity: 0.6; text-align: center; }
        #gameOver {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: all;
        }
        #gameOver.show { display: flex; }
        .game-over-title { font-size: 64px; color: #ff0044; text-shadow: 0 0 20px #ff0044; margin-bottom: 30px; }
        .final-score { font-size: 32px; margin-bottom: 40px; text-align: center; line-height: 1.6; }
        .info-section { max-width: 800px; margin: 40px auto; padding: 20px; background: rgba(0,255,136,0.05); border: 1px solid #00ff88; }
        .info-section h2 { margin-bottom: 15px; text-shadow: 0 0 10px #00ff88; }
        .info-section p { line-height: 1.6; opacity: 0.8; }
        .footer { text-align: center; padding: 20px; opacity: 0.5; font-size: 12px; }
        #pauseOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100; pointer-events: all;
        }
        #pauseOverlay.show { display: flex; }
        .pause-title { font-size: 64px; color: #00ff88; text-shadow: 0 0 30px #00ff88; margin-bottom: 20px; }
        .pause-hint { font-size: 16px; opacity: 0.6; margin-top: 20px; }
        #pauseBtn {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            font-family: 'Courier New', monospace; font-size: 18px;
            background: transparent; color: #00ff88; border: 1px solid rgba(0,255,136,0.3);
            padding: 5px 15px; cursor: pointer; z-index: 50; display: none; opacity: 0.5;
            transition: opacity 0.2s;
        }
        #pauseBtn:hover { opacity: 1; }
        @media (max-width: 768px) {
            .title { font-size: 42px; }
            .game-over-title { font-size: 42px; }
            .hud { font-size: 14px; top: 10px; left: 10px; }
            .hud-right { font-size: 12px; top: 10px; right: 10px; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="overlay">
        <div class="hud"><div id="scoreDisplay">TIME: 0.0s | GRAZE: 0</div></div>
        <div class="hud-right"><div>Iteration #11</div><div>Grade: 78/100</div></div>
        <div class="hud-bottom" id="powerupHud"></div>
    </div>
    <div id="menu">
        <div class="title">NEON SURVIVE</div>
        <div class="subtitle">Self-Improving Game v11</div>
        <div class="high-score" id="highScoreDisplay">HIGH SCORE: 0</div>
        <button class="start-btn" id="startBtn">START</button>
        <div class="controls">
            MOUSE / WASD / ARROW KEYS / TOUCH<br>
            SPACE / DOUBLE-TAP to DASH<br>
            Dodge enemies. Graze for bonus points. Collect power-ups. Survive.
        </div>
    </div>
    <button id="pauseBtn" onclick="togglePause()">‚ùö‚ùö PAUSE</button>
    <div id="pauseOverlay">
        <div class="pause-title">PAUSED</div>
        <button class="start-btn" onclick="togglePause()">RESUME</button>
        <div class="pause-hint">Press P or ESC to resume</div>
    </div>
    <div id="gameOver">
        <div class="game-over-title">GAME OVER</div>
        <div class="final-score" id="finalScore">SCORE: 0</div>
        <button class="start-btn" id="restartBtn">PLAY AGAIN</button>
    </div>
    <div class="info-section">
        <h2>About This Game</h2>
        <p>This is a <strong>self-improving autonomous game</strong>. Every 7 minutes, an AI agent evaluates the current version, grades it, and automatically generates improvements. The game evolves itself over time.</p>
        <p style="margin-top:10px;">You are playing <strong>Iteration #11</strong>. Check back regularly to see how it transforms itself.</p>
        <p style="margin-top:10px;"><a href="https://game.theselfimprovingpage.com" target="_blank" style="color:#00ffff;">üï∞Ô∏è Explore the Time Machine</a> ‚Äî browse every version and see the evolution history.</p>
    </div>
    <div class="footer">
        Iteration #11 | Grade: 78/100 | Last Updated: <span id="timestamp"></span>
        <br><a href="https://game.theselfimprovingpage.com" target="_blank" style="color:#00ff88;opacity:0.7;text-decoration:underline;">üï∞Ô∏è Time Machine ‚Äî See how this game evolved</a>
    </div>
    <script>
    // ============================================
    // NEON SURVIVE ‚Äî Iteration 10 (Visual Depth + Juice)
    // ============================================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let WIDTH, HEIGHT;
    let gameState = 'menu';
    let paused = false;
    let killCount = 0;
    let score = 0, grazeCount = 0, gameTime = 0, difficulty = 1;
    let highScore = localStorage.getItem('neonSurviveHighScore') || 0;
    let newHighScore = false;

    // Edge warnings
    let edgeWarnings = [];

    // Ambient beat
    let beatInterval = null, beatOsc = null, beatGain = null;

    // Cached vignette
    let cachedVignette = null, vignetteW = 0, vignetteH = 0;

    // Danger border
    let dangerPulse = 0;

    // Mobile detection
    const isMobile = /Android|iPhone|iPad|iPod|webOS/i.test(navigator.userAgent) || window.innerWidth < 768;

    // Player
    let player = { x: 0, y: 0, vx: 0, vy: 0, radius: 12, trail: [] };

    // Dash
    let dash = { active: false, timer: 0, cooldown: 0, duration: 0.15, cooldownTime: 1.2, speed: 1200, invincible: false };
    let lastTapTime = 0;

    // Entities
    let enemies = [], particles = [], stars = [], powerups = [];

    // Input
    let keys = {}, mouse = { x: 0, y: 0, active: false }, touch = { x: 0, y: 0, active: false };

    // Timing
    let lastSpawn = 0, spawnInterval = 1000, lastPowerupSpawn = 0;

    // Effects
    let shakeAmount = 0, flashColor = null, flashAlpha = 0;
    // Kill streak
    let killStreak = 0, killStreakTimer = 0, killStreakAnnounce = '', killStreakAnnounceTimer = 0;
    // Ring explosions (wave clear, death)
    let rings = [];
    // Death slowmo
    let deathSlowmo = 0, deathSlowmoDuration = 1.2;

    // Wave system
    let wave = 1, waveTimer = 0, waveDuration = 8, waveBreak = false, waveBreakTimer = 0, waveBreakDuration = 2;
    let waveAnnounce = '', waveAnnounceTimer = 0;

    // Combo system
    let comboCount = 0, comboTimer = 0, comboBest = 0;

    // Active power-ups
    let activePowerups = { shield: 0, slowmo: 0, magnet: 0 };

    // Audio
    let audioCtx = null;
    function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

    function playSound(freq, duration, type = 'sine', volume = 0.1) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.value = volume;
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + duration);
    }

    // Ambient beat system
    let beatBPM = 80, beatPlaying = false;
    function startBeat() {
        if (!audioCtx || beatPlaying) return;
        beatPlaying = true;
        function scheduleBeat() {
            if (!beatPlaying) return;
            const bpm = beatBPM + (wave - 1) * 8;
            const interval = 60000 / bpm;
            // Kick
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(80, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.12);
            gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.2);
            beatInterval = setTimeout(scheduleBeat, interval);
        }
        scheduleBeat();
    }
    function stopBeat() { beatPlaying = false; if (beatInterval) clearTimeout(beatInterval); }

    // Dash sound ‚Äî whoosh
    function playDashSound() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(300, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.15);
        gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.2);
    }

    // Power-up pickup sound
    function playPowerupSound() {
        playSound(800, 0.1, 'sine', 0.15);
        setTimeout(() => playSound(1200, 0.1, 'sine', 0.12), 60);
        setTimeout(() => playSound(1600, 0.15, 'sine', 0.1), 120);
    }

    // Dramatic death explosion sound
    function playDeathSound() {
        if (!audioCtx) return;
        // Low rumble
        const osc1 = audioCtx.createOscillator();
        const g1 = audioCtx.createGain();
        osc1.type = 'sawtooth';
        osc1.frequency.setValueAtTime(80, audioCtx.currentTime);
        osc1.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.8);
        g1.gain.setValueAtTime(0.2, audioCtx.currentTime);
        g1.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);
        osc1.connect(g1); g1.connect(audioCtx.destination);
        osc1.start(); osc1.stop(audioCtx.currentTime + 0.9);
        // Noise burst
        const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/data.length, 2);
        const noise = audioCtx.createBufferSource();
        const g2 = audioCtx.createGain();
        noise.buffer = buf;
        g2.gain.setValueAtTime(0.15, audioCtx.currentTime);
        g2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
        noise.connect(g2); g2.connect(audioCtx.destination);
        noise.start();
        // Descending tone
        setTimeout(() => { playSound(400, 0.4, 'sine', 0.1); }, 200);
        setTimeout(() => { playSound(200, 0.5, 'sine', 0.08); }, 400);
    }

    // Graze streak sound ‚Äî rising pitch with combo
    function playGrazeStreakSound(combo) {
        if (!audioCtx) return;
        const baseFreq = 600 + Math.min(combo, 15) * 80;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(baseFreq, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.3, audioCtx.currentTime + 0.08);
        g.gain.setValueAtTime(0.06 + Math.min(combo, 10) * 0.01, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.2);
    }

    // Wave clear fanfare
    function playWaveClearSound() {
        if (!audioCtx) return;
        const notes = [523, 659, 784, 1047]; // C5 E5 G5 C6
        notes.forEach((f, i) => {
            setTimeout(() => playSound(f, 0.25, 'sine', 0.1), i * 80);
        });
    }

    // Bass drone ‚Äî sustained tension note that increases with wave
    let bassDrone = null, bassDroneGain = null;
    function startBassDrone() {
        if (!audioCtx || bassDrone) return;
        bassDrone = audioCtx.createOscillator();
        bassDroneGain = audioCtx.createGain();
        bassDrone.type = 'sine';
        bassDrone.frequency.value = 40;
        bassDroneGain.gain.value = 0.03;
        bassDrone.connect(bassDroneGain);
        bassDroneGain.connect(audioCtx.destination);
        bassDrone.start();
    }
    function updateBassDrone(wave) {
        if (!bassDrone || !bassDroneGain) return;
        bassDrone.frequency.value = 35 + wave * 5;
        bassDroneGain.gain.value = Math.min(0.06, 0.02 + wave * 0.005);
    }
    function stopBassDrone() {
        if (bassDrone) { try { bassDrone.stop(); } catch(e){} bassDrone = null; bassDroneGain = null; }
    }

    // ============================================
    // INIT
    // ============================================
    function resizeCanvas() {
        WIDTH = window.innerWidth; HEIGHT = window.innerHeight;
        canvas.width = WIDTH; canvas.height = HEIGHT;
    }

    function init() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        // 3-layer parallax starfield
        for (let i = 0; i < 60; i++) {
            stars.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, size: 0.5 + Math.random(), speed: 0.05 + Math.random() * 0.15, layer: 0 });
        }
        for (let i = 0; i < 40; i++) {
            stars.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, size: 1 + Math.random(), speed: 0.2 + Math.random() * 0.3, layer: 1 });
        }
        for (let i = 0; i < 15; i++) {
            stars.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, size: 2 + Math.random() * 1.5, speed: 0.5 + Math.random() * 0.5, layer: 2 });
        }
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);
        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ' && gameState === 'playing' && !paused) { e.preventDefault(); tryDash(); }
            if ((e.key === 'p' || e.key === 'Escape') && gameState === 'playing') { e.preventDefault(); togglePause(); }
        });
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        canvas.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; mouse.active = true; });
        canvas.addEventListener('touchstart', e => {
            handleTouch(e);
            const now = Date.now();
            if (now - lastTapTime < 300) tryDash();
            lastTapTime = now;
        });
        canvas.addEventListener('touchmove', handleTouch);
        canvas.addEventListener('touchend', () => touch.active = false);
        // Prevent scroll during gameplay
        document.body.addEventListener('touchmove', e => { if (gameState === 'playing') e.preventDefault(); }, { passive: false });
        document.getElementById('highScoreDisplay').textContent = `HIGH SCORE: ${Math.floor(highScore)}`;
        document.getElementById('timestamp').textContent = new Date().toLocaleString();
        requestAnimationFrame(gameLoop);
    }

    function handleTouch(e) {
        e.preventDefault();
        touch.x = e.touches[0].clientX;
        touch.y = e.touches[0].clientY;
        touch.active = true;
    }

    // ============================================
    // DASH
    // ============================================
    function tryDash() {
        if (dash.cooldown > 0 || dash.active) return;
        dash.active = true;
        dash.timer = dash.duration;
        dash.cooldown = dash.cooldownTime;
        dash.invincible = true;
        playDashSound();
        shakeAmount = 5;
        flashColor = '#00ff88'; flashAlpha = 0.15;
        // Dash trail burst
        for (let i = 0; i < 8; i++) {
            const a = Math.random() * Math.PI * 2;
            particles.push({
                x: player.x, y: player.y,
                vx: Math.cos(a) * 200, vy: Math.sin(a) * 200,
                life: 0.4, decay: 0.025, size: 3, color: '#00ff88'
            });
        }
    }

    // ============================================
    // GAME CONTROL
    // ============================================
    function togglePause() {
        if (gameState !== 'playing') return;
        paused = !paused;
        document.getElementById('pauseOverlay').classList.toggle('show', paused);
        if (paused) { stopBeat(); if (audioCtx) audioCtx.suspend(); }
        else { startBeat(); if (audioCtx) audioCtx.resume(); }
    }

    function startGame() {
        initAudio(); startBeat(); startBassDrone();
        gameState = 'playing'; score = 0; grazeCount = 0; gameTime = 0; difficulty = 1;
        player.x = WIDTH / 2; player.y = HEIGHT / 2; player.vx = 0; player.vy = 0; player.trail = [];
        enemies = []; particles = []; powerups = [];
        lastSpawn = 0; lastPowerupSpawn = 0;
        wave = 1; waveTimer = 0; waveBreak = false; waveBreakTimer = 0;
        comboCount = 0; comboTimer = 0; comboBest = 0; killCount = 0; killStreak = 0; killStreakTimer = 0;
        paused = false; newHighScore = false; document.getElementById('pauseOverlay').classList.remove('show');
        document.getElementById('pauseBtn').style.display = 'block';
        dash.active = false; dash.timer = 0; dash.cooldown = 0; dash.invincible = false;
        activePowerups = { shield: 0, slowmo: 0, magnet: 0 };
        waveAnnounce = 'WAVE 1'; waveAnnounceTimer = 1.5;
        document.getElementById('menu').classList.add('hidden');
        document.getElementById('gameOver').classList.remove('show');
        document.body.style.overflow = 'hidden';
    }

    function endGame() {
        gameState = 'dying'; deathSlowmo = deathSlowmoDuration;
        shakeAmount = 25;
        // Death ring
        rings.push({ x: player.x, y: player.y, radius: 5, maxRadius: Math.max(WIDTH, HEIGHT) * 0.8, speed: 300, life: 1, color: '#ff0044', width: 4 });
        // Initial burst
        for (let i = 0; i < 30; i++) {
            const a = Math.random() * Math.PI * 2, sp = Math.random() * 300 + 50;
            particles.push({ x: player.x, y: player.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 1.5, decay: 0.012, size: Math.random()*5+2, color: Math.random()>0.5?'#ff0044':'#ff8800' });
        }
        playDeathSound();
    }

    function finalizeDeath() {
        gameState = 'gameover'; stopBeat(); stopBassDrone();
        document.getElementById('pauseBtn').style.display = 'none';
        document.body.style.overflow = '';
        // Final explosion burst
        for (let i = 0; i < 40; i++) {
            const a = Math.random() * Math.PI * 2, sp = Math.random() * 200 + 80;
            particles.push({ x: player.x, y: player.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 1, decay: 0.02, size: Math.random()*4+1, color: Math.random()>0.3?'#ff0044':'#ffffff' });
        }
        flashColor = '#ff0044'; flashAlpha = 0.6;
        if (score > highScore) { highScore = score; localStorage.setItem('neonSurviveHighScore', highScore); }
        const survivalTime = gameTime.toFixed(1);
        const gradeEmoji = wave >= 5 ? 'üî•' : wave >= 3 ? '‚ö°' : 'üíÄ';
        document.getElementById('finalScore').innerHTML = `SCORE: ${Math.floor(score)}<br><span style="font-size:20px;opacity:0.7">${gradeEmoji} Wave ${wave} | ${survivalTime}s | ${grazeCount} grazes | ${killCount} kills | Best combo: x${comboBest}</span>`;
        setTimeout(() => document.getElementById('gameOver').classList.add('show'), 800);
    }

    // ============================================
    // POWER-UPS
    // ============================================
    function spawnPowerup() {
        const types = ['shield', 'slowmo', 'magnet'];
        const colors = { shield: '#00aaff', slowmo: '#ff00ff', magnet: '#ffff00' };
        const symbols = { shield: 'üõ°', slowmo: '‚è≥', magnet: 'üß≤' };
        const type = types[Math.floor(Math.random() * types.length)];
        powerups.push({
            x: Math.random() * (WIDTH - 100) + 50,
            y: Math.random() * (HEIGHT - 100) + 50,
            type, color: colors[type], symbol: symbols[type],
            radius: 15, life: 10, pulse: 0
        });
    }

    function collectPowerup(p) {
        activePowerups[p.type] = p.type === 'shield' ? 5 : p.type === 'slowmo' ? 4 : 6;
        playPowerupSound();
        flashColor = p.color; flashAlpha = 0.2;
        // Pickup particles
        for (let i = 0; i < 12; i++) {
            const a = Math.random() * Math.PI * 2;
            particles.push({ x: p.x, y: p.y, vx: Math.cos(a)*150, vy: Math.sin(a)*150, life: 0.6, decay: 0.03, size: 2, color: p.color });
        }
        particles.push({ x: p.x, y: p.y - 15, vx: 0, vy: -60, life: 1, decay: 0.02, size: 0, color: p.color, text: p.type.toUpperCase() });
    }

    // ============================================
    // GAME LOOP
    // ============================================
    let lastTime = 0;
    function gameLoop(timestamp) {
        requestAnimationFrame(gameLoop);
        const rawDt = lastTime ? (timestamp - lastTime) / 1000 : 1/60;
        lastTime = timestamp;
        const dt = Math.min(rawDt, 1/30); // Cap dt to prevent physics jumps

        if (gameState === 'playing' && !paused) update(dt, timestamp);
        if (gameState === 'dying') updateDying(dt);
        // Update rings always
        rings.forEach(r => { r.radius += r.speed * dt; r.life -= dt / (r.maxRadius / r.speed); });
        rings = rings.filter(r => r.life > 0 && r.radius < r.maxRadius);
        render();
    }

    function update(dt, timestamp) {
        const timeMult = activePowerups.slowmo > 0 ? 0.5 : 1;
        const eDt = dt * timeMult; // Enemy delta time (slowed)
        gameTime += dt;

        // Wave system
        waveTimer += dt;
        if (waveBreak) {
            waveBreakTimer += dt;
            if (waveBreakTimer >= waveBreakDuration) {
                waveBreak = false; waveBreakTimer = 0; waveTimer = 0; wave++;
                waveAnnounce = `WAVE ${wave}`; waveAnnounceTimer = 1.5;
                playSound(600, 0.2, 'square', 0.08);
                setTimeout(() => playSound(800, 0.2, 'square', 0.08), 100);
                updateBassDrone(wave);
            }
        } else if (waveTimer >= waveDuration) {
            waveBreak = true; waveBreakTimer = 0;
            waveAnnounce = 'CLEAR!'; waveAnnounceTimer = 1.5;
            flashColor = '#00ff88'; flashAlpha = 0.3;
            playWaveClearSound();
            // Expanding ring VFX
            rings.push({ x: player.x, y: player.y, radius: 20, maxRadius: Math.max(WIDTH, HEIGHT) * 0.6, speed: 600, life: 1, color: '#00ff88', width: 3 });
            rings.push({ x: player.x, y: player.y, radius: 10, maxRadius: Math.max(WIDTH, HEIGHT) * 0.4, speed: 450, life: 1, color: '#00ffcc', width: 2 });
            // Spawn bonus orb during wave break
            powerups.push({
                x: WIDTH/2 + (Math.random()-0.5)*200, y: HEIGHT/2 + (Math.random()-0.5)*200,
                type: 'shield', color: '#00ffcc', symbol: '‚≠ê',
                radius: 18, life: waveBreakDuration + 0.5, pulse: 0
            });
        }
        if (waveAnnounceTimer > 0) waveAnnounceTimer -= dt;

        difficulty = 1 + (wave - 1) * 0.3 + gameTime * 0.02;
        spawnInterval = waveBreak ? 99999 : Math.max(250, 900 - wave * 60);

        // Combo timer
        if (comboTimer > 0) { comboTimer -= dt; if (comboTimer <= 0) comboCount = 0; }
        // Kill streak timer
        if (killStreakTimer > 0) { killStreakTimer -= dt; if (killStreakTimer <= 0) killStreak = 0; }
        if (killStreakAnnounceTimer > 0) killStreakAnnounceTimer -= dt;

        // Dash update
        if (dash.active) { dash.timer -= dt; if (dash.timer <= 0) { dash.active = false; dash.invincible = false; } }
        if (dash.cooldown > 0) dash.cooldown -= dt;

        // Power-up timers
        for (const k in activePowerups) { if (activePowerups[k] > 0) activePowerups[k] -= dt; }

        // Score
        const comboMult = Math.max(1, comboCount);
        score = gameTime * 10 + grazeCount * 50 * comboMult;
        // New high score detection
        if (!newHighScore && score > highScore && highScore > 0) {
            newHighScore = true;
            flashColor = '#ffff00'; flashAlpha = 0.4;
            shakeAmount = 8;
            playSound(880, 0.2, 'sine', 0.12);
            setTimeout(() => playSound(1100, 0.2, 'sine', 0.1), 100);
            setTimeout(() => playSound(1320, 0.3, 'sine', 0.1), 200);
            for (let i = 0; i < 20; i++) {
                const a = Math.random() * Math.PI * 2;
                particles.push({ x: player.x, y: player.y, vx: Math.cos(a)*200, vy: Math.sin(a)*200, life: 1.2, decay: 0.015, size: 3, color: '#ffff00' });
            }
            particles.push({ x: WIDTH/2, y: HEIGHT/3, vx: 0, vy: -30, life: 2, decay: 0.012, size: 0, color: '#ffff00', text: '‚òÖ NEW HIGH SCORE ‚òÖ' });
        }
        const comboText = comboCount > 1 ? ` | COMBO: x${comboCount}` : '';
        const dashText = dash.cooldown > 0 ? ` | DASH: ${dash.cooldown.toFixed(1)}s` : ' | DASH: READY';
        document.getElementById('scoreDisplay').textContent = `WAVE ${wave} | TIME: ${gameTime.toFixed(1)}s | GRAZE: ${grazeCount}${comboText}${dashText}`;

        // Power-up HUD
        const pTexts = [];
        if (activePowerups.shield > 0) pTexts.push(`üõ° ${activePowerups.shield.toFixed(1)}s`);
        if (activePowerups.slowmo > 0) pTexts.push(`‚è≥ ${activePowerups.slowmo.toFixed(1)}s`);
        if (activePowerups.magnet > 0) pTexts.push(`üß≤ ${activePowerups.magnet.toFixed(1)}s`);
        document.getElementById('powerupHud').textContent = pTexts.join('  ');

        updatePlayer(dt);

        // Spawn enemies
        if (timestamp - lastSpawn > spawnInterval) { spawnEnemy(); lastSpawn = timestamp; }

        // Spawn power-ups (every 8-12 seconds)
        if (timestamp - lastPowerupSpawn > 8000 + Math.random() * 4000) {
            if (powerups.length < 3) spawnPowerup();
            lastPowerupSpawn = timestamp;
        }

        updateEnemies(eDt);
        updatePowerups(dt);
        updateParticles(dt);
        updateStars(dt);
        checkCollisions();

        // Edge warnings
        edgeWarnings.forEach(w => w.life -= dt * 2);
        edgeWarnings = edgeWarnings.filter(w => w.life > 0);

        // Danger border pulse ‚Äî intensifies with enemy count
        dangerPulse += dt * 3;

        if (shakeAmount > 0) { shakeAmount *= 0.9; if (shakeAmount < 0.1) shakeAmount = 0; }
    }

    function updateDying(dt) {
        deathSlowmo -= dt;
        const slowFactor = 0.05 + 0.15 * (1 - deathSlowmo / deathSlowmoDuration);
        // Still update particles slowly for dramatic effect
        particles.forEach(p => { p.x += p.vx * dt * slowFactor; p.y += p.vy * dt * slowFactor; p.life -= p.decay * slowFactor; });
        particles = particles.filter(p => p.life > 0);
        // Enemies slow to crawl
        enemies.forEach(e => { e.x += e.vx * dt * slowFactor; e.y += e.vy * dt * slowFactor; });
        updateStars(dt * slowFactor);
        if (shakeAmount > 0) { shakeAmount *= 0.95; if (shakeAmount < 0.1) shakeAmount = 0; }
        if (deathSlowmo <= 0) finalizeDeath();
    }

    function updatePlayer(dt) {
        const accel = 800, maxSpeed = dash.active ? dash.speed : 400, friction = 0.85;
        if (keys['w'] || keys['arrowup']) player.vy -= accel * dt;
        if (keys['s'] || keys['arrowdown']) player.vy += accel * dt;
        if (keys['a'] || keys['arrowleft']) player.vx -= accel * dt;
        if (keys['d'] || keys['arrowright']) player.vx += accel * dt;

        if (mouse.active && gameState === 'playing') {
            const dx = mouse.x - player.x, dy = mouse.y - player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 5) { player.vx += (dx/dist)*accel*dt*0.5; player.vy += (dy/dist)*accel*dt*0.5; }
        }
        if (touch.active) {
            const dx = touch.x - player.x, dy = touch.y - player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 5) { player.vx += (dx/dist)*accel*dt; player.vy += (dy/dist)*accel*dt; }
        }

        player.vx *= friction; player.vy *= friction;
        const speed = Math.sqrt(player.vx*player.vx + player.vy*player.vy);
        if (speed > maxSpeed) { player.vx = (player.vx/speed)*maxSpeed; player.vy = (player.vy/speed)*maxSpeed; }

        player.x += player.vx * dt;
        player.y += player.vy * dt;
        player.x = Math.max(player.radius, Math.min(WIDTH - player.radius, player.x));
        player.y = Math.max(player.radius, Math.min(HEIGHT - player.radius, player.y));

        player.trail.push({ x: player.x, y: player.y, life: 1 });
        if (player.trail.length > (dash.active ? 25 : 15)) player.trail.shift();
        player.trail.forEach(t => t.life -= 0.05);
    }

    function spawnEnemy() {
        const r = Math.random();
        const type = r < 0.5 ? 'basic' : r < 0.8 ? 'homing' : 'burst';
        const side = Math.floor(Math.random() * 4);
        let x, y;
        if (side === 0) { x = Math.random() * WIDTH; y = -20; }
        else if (side === 1) { x = WIDTH + 20; y = Math.random() * HEIGHT; }
        else if (side === 2) { x = Math.random() * WIDTH; y = HEIGHT + 20; }
        else { x = -20; y = Math.random() * HEIGHT; }

        const dx = player.x - x, dy = player.y - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const speed = (50 + Math.random() * 50) * difficulty;

        const colors = { basic: '#ff0044', homing: '#ffaa00', burst: '#ff00ff' };
        const radii = { basic: 8, homing: 10, burst: 12 };

        enemies.push({
            x, y, vx: (dx/dist)*speed, vy: (dy/dist)*speed,
            type, radius: radii[type], color: colors[type], grazed: false,
            burstTimer: type === 'burst' ? 2 + Math.random() : 0,
            trail: []
        });
        playSound(400, 0.05, 'sine', 0.02);
        // Edge warning
        edgeWarnings.push({ x, y, life: 0.5, color: colors[type] || '#ff0044' });
    }

    function updateEnemies(dt) {
        const toAdd = [];
        enemies.forEach(e => {
            if (e.type === 'homing') {
                const dx = player.x - e.x, dy = player.y - e.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const turnSpeed = 100 * difficulty;
                e.vx += (dx/dist)*turnSpeed*dt; e.vy += (dy/dist)*turnSpeed*dt;
                const sp = Math.sqrt(e.vx*e.vx + e.vy*e.vy);
                const ms = 200 * difficulty;
                if (sp > ms) { e.vx = (e.vx/sp)*ms; e.vy = (e.vy/sp)*ms; }
            }
            if (e.type === 'burst') {
                e.burstTimer -= dt;
                if (e.burstTimer <= 0) {
                    // Burst into 4 small projectiles
                    for (let i = 0; i < 4; i++) {
                        const a = (Math.PI * 2 / 4) * i;
                        toAdd.push({
                            x: e.x, y: e.y,
                            vx: Math.cos(a) * 150 * difficulty, vy: Math.sin(a) * 150 * difficulty,
                            type: 'basic', radius: 5, color: '#ff66ff', grazed: false, burstTimer: 0
                        });
                    }
                    // Burst visual
                    for (let i = 0; i < 8; i++) {
                        const a = Math.random() * Math.PI * 2;
                        particles.push({ x: e.x, y: e.y, vx: Math.cos(a)*120, vy: Math.sin(a)*120, life: 0.5, decay: 0.03, size: 2, color: '#ff00ff' });
                    }
                    playSound(300, 0.15, 'square', 0.08);
                    e.life = 0; // Mark for removal
                }
            }
            e.x += e.vx * dt; e.y += e.vy * dt;
            // Enemy trail
            e.trail.push({ x: e.x, y: e.y, life: 1 });
            if (e.trail.length > 8) e.trail.shift();
            e.trail.forEach(t => t.life -= 0.12);
        });
        enemies = enemies.filter(e => e.life !== 0 && e.x > -100 && e.x < WIDTH+100 && e.y > -100 && e.y < HEIGHT+100);
        enemies.push(...toAdd);
    }

    function updatePowerups(dt) {
        powerups.forEach(p => {
            p.life -= dt; p.pulse += dt * 3;
            // Magnet effect ‚Äî pull toward player
            if (activePowerups.magnet > 0) {
                const dx = player.x - p.x, dy = player.y - p.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 10 && dist < 300) {
                    p.x += (dx/dist) * 200 * dt;
                    p.y += (dy/dist) * 200 * dt;
                }
            }
        });
        powerups = powerups.filter(p => p.life > 0);
    }

    function updateParticles(dt) {
        particles.forEach(p => { p.x += p.vx*dt; p.y += p.vy*dt; p.vx *= 0.98; p.vy *= 0.98; p.life -= p.decay; });
        particles = particles.filter(p => p.life > 0);
    }

    function updateStars(dt) {
        stars.forEach(s => {
            s.y += s.speed;
            // Parallax: deeper layers react slightly to player movement
            if (gameState === 'playing' && s.layer > 0) {
                s.x -= player.vx * dt * s.layer * 0.015;
            }
            if (s.y > HEIGHT) { s.y = 0; s.x = Math.random() * WIDTH; }
            if (s.x < 0) s.x = WIDTH;
            if (s.x > WIDTH) s.x = 0;
        });
    }

    function checkCollisions() {
        // Enemy collisions
        enemies.forEach(e => {
            const dx = player.x - e.x, dy = player.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < player.radius + e.radius) {
                if (dash.invincible || activePowerups.shield > 0) {
                    // Destroy enemy ‚Äî satisfying explosion
                    e.life = 0; killCount++;
                    killStreak++; killStreakTimer = 1.5;
                    if (killStreak === 3) { killStreakAnnounce = 'TRIPLE KILL!'; killStreakAnnounceTimer = 1.2; playSound(1000, 0.15, 'square', 0.1); }
                    else if (killStreak === 5) { killStreakAnnounce = 'RAMPAGE!'; killStreakAnnounceTimer = 1.2; playSound(1200, 0.2, 'square', 0.12); }
                    else if (killStreak >= 8) { killStreakAnnounce = 'UNSTOPPABLE!'; killStreakAnnounceTimer = 1.5; playSound(1500, 0.25, 'square', 0.15); }
                    shakeAmount = 10;
                    // Ring burst
                    for (let i = 0; i < 16; i++) {
                        const a = (Math.PI * 2 / 16) * i;
                        const sp = 180 + Math.random() * 80;
                        particles.push({ x: e.x, y: e.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.7, decay: 0.02, size: 2 + Math.random()*3, color: e.color });
                    }
                    // Center flash
                    particles.push({ x: e.x, y: e.y, vx: 0, vy: 0, life: 0.4, decay: 0.04, size: e.radius * 3, color: '#fff' });
                    // Score popup
                    particles.push({ x: e.x, y: e.y - 15, vx: 0, vy: -70, life: 1, decay: 0.02, size: 0, color: '#ffff00', text: '+100' });
                    playSound(500, 0.1, 'square', 0.12);
                    setTimeout(() => playSound(700, 0.08, 'sine', 0.08), 50);
                    score += 100;
                } else {
                    endGame();
                }
            }
            // Graze
            const grazeDist = player.radius + e.radius + 25;
            if (!e.grazed && dist < grazeDist && dist > player.radius + e.radius) {
                e.grazed = true; grazeCount++; comboCount++; comboTimer = 2;
                if (comboCount > comboBest) comboBest = comboCount;
                playGrazeStreakSound(comboCount);
                flashColor = '#00ffff'; flashAlpha = 0.1 + comboCount * 0.02;
                const mx = (player.x+e.x)/2, my = (player.y+e.y)/2;
                for (let p = 0; p < 6; p++) {
                    const a = Math.random()*Math.PI*2, sp = Math.random()*120+40;
                    particles.push({ x: mx, y: my, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.6, decay: 0.025, size: Math.random()*3+1, color: comboCount>3?'#ffff00':'#00ffff' });
                }
                particles.push({ x: mx, y: my-10, vx: 0, vy: -80, life: 0.8, decay: 0.025, size: 0, color: comboCount>3?'#ffff00':'#00ffff', text: comboCount>1?`x${comboCount}`:'+50' });
            }
        });
        enemies = enemies.filter(e => e.life !== 0);

        // Power-up collisions (iterate backwards for safe splice)
        for (let i = powerups.length - 1; i >= 0; i--) {
            const p = powerups[i];
            const dx = player.x - p.x, dy = player.y - p.y;
            if (Math.sqrt(dx*dx + dy*dy) < player.radius + p.radius) {
                collectPowerup(p);
                powerups.splice(i, 1);
            }
        }
    }

    // ============================================
    // RENDERING
    // ============================================
    function render() {
        // Dynamic background ‚Äî shifts hue with wave
        const isActive = (gameState === 'playing' || gameState === 'dying') && !paused;
        if (isActive) {
            const waveHue = gameState === 'dying' ? 0 : ((wave - 1) * 30) % 360;
            const sat = gameState === 'dying' ? '60%' : '40%';
            const grad = ctx.createRadialGradient(WIDTH/2, HEIGHT/2, 0, WIDTH/2, HEIGHT/2, HEIGHT * 0.9);
            grad.addColorStop(0, `hsla(${waveHue}, ${sat}, 4%, 1)`);
            grad.addColorStop(0.5, `hsla(${waveHue + 20}, 50%, 2%, 1)`);
            grad.addColorStop(1, '#000');
            ctx.fillStyle = grad;
        } else {
            ctx.fillStyle = '#000';
        }
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        if (shakeAmount > 0) { ctx.save(); ctx.translate((Math.random()-0.5)*shakeAmount, (Math.random()-0.5)*shakeAmount); }

        // Grid
        if (isActive) {
            ctx.strokeStyle = 'rgba(0,255,136,0.05)'; ctx.lineWidth = 1;
            for (let x = 0; x < WIDTH; x += 50) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,HEIGHT); ctx.stroke(); }
            for (let y = 0; y < HEIGHT; y += 50) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(WIDTH,y); ctx.stroke(); }
        }

        // Stars (parallax layers)
        stars.forEach(s => {
            const alpha = s.layer === 0 ? 0.3 : s.layer === 1 ? 0.5 : 0.8;
            ctx.fillStyle = `rgba(255,255,255,${alpha})`;
            ctx.fillRect(s.x, s.y, s.size, s.size);
        });

        if (isActive) {
            // Player trail
            player.trail.forEach(t => {
                if (t.life > 0) {
                    ctx.globalAlpha = t.life * (dash.active ? 0.8 : 0.5);
                    ctx.fillStyle = dash.active ? '#88ffcc' : '#00ff88';
                    ctx.beginPath(); ctx.arc(t.x, t.y, player.radius * t.life * (dash.active ? 0.7 : 0.5), 0, Math.PI*2); ctx.fill();
                }
            });
            ctx.globalAlpha = 1;

            // Shield visual
            if (activePowerups.shield > 0) {
                ctx.strokeStyle = '#00aaff';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.4 + Math.sin(gameTime * 6) * 0.2;
                ctx.shadowBlur = 15; ctx.shadowColor = '#00aaff';
                ctx.beginPath(); ctx.arc(player.x, player.y, player.radius + 10, 0, Math.PI*2); ctx.stroke();
                ctx.globalAlpha = 1; ctx.shadowBlur = 0;
            }

            // Dash invincibility glow
            if (dash.invincible) {
                ctx.strokeStyle = '#88ffcc'; ctx.lineWidth = 3; ctx.globalAlpha = 0.6;
                ctx.beginPath(); ctx.arc(player.x, player.y, player.radius + 6, 0, Math.PI*2); ctx.stroke();
                ctx.globalAlpha = 1;
            }

            // Player (rotating triangle)
            ctx.save();
            ctx.translate(player.x, player.y);
            const angle = Math.atan2(player.vy, player.vx) || 0;
            ctx.rotate(angle);
            ctx.shadowBlur = 25; ctx.shadowColor = activePowerups.shield > 0 ? '#44ccff' : '#00ff88';
            ctx.fillStyle = activePowerups.shield > 0 ? '#44ccff' : '#00ff88';
            const r = player.radius;
            ctx.beginPath();
            ctx.moveTo(r * 1.3, 0);
            ctx.lineTo(-r * 0.8, -r * 0.9);
            ctx.lineTo(-r * 0.4, 0);
            ctx.lineTo(-r * 0.8, r * 0.9);
            ctx.closePath();
            ctx.fill();
            // Core glow
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(0, 0, r * 0.3, 0, Math.PI*2); ctx.fill();
            // Engine glow
            ctx.fillStyle = dash.active ? '#88ffcc' : 'rgba(0,255,136,0.5)';
            ctx.beginPath(); ctx.arc(-r * 0.5, 0, r * 0.25 + Math.random() * 2, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
            ctx.restore();

            // Enemies (trails first, then bodies)
            enemies.forEach(e => {
                // Enemy trail
                e.trail.forEach(t => {
                    if (t.life > 0) {
                        ctx.globalAlpha = t.life * 0.3;
                        ctx.fillStyle = e.color;
                        ctx.beginPath(); ctx.arc(t.x, t.y, e.radius * t.life * 0.6, 0, Math.PI*2); ctx.fill();
                    }
                });
                ctx.globalAlpha = 1;
                ctx.shadowBlur = 15; ctx.shadowColor = e.color; ctx.fillStyle = e.color;
                ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.beginPath(); ctx.arc(e.x, e.y, e.radius * 0.4, 0, Math.PI*2); ctx.fill();
                // Burst timer visual
                if (e.type === 'burst' && e.burstTimer < 1) {
                    ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5 + Math.sin(gameTime * 15) * 0.5;
                    ctx.beginPath(); ctx.arc(e.x, e.y, e.radius + 5 + Math.sin(gameTime*10)*3, 0, Math.PI*2); ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            });
            ctx.shadowBlur = 0;

            // Power-ups
            powerups.forEach(p => {
                const s = Math.sin(p.pulse) * 3;
                ctx.globalAlpha = p.life < 3 ? 0.3 + Math.sin(gameTime*10)*0.3 : 0.9;
                ctx.shadowBlur = 12; ctx.shadowColor = p.color;
                ctx.strokeStyle = p.color; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.radius + s, 0, Math.PI*2); ctx.stroke();
                ctx.font = '16px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.fillText(p.symbol, p.x, p.y);
                ctx.shadowBlur = 0;
            });
            ctx.globalAlpha = 1;

            // Dash cooldown indicator (ring around player)
            if (dash.cooldown > 0) {
                const pct = 1 - dash.cooldown / dash.cooldownTime;
                ctx.strokeStyle = 'rgba(0,255,136,0.3)'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(player.x, player.y, player.radius + 18, -Math.PI/2, -Math.PI/2 + Math.PI*2*pct); ctx.stroke();
            }

            // Combo streak ring ‚Äî grows and glows with combo count
            if (comboCount > 1 && comboTimer > 0) {
                const comboRing = player.radius + 24 + comboCount * 2;
                const comboAlpha = Math.min(0.6, 0.15 + comboCount * 0.05) * (comboTimer / 2);
                const hue = comboCount > 5 ? `hsl(${60 - comboCount * 3}, 100%, 60%)` : '#00ffff';
                ctx.strokeStyle = hue;
                ctx.lineWidth = 1 + comboCount * 0.3;
                ctx.globalAlpha = comboAlpha;
                ctx.shadowBlur = 10 + comboCount * 2; ctx.shadowColor = hue;
                ctx.beginPath(); ctx.arc(player.x, player.y, comboRing, 0, Math.PI*2); ctx.stroke();
                // Combo text above player
                if (comboCount >= 3) {
                    ctx.font = `bold ${14 + comboCount}px Courier New`; ctx.textAlign = 'center';
                    ctx.fillStyle = hue;
                    ctx.fillText(`x${comboCount}`, player.x, player.y - comboRing - 8);
                }
                ctx.globalAlpha = 1; ctx.shadowBlur = 0;
            }
        }

        // Particles
        particles.forEach(p => {
            ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
            if (p.text) {
                ctx.font = 'bold 16px Courier New'; ctx.textAlign = 'center';
                ctx.shadowBlur = 8; ctx.shadowColor = p.color;
                ctx.fillText(p.text, p.x, p.y); ctx.shadowBlur = 0;
            } else {
                ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
            }
        });
        ctx.globalAlpha = 1;

        // Screen flash
        if (flashAlpha > 0) {
            ctx.fillStyle = flashColor || '#fff'; ctx.globalAlpha = flashAlpha;
            ctx.fillRect(0, 0, WIDTH, HEIGHT); ctx.globalAlpha = 1; flashAlpha -= 0.015;
        }

        // Slow-mo tint
        if (activePowerups.slowmo > 0) {
            ctx.fillStyle = '#ff00ff'; ctx.globalAlpha = 0.06;
            ctx.fillRect(0, 0, WIDTH, HEIGHT); ctx.globalAlpha = 1;
        }

        // Edge warnings
        if (isActive) {
            edgeWarnings.forEach(w => {
                // Clamp to screen edge
                let wx = Math.max(30, Math.min(WIDTH - 30, w.x));
                let wy = Math.max(30, Math.min(HEIGHT - 30, w.y));
                ctx.globalAlpha = w.life * 0.8;
                ctx.fillStyle = w.color;
                ctx.shadowBlur = 15; ctx.shadowColor = w.color;
                // Draw warning triangle
                ctx.save(); ctx.translate(wx, wy);
                const a = Math.atan2(HEIGHT/2 - wy, WIDTH/2 - wx);
                ctx.rotate(a);
                ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-6, -7); ctx.lineTo(-6, 7); ctx.closePath(); ctx.fill();
                ctx.restore();
                ctx.shadowBlur = 0;
            });
            ctx.globalAlpha = 1;

            // Danger border ‚Äî red glow intensifies with enemy count
            if (enemies.length > 3) {
                const intensity = Math.min(0.4, (enemies.length - 3) * 0.03) * (0.6 + Math.sin(dangerPulse) * 0.4);
                ctx.globalAlpha = intensity;
                const dg = ctx.createLinearGradient(0, 0, 40, 0);
                dg.addColorStop(0, '#ff0044'); dg.addColorStop(1, 'transparent');
                ctx.fillStyle = dg; ctx.fillRect(0, 0, 40, HEIGHT);
                const dg2 = ctx.createLinearGradient(WIDTH, 0, WIDTH-40, 0);
                dg2.addColorStop(0, '#ff0044'); dg2.addColorStop(1, 'transparent');
                ctx.fillStyle = dg2; ctx.fillRect(WIDTH-40, 0, 40, HEIGHT);
                const dg3 = ctx.createLinearGradient(0, 0, 0, 40);
                dg3.addColorStop(0, '#ff0044'); dg3.addColorStop(1, 'transparent');
                ctx.fillStyle = dg3; ctx.fillRect(0, 0, WIDTH, 40);
                const dg4 = ctx.createLinearGradient(0, HEIGHT, 0, HEIGHT-40);
                dg4.addColorStop(0, '#ff0044'); dg4.addColorStop(1, 'transparent');
                ctx.fillStyle = dg4; ctx.fillRect(0, HEIGHT-40, WIDTH, 40);
                ctx.globalAlpha = 1;
            }

            // Vignette (cached)
            if (!cachedVignette || vignetteW !== WIDTH || vignetteH !== HEIGHT) {
                cachedVignette = ctx.createRadialGradient(WIDTH/2, HEIGHT/2, HEIGHT*0.3, WIDTH/2, HEIGHT/2, HEIGHT*0.8);
                cachedVignette.addColorStop(0, 'transparent');
                cachedVignette.addColorStop(1, 'rgba(0,0,0,0.5)');
                vignetteW = WIDTH; vignetteH = HEIGHT;
            }
            ctx.fillStyle = cachedVignette;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
        }

        // Expanding rings
        rings.forEach(r => {
            ctx.globalAlpha = r.life * 0.7;
            ctx.strokeStyle = r.color;
            ctx.lineWidth = r.width * r.life;
            ctx.shadowBlur = 15; ctx.shadowColor = r.color;
            ctx.beginPath(); ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2); ctx.stroke();
            ctx.shadowBlur = 0;
        });
        ctx.globalAlpha = 1;

        // Wave announcement
        if (waveAnnounceTimer > 0 && gameState === 'playing') {
            ctx.save(); ctx.globalAlpha = Math.min(1, waveAnnounceTimer);
            ctx.font = 'bold 64px Courier New'; ctx.textAlign = 'center';
            ctx.fillStyle = '#00ff88'; ctx.shadowBlur = 30; ctx.shadowColor = '#00ff88';
            ctx.fillText(waveAnnounce, WIDTH/2, HEIGHT/2); ctx.restore();
        }

        // Kill streak announcement
        if (killStreakAnnounceTimer > 0 && gameState === 'playing') {
            ctx.save(); ctx.globalAlpha = Math.min(1, killStreakAnnounceTimer);
            const scale = 1 + (1 - Math.min(1, killStreakAnnounceTimer)) * 0.3;
            ctx.font = `bold ${Math.floor(36 * scale)}px Courier New`; ctx.textAlign = 'center';
            ctx.fillStyle = '#ff8800'; ctx.shadowBlur = 20; ctx.shadowColor = '#ff8800';
            ctx.fillText(killStreakAnnounce, WIDTH/2, HEIGHT/2 + 60); ctx.restore();
        }

        // CRT scanline overlay
        if (isActive) {
            ctx.fillStyle = 'rgba(0,0,0,0.03)';
            for (let y = 0; y < HEIGHT; y += 4) {
                ctx.fillRect(0, y, WIDTH, 2);
            }
        }

        if (shakeAmount > 0) ctx.restore();
    }

    init();
    </script>
</body>
</html>
