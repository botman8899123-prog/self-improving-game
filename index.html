<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>NEON SURVIVE ‚Äî Self-Improving Game</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéÆ</text></svg>">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0f;
            color: #00ff88;
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none; user-select: none;
        }
        #gameCanvas { display: block; background: #000; cursor: none; touch-action: none; }
        .overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        .hud { position: absolute; top: 20px; left: 20px; font-size: 18px; text-shadow: 0 0 10px #00ff88; pointer-events: none; }
        .hud-right { position: absolute; top: 20px; right: 20px; text-align: right; font-size: 14px; opacity: 0.7; }
        .hud-bottom { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); font-size: 13px; opacity: 0.6; text-align: center; pointer-events: none; }
        #menu {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: all;
        }
        #menu.hidden { display: none; }
        .title {
            font-size: 72px; font-weight: bold;
            text-shadow: 0 0 20px #00ff88, 0 0 40px #00ff88;
            margin-bottom: 20px; animation: pulse 2s infinite;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .subtitle { font-size: 18px; opacity: 0.8; margin-bottom: 40px; }
        .high-score { font-size: 24px; margin-bottom: 30px; }
        .start-btn {
            padding: 15px 40px; font-size: 24px; font-family: 'Courier New', monospace;
            background: transparent; color: #00ff88; border: 2px solid #00ff88;
            cursor: pointer; transition: all 0.3s; text-shadow: 0 0 10px #00ff88;
            pointer-events: all;
        }
        .start-btn:hover { background: #00ff88; color: #000; box-shadow: 0 0 20px #00ff88; }
        .start-btn { touch-action: manipulation; }
        .controls { margin-top: 30px; font-size: 14px; opacity: 0.6; text-align: center; }
        #gameOver {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; pointer-events: all;
        }
        #gameOver.show { display: flex; }
        .game-over-title { font-size: 64px; color: #ff0044; text-shadow: 0 0 20px #ff0044; margin-bottom: 30px; }
        .final-score { font-size: 32px; margin-bottom: 40px; text-align: center; line-height: 1.6; }
        .info-section { max-width: 800px; margin: 40px auto; padding: 20px; background: rgba(0,255,136,0.05); border: 1px solid #00ff88; width: calc(100% - 30px); }
        .info-section h2 { margin-bottom: 15px; text-shadow: 0 0 10px #00ff88; }
        .info-section p { line-height: 1.6; opacity: 0.8; }
        .footer { text-align: center; padding: 20px; opacity: 0.5; font-size: 12px; }
        #pauseOverlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100; pointer-events: all;
        }
        #pauseOverlay.show { display: flex; }
        .pause-title { font-size: 64px; color: #00ff88; text-shadow: 0 0 30px #00ff88; margin-bottom: 20px; }
        .pause-hint { font-size: 16px; opacity: 0.6; margin-top: 20px; }
        #pauseBtn {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            font-family: 'Courier New', monospace; font-size: 18px;
            background: transparent; color: #00ff88; border: 1px solid rgba(0,255,136,0.3);
            padding: 5px 15px; cursor: pointer; z-index: 50; display: none; opacity: 0.5;
            transition: opacity 0.2s;
        }
        #pauseBtn:hover { opacity: 1; }
        @media (max-width: 768px) {
            .title { font-size: 42px; }
            .game-over-title { font-size: 42px; }
            .hud { font-size: 14px; top: 10px; left: 10px; }
            .hud-right { font-size: 12px; top: 10px; right: 10px; }
        }
        @media (max-width: 420px) {
            .title { font-size: 32px; }
            .subtitle { font-size: 14px; }
            .game-over-title { font-size: 32px; }
            .high-score { font-size: 18px; }
            .start-btn { font-size: 20px; padding: 12px 30px; }
            .hud { font-size: 12px; top: 8px; left: 8px; max-width: 60%; }
            .hud-right { font-size: 10px; top: 8px; right: 8px; }
            .hud-bottom { font-size: 11px; bottom: 12px; }
            .controls { font-size: 12px; margin-top: 20px; }
            .info-section { padding: 15px; font-size: 13px; }
            .info-section h2 { font-size: 18px; }
            #pauseBtn { font-size: 14px; padding: 4px 10px; top: 10px; left: auto; right: 60px; transform: none; }
            #muteBtn { right: 10px !important; font-size: 14px !important; padding: 4px 8px !important; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="overlay">
        <div class="hud"><div id="scoreDisplay">TIME: 0.0s | GRAZE: 0</div></div>
        <div class="hud-right"><div>Iteration #20</div><div>Grade: 85/100</div></div>
        <div class="hud-bottom" id="powerupHud"></div>
    </div>
    <div id="menu">
        <div class="title">NEON SURVIVE</div>
        <div class="subtitle">Self-Improving Game v20</div>
        <div class="high-score" id="highScoreDisplay">HIGH SCORE: 0</div>
        <button class="start-btn" id="startBtn">START</button>
        <div class="controls">
            MOUSE / WASD / ARROW KEYS / TOUCH<br>
            SPACE / DOUBLE-TAP to DASH<br>
            Dodge enemies. Graze for bonus points. Collect power-ups. Survive.
        </div>
        <div id="lifetimeStats" style="margin-top:25px;font-size:12px;opacity:0.5;text-align:center;line-height:1.8;"></div>
    </div>
    <button id="pauseBtn" onclick="togglePause()">‚ùö‚ùö PAUSE</button>
    <button id="muteBtn" onclick="toggleMute()" style="position:fixed;top:20px;right:120px;font-family:'Courier New',monospace;font-size:18px;background:transparent;color:#00ff88;border:1px solid rgba(0,255,136,0.3);padding:5px 10px;cursor:pointer;z-index:50;display:none;opacity:0.5;transition:opacity 0.2s;">üîä</button>
    <div id="pauseOverlay">
        <div class="pause-title">PAUSED</div>
        <button class="start-btn" onclick="togglePause()">RESUME</button>
        <div class="pause-hint">Press P or ESC to resume</div>
    </div>
    <div id="gameOver">
        <div class="game-over-title">GAME OVER</div>
        <div class="final-score" id="finalScore">SCORE: 0</div>
        <button class="start-btn" id="restartBtn">PLAY AGAIN</button>
    </div>
    <div class="info-section">
        <h2>About This Game</h2>
        <p>This is a <strong>self-improving autonomous game</strong>. Every 7 minutes, an AI agent evaluates the current version, grades it, and automatically generates improvements. The game evolves itself over time.</p>
        <p style="margin-top:10px;">You are playing <strong>Iteration #20</strong>. Check back regularly to see how it transforms itself.</p>
        <p style="margin-top:10px;"><a href="https://game.theselfimprovingpage.com" target="_blank" style="color:#00ffff;">üï∞Ô∏è Explore the Time Machine</a> ‚Äî browse every version and see the evolution history.</p>
    </div>
    <div class="footer">
        Iteration #20 | Grade: 85/100 | Last Updated: <span id="timestamp"></span>
        <br><a href="https://game.theselfimprovingpage.com" target="_blank" style="color:#00ff88;opacity:0.7;text-decoration:underline;">üï∞Ô∏è Time Machine ‚Äî See how this game evolved</a>
    </div>
    <script>
    // ============================================
    // NEON SURVIVE ‚Äî Iteration 20 (Performance & Mobile Audit)
    // ============================================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let WIDTH, HEIGHT;
    let gameState = 'menu';
    let paused = false;
    let killCount = 0;
    let score = 0, grazeCount = 0, gameTime = 0, difficulty = 1;
    let highScore = localStorage.getItem('neonSurviveHighScore') || 0;
    let newHighScore = false;

    // Lifetime stats
    let lifetime = JSON.parse(localStorage.getItem('neonSurviveLifetime') || '{"games":0,"bestWave":0,"totalKills":0,"totalGrazes":0,"totalTime":0,"bestCombo":0}');
    function saveLifetime() { localStorage.setItem('neonSurviveLifetime', JSON.stringify(lifetime)); }

    // Edge warnings
    let edgeWarnings = [];

    // Ambient beat
    let beatInterval = null, beatOsc = null, beatGain = null;

    // Cached vignette
    let cachedVignette = null, vignetteW = 0, vignetteH = 0;

    // Cached background gradient
    let cachedBgGrad = null, bgGradWave = -1, bgGradW = 0, bgGradH = 0, bgGradDying = false;

    // Cached CRT scanline overlay
    let cachedScanlines = null, scanW = 0, scanH = 0;
    function buildScanlines() {
        if (scanW === WIDTH && scanH === HEIGHT && cachedScanlines) return;
        const oc = document.createElement('canvas');
        oc.width = WIDTH; oc.height = HEIGHT;
        const octx = oc.getContext('2d');
        octx.fillStyle = 'rgba(0,0,0,0.03)';
        for (let y = 0; y < HEIGHT; y += 4) octx.fillRect(0, y, WIDTH, 2);
        cachedScanlines = oc; scanW = WIDTH; scanH = HEIGHT;
    }

    // Cached danger border gradients
    let cachedDanger = { w: 0, h: 0, left: null, right: null, top: null, bottom: null };
    function buildDangerGradients() {
        if (cachedDanger.w === WIDTH && cachedDanger.h === HEIGHT) return;
        const dg = ctx.createLinearGradient(0, 0, 40, 0);
        dg.addColorStop(0, '#ff0044'); dg.addColorStop(1, 'transparent');
        const dg2 = ctx.createLinearGradient(WIDTH, 0, WIDTH-40, 0);
        dg2.addColorStop(0, '#ff0044'); dg2.addColorStop(1, 'transparent');
        const dg3 = ctx.createLinearGradient(0, 0, 0, 40);
        dg3.addColorStop(0, '#ff0044'); dg3.addColorStop(1, 'transparent');
        const dg4 = ctx.createLinearGradient(0, HEIGHT, 0, HEIGHT-40);
        dg4.addColorStop(0, '#ff0044'); dg4.addColorStop(1, 'transparent');
        cachedDanger = { w: WIDTH, h: HEIGHT, left: dg, right: dg2, top: dg3, bottom: dg4 };
    }

    // Danger border
    let dangerPulse = 0;

    // Mobile detection
    const isMobile = /Android|iPhone|iPad|iPod|webOS/i.test(navigator.userAgent) || window.innerWidth < 768;

    // Player
    let player = { x: 0, y: 0, vx: 0, vy: 0, radius: 12, trail: [] };

    // Dash
    let dash = { active: false, timer: 0, cooldown: 0, duration: 0.15, cooldownTime: 1.2, speed: 1200, invincible: false };
    let lastTapTime = 0;

    // Entities
    let enemies = [], particles = [], stars = [], powerups = [], orbs = [];

    // Input
    let keys = {}, mouse = { x: 0, y: 0, active: false }, touch = { x: 0, y: 0, active: false };

    // Timing
    let lastSpawn = 0, spawnInterval = 1000, lastPowerupSpawn = 0;

    // Effects
    let shakeAmount = 0, flashColor = null, flashAlpha = 0;
    // Kill streak
    let killStreak = 0, killStreakTimer = 0, killStreakAnnounce = '', killStreakAnnounceTimer = 0;
    // Ring explosions (wave clear, death)
    let rings = [];
    // Death slowmo
    let deathSlowmo = 0, deathSlowmoDuration = 1.2;

    // Near-death bullet time
    let bulletTime = 0, bulletTimeDuration = 0.12;

    // Proximity heartbeat
    let proximityBeatTimer = 0, lastProximityBeat = 0;

    // Dash afterimages
    let dashAfterimages = [];

    // Attract mode (menu background)
    let attractEnemies = [];
    function updateAttractMode(dt) {
        if (Math.random() < dt * 1.5) {
            const side = Math.floor(Math.random() * 4);
            let x, y, vx, vy;
            const sp = 60 + Math.random() * 100;
            if (side === 0) { x = Math.random() * WIDTH; y = -15; vx = (Math.random()-0.5)*80; vy = sp; }
            else if (side === 1) { x = WIDTH+15; y = Math.random() * HEIGHT; vx = -sp; vy = (Math.random()-0.5)*80; }
            else if (side === 2) { x = Math.random() * WIDTH; y = HEIGHT+15; vx = (Math.random()-0.5)*80; vy = -sp; }
            else { x = -15; y = Math.random() * HEIGHT; vx = sp; vy = (Math.random()-0.5)*80; }
            const colors = ['#ff0044','#ffaa00','#ff00ff','#00aaff'];
            attractEnemies.push({ x, y, vx, vy, radius: 5+Math.random()*6, color: colors[Math.floor(Math.random()*4)], trail: [] });
        }
        attractEnemies.forEach(e => {
            e.x += e.vx * dt; e.y += e.vy * dt;
            e.trail.push({ x: e.x, y: e.y, life: 1 });
            if (e.trail.length > 6) e.trail.shift();
            e.trail.forEach(t => t.life -= 0.15);
        });
        attractEnemies = attractEnemies.filter(e => e.x > -50 && e.x < WIDTH+50 && e.y > -50 && e.y < HEIGHT+50);
    }
    function renderAttractMode() {
        attractEnemies.forEach(e => {
            e.trail.forEach(t => {
                if (t.life > 0) { ctx.globalAlpha = t.life * 0.15; ctx.fillStyle = e.color; ctx.beginPath(); ctx.arc(t.x, t.y, e.radius * t.life * 0.5, 0, Math.PI*2); ctx.fill(); }
            });
            ctx.globalAlpha = 0.3; ctx.fillStyle = e.color; ctx.shadowBlur = 10; ctx.shadowColor = e.color;
            ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
        });
        ctx.globalAlpha = 1;
    }

    // Performance rank system
    function getPerformanceRank(wave, score, grazes, comboBest, kills) {
        let pts = 0;
        pts += Math.min(40, wave * 5);           // waves survived (max 40)
        pts += Math.min(25, score / 200);         // score (max 25)
        pts += Math.min(15, grazes * 1.5);        // grazing skill (max 15)
        pts += Math.min(10, comboBest * 2);       // combo mastery (max 10)
        pts += Math.min(10, kills * 1);            // kills (max 10)
        if (pts >= 90) return { rank: 'S', color: '#ffdd00', glow: '#ffdd00' };
        if (pts >= 75) return { rank: 'A', color: '#00ff88', glow: '#00ff88' };
        if (pts >= 55) return { rank: 'B', color: '#00aaff', glow: '#00aaff' };
        if (pts >= 35) return { rank: 'C', color: '#ffaa00', glow: '#ffaa00' };
        if (pts >= 20) return { rank: 'D', color: '#ff6600', glow: '#ff6600' };
        return { rank: 'F', color: '#ff0044', glow: '#ff0044' };
    }

    // Speed lines during dash
    let speedLines = [];
    function spawnSpeedLines() {
        for (let i = 0; i < 5; i++) {
            const angle = Math.atan2(player.vy, player.vx) + Math.PI + (Math.random()-0.5)*0.8;
            speedLines.push({
                x: player.x + (Math.random()-0.5)*30,
                y: player.y + (Math.random()-0.5)*30,
                angle, length: 20 + Math.random()*40, life: 0.2 + Math.random()*0.15, decay: 0.04
            });
        }
    }

    // Wave system
    let wave = 1, waveTimer = 0, waveDuration = 8, waveBreak = false, waveBreakTimer = 0, waveBreakDuration = 2;
    let waveAnnounce = '', waveAnnounceTimer = 0;
    let waveKills = 0, waveGrazes = 0; // per-wave stats
    let waveBreakStats = null; // {kills, grazes, wave} shown during break
    let beatPulse = 0; // 0-1 pulse synced to beat timing

    // Combo system
    let comboCount = 0, comboTimer = 0, comboBest = 0;

    // Active power-ups
    let activePowerups = { shield: 0, slowmo: 0, magnet: 0 };

    // Audio
    let audioCtx = null;
    function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

    function playSound(freq, duration, type = 'sine', volume = 0.1) {
        if (!audioCtx || muted) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        gain.gain.value = volume;
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + duration);
    }

    // Ambient beat system
    let beatBPM = 80, beatPlaying = false;
    function startBeat() {
        if (!audioCtx || beatPlaying) return;
        beatPlaying = true;
        function scheduleBeat() {
            if (!beatPlaying) return;
            const bpm = beatBPM + (wave - 1) * 8;
            const interval = 60000 / bpm;
            // Kick
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(80, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.12);
            gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.2);
            beatPulse = 1; // Trigger visual pulse on each beat
            beatInterval = setTimeout(scheduleBeat, interval);
        }
        scheduleBeat();
    }
    function stopBeat() { beatPlaying = false; if (beatInterval) clearTimeout(beatInterval); }

    // Dash sound ‚Äî whoosh
    function playDashSound() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(300, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.15);
        gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.2);
    }

    // Power-up pickup sound
    function playPowerupSound() {
        playSound(800, 0.1, 'sine', 0.15);
        setTimeout(() => playSound(1200, 0.1, 'sine', 0.12), 60);
        setTimeout(() => playSound(1600, 0.15, 'sine', 0.1), 120);
    }

    // Dramatic death explosion sound
    function playDeathSound() {
        if (!audioCtx) return;
        // Low rumble
        const osc1 = audioCtx.createOscillator();
        const g1 = audioCtx.createGain();
        osc1.type = 'sawtooth';
        osc1.frequency.setValueAtTime(80, audioCtx.currentTime);
        osc1.frequency.exponentialRampToValueAtTime(20, audioCtx.currentTime + 0.8);
        g1.gain.setValueAtTime(0.2, audioCtx.currentTime);
        g1.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.8);
        osc1.connect(g1); g1.connect(audioCtx.destination);
        osc1.start(); osc1.stop(audioCtx.currentTime + 0.9);
        // Noise burst
        const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.3, audioCtx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/data.length, 2);
        const noise = audioCtx.createBufferSource();
        const g2 = audioCtx.createGain();
        noise.buffer = buf;
        g2.gain.setValueAtTime(0.15, audioCtx.currentTime);
        g2.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
        noise.connect(g2); g2.connect(audioCtx.destination);
        noise.start();
        // Descending tone
        setTimeout(() => { playSound(400, 0.4, 'sine', 0.1); }, 200);
        setTimeout(() => { playSound(200, 0.5, 'sine', 0.08); }, 400);
    }

    // Graze streak sound ‚Äî rising pitch with combo
    function playGrazeStreakSound(combo) {
        if (!audioCtx) return;
        const baseFreq = 600 + Math.min(combo, 15) * 80;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(baseFreq, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.3, audioCtx.currentTime + 0.08);
        g.gain.setValueAtTime(0.06 + Math.min(combo, 10) * 0.01, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.2);
    }

    // Proximity heartbeat sound ‚Äî low thump when enemies are close
    function playProximityBeat(closeness) {
        if (!audioCtx || muted) return;
        const vol = 0.03 + closeness * 0.08;
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(55, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(30, audioCtx.currentTime + 0.12);
        g.gain.setValueAtTime(vol, audioCtx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
        osc.connect(g); g.connect(audioCtx.destination);
        osc.start(); osc.stop(audioCtx.currentTime + 0.2);
    }

    // Wave clear fanfare
    function playWaveClearSound() {
        if (!audioCtx) return;
        const notes = [523, 659, 784, 1047]; // C5 E5 G5 C6
        notes.forEach((f, i) => {
            setTimeout(() => playSound(f, 0.25, 'sine', 0.1), i * 80);
        });
    }

    // Bass drone ‚Äî sustained tension note that increases with wave
    let bassDrone = null, bassDroneGain = null;
    function startBassDrone() {
        if (!audioCtx || bassDrone) return;
        bassDrone = audioCtx.createOscillator();
        bassDroneGain = audioCtx.createGain();
        bassDrone.type = 'sine';
        bassDrone.frequency.value = 40;
        bassDroneGain.gain.value = 0.03;
        bassDrone.connect(bassDroneGain);
        bassDroneGain.connect(audioCtx.destination);
        bassDrone.start();
    }
    function updateBassDrone(wave) {
        if (!bassDrone || !bassDroneGain) return;
        bassDrone.frequency.value = 35 + wave * 5;
        bassDroneGain.gain.value = Math.min(0.06, 0.02 + wave * 0.005);
    }
    function stopBassDrone() {
        if (bassDrone) { try { bassDrone.stop(); } catch(e){} bassDrone = null; bassDroneGain = null; }
    }

    // Arpeggio melody system
    let arpPlaying = false, arpTimeout = null, arpStep = 0;
    let muted = localStorage.getItem('neonSurviveMuted') === 'true';
    const arpScales = [
        [261, 329, 392, 523, 659], // C major pentatonic
        [293, 349, 440, 523, 659], // D minor-ish
        [330, 392, 494, 587, 659], // E phrygian feel
        [349, 440, 523, 659, 698], // F lydian feel
    ];
    function startArp() {
        if (arpPlaying || muted) return;
        arpPlaying = true; arpStep = 0;
        function scheduleArpNote() {
            if (!arpPlaying || !audioCtx || muted) return;
            const scaleIdx = Math.min(wave - 1, arpScales.length - 1);
            const scale = arpScales[scaleIdx];
            const note = scale[arpStep % scale.length];
            const octave = Math.floor(arpStep / scale.length) % 2 === 0 ? 1 : 2;
            const freq = note * octave;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'triangle';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.04, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.25);
            arpStep++;
            const bpm = beatBPM + (wave - 1) * 8;
            arpTimeout = setTimeout(scheduleArpNote, (60000 / bpm) / 2);
        }
        scheduleArpNote();
    }
    function stopArp() { arpPlaying = false; if (arpTimeout) clearTimeout(arpTimeout); }

    function toggleMute() {
        muted = !muted;
        localStorage.setItem('neonSurviveMuted', muted);
        document.getElementById('muteBtn').textContent = muted ? 'üîá' : 'üîä';
        if (muted) { stopBeat(); stopArp(); stopBassDrone(); if (audioCtx) audioCtx.suspend(); }
        else if (gameState === 'playing' && !paused) { if (audioCtx) audioCtx.resume(); startBeat(); startArp(); startBassDrone(); }
    }

    // ============================================
    // INIT
    // ============================================
    function resizeCanvas() {
        WIDTH = window.innerWidth; HEIGHT = window.innerHeight;
        canvas.width = WIDTH; canvas.height = HEIGHT;
    }

    function init() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        // 3-layer parallax starfield
        for (let i = 0; i < 60; i++) {
            stars.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, size: 0.5 + Math.random(), speed: 0.05 + Math.random() * 0.15, layer: 0 });
        }
        for (let i = 0; i < 40; i++) {
            stars.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, size: 1 + Math.random(), speed: 0.2 + Math.random() * 0.3, layer: 1 });
        }
        for (let i = 0; i < 15; i++) {
            stars.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, size: 2 + Math.random() * 1.5, speed: 0.5 + Math.random() * 0.5, layer: 2 });
        }
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);
        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ' && gameState === 'playing' && !paused) { e.preventDefault(); tryDash(); }
            if ((e.key === 'p' || e.key === 'Escape') && gameState === 'playing') { e.preventDefault(); togglePause(); }
        });
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
        canvas.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; mouse.active = true; });
        canvas.addEventListener('touchstart', e => {
            handleTouch(e);
            const now = Date.now();
            if (now - lastTapTime < 300) tryDash();
            lastTapTime = now;
        });
        canvas.addEventListener('touchmove', handleTouch);
        canvas.addEventListener('touchend', () => touch.active = false);
        // Prevent scroll during gameplay
        document.body.addEventListener('touchmove', e => { if (gameState === 'playing') e.preventDefault(); }, { passive: false });
        document.getElementById('highScoreDisplay').textContent = `HIGH SCORE: ${Math.floor(highScore)}`;
        updateLifetimeDisplay();
        document.getElementById('timestamp').textContent = new Date().toLocaleString();
        requestAnimationFrame(gameLoop);
    }

    function handleTouch(e) {
        e.preventDefault();
        touch.x = e.touches[0].clientX;
        touch.y = e.touches[0].clientY;
        touch.active = true;
    }

    // ============================================
    // DASH
    // ============================================
    function tryDash() {
        if (dash.cooldown > 0 || dash.active) return;
        dash.active = true;
        dash.timer = dash.duration;
        dash.cooldown = dash.cooldownTime;
        dash.invincible = true;
        playDashSound();
        shakeAmount = 5;
        flashColor = '#00ff88'; flashAlpha = 0.15;
        spawnSpeedLines();
        // Dash trail burst
        for (let i = 0; i < 8; i++) {
            const a = Math.random() * Math.PI * 2;
            particles.push({
                x: player.x, y: player.y,
                vx: Math.cos(a) * 200, vy: Math.sin(a) * 200,
                life: 0.4, decay: 0.025, size: 3, color: '#00ff88'
            });
        }
    }

    // ============================================
    // GAME CONTROL
    // ============================================
    function togglePause() {
        if (gameState !== 'playing') return;
        paused = !paused;
        document.getElementById('pauseOverlay').classList.toggle('show', paused);
        if (paused) { stopBeat(); stopArp(); if (audioCtx) audioCtx.suspend(); }
        else { if (!muted) { startBeat(); startArp(); if (audioCtx) audioCtx.resume(); } }
    }

    function startGame() {
        initAudio();
        if (!muted) { startBeat(); startBassDrone(); startArp(); }
        document.getElementById('muteBtn').style.display = 'block';
        document.getElementById('muteBtn').textContent = muted ? 'üîá' : 'üîä';
        gameState = 'playing'; score = 0; grazeCount = 0; gameTime = 0; difficulty = 1;
        player.x = WIDTH / 2; player.y = HEIGHT / 2; player.vx = 0; player.vy = 0; player.trail = [];
        enemies = []; particles = []; powerups = [];
        lastSpawn = 0; lastPowerupSpawn = 0;
        wave = 1; waveTimer = 0; waveBreak = false; waveBreakTimer = 0;
        comboCount = 0; comboTimer = 0; comboBest = 0; killCount = 0; killStreak = 0; killStreakTimer = 0;
        paused = false; newHighScore = false; document.getElementById('pauseOverlay').classList.remove('show');
        document.getElementById('pauseBtn').style.display = 'block';
        dash.active = false; dash.timer = 0; dash.cooldown = 0; dash.invincible = false;
        activePowerups = { shield: 0, slowmo: 0, magnet: 0 };
        waveAnnounce = 'WAVE 1'; waveAnnounceTimer = 1.5;
        document.getElementById('menu').classList.add('hidden');
        document.getElementById('gameOver').classList.remove('show');
        document.body.style.overflow = 'hidden';
    }

    function endGame() {
        gameState = 'dying'; deathSlowmo = deathSlowmoDuration;
        shakeAmount = 25;
        // Death ring
        rings.push({ x: player.x, y: player.y, radius: 5, maxRadius: Math.max(WIDTH, HEIGHT) * 0.8, speed: 300, life: 1, color: '#ff0044', width: 4 });
        // Initial burst
        for (let i = 0; i < 30; i++) {
            const a = Math.random() * Math.PI * 2, sp = Math.random() * 300 + 50;
            particles.push({ x: player.x, y: player.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 1.5, decay: 0.012, size: Math.random()*5+2, color: Math.random()>0.5?'#ff0044':'#ff8800' });
        }
        playDeathSound();
    }

    function updateLifetimeDisplay() {
        const el = document.getElementById('lifetimeStats');
        if (el && lifetime.games > 0) {
            el.innerHTML = `GAMES: ${lifetime.games} | BEST WAVE: ${lifetime.bestWave} | KILLS: ${lifetime.totalKills} | GRAZES: ${lifetime.totalGrazes} | BEST COMBO: x${lifetime.bestCombo}`;
        }
    }

    function finalizeDeath() {
        gameState = 'gameover'; stopBeat(); stopBassDrone(); stopArp();
        document.getElementById('pauseBtn').style.display = 'none';
        document.body.style.overflow = '';
        // Update lifetime stats
        lifetime.games++;
        lifetime.bestWave = Math.max(lifetime.bestWave, wave);
        lifetime.totalKills += killCount;
        lifetime.totalGrazes += grazeCount;
        lifetime.totalTime += gameTime;
        lifetime.bestCombo = Math.max(lifetime.bestCombo, comboBest);
        saveLifetime();
        updateLifetimeDisplay();
        // Final explosion burst
        for (let i = 0; i < 40; i++) {
            const a = Math.random() * Math.PI * 2, sp = Math.random() * 200 + 80;
            particles.push({ x: player.x, y: player.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 1, decay: 0.02, size: Math.random()*4+1, color: Math.random()>0.3?'#ff0044':'#ffffff' });
        }
        flashColor = '#ff0044'; flashAlpha = 0.6;
        if (score > highScore) { highScore = score; localStorage.setItem('neonSurviveHighScore', highScore); }
        const survivalTime = gameTime.toFixed(1);
        const rankInfo = getPerformanceRank(wave, score, grazeCount, comboBest, killCount);
        document.getElementById('finalScore').innerHTML = `<div style="font-size:80px;color:${rankInfo.color};text-shadow:0 0 30px ${rankInfo.glow},0 0 60px ${rankInfo.glow};margin-bottom:10px;animation:pulse 1s infinite">${rankInfo.rank}</div>SCORE: ${Math.floor(score)}<br><span style="font-size:18px;opacity:0.7">Wave ${wave} | ${survivalTime}s | ${grazeCount} grazes | ${killCount} kills | Best combo: x${comboBest}</span>`;
        setTimeout(() => document.getElementById('gameOver').classList.add('show'), 800);
    }

    // ============================================
    // POWER-UPS
    // ============================================
    function spawnPowerup() {
        const types = ['shield', 'slowmo', 'magnet'];
        const colors = { shield: '#00aaff', slowmo: '#ff00ff', magnet: '#ffff00' };
        const symbols = { shield: 'üõ°', slowmo: '‚è≥', magnet: 'üß≤' };
        const type = types[Math.floor(Math.random() * types.length)];
        powerups.push({
            x: Math.random() * (WIDTH - 100) + 50,
            y: Math.random() * (HEIGHT - 100) + 50,
            type, color: colors[type], symbol: symbols[type],
            radius: 15, life: 10, pulse: 0
        });
    }

    function collectPowerup(p) {
        activePowerups[p.type] = p.type === 'shield' ? 5 : p.type === 'slowmo' ? 4 : 6;
        playPowerupSound();
        flashColor = p.color; flashAlpha = 0.2;
        // Pickup particles
        for (let i = 0; i < 12; i++) {
            const a = Math.random() * Math.PI * 2;
            particles.push({ x: p.x, y: p.y, vx: Math.cos(a)*150, vy: Math.sin(a)*150, life: 0.6, decay: 0.03, size: 2, color: p.color });
        }
        particles.push({ x: p.x, y: p.y - 15, vx: 0, vy: -60, life: 1, decay: 0.02, size: 0, color: p.color, text: p.type.toUpperCase() });
    }

    // ============================================
    // GAME LOOP
    // ============================================
    let lastTime = 0;
    function gameLoop(timestamp) {
        requestAnimationFrame(gameLoop);
        const rawDt = lastTime ? (timestamp - lastTime) / 1000 : 1/60;
        lastTime = timestamp;
        const dt = Math.min(rawDt, 1/30); // Cap dt to prevent physics jumps

        if (gameState === 'playing' && !paused) update(dt, timestamp);
        if (gameState === 'dying') updateDying(dt);
        if (gameState === 'menu' || gameState === 'gameover') updateAttractMode(dt);
        // Update rings always
        rings.forEach(r => { r.radius += r.speed * dt; r.life -= dt / (r.maxRadius / r.speed); });
        rings = rings.filter(r => r.life > 0 && r.radius < r.maxRadius);
        render();
    }

    function update(dt, timestamp) {
        // Bullet time tick
        if (bulletTime > 0) bulletTime -= dt;
        const btMult = bulletTime > 0 ? 0.15 : 1;
        const timeMult = (activePowerups.slowmo > 0 ? 0.5 : 1) * btMult;
        const eDt = dt * timeMult; // Enemy delta time (slowed)
        gameTime += dt;

        // Wave system
        waveTimer += dt;
        if (waveBreak) {
            waveBreakTimer += dt;
            if (waveBreakTimer >= waveBreakDuration) {
                waveBreak = false; waveBreakTimer = 0; waveTimer = 0; wave++;
                waveAnnounce = `WAVE ${wave}`; waveAnnounceTimer = 1.5;
                waveKills = 0; waveGrazes = 0; waveBreakStats = null;
                playSound(600, 0.2, 'square', 0.08);
                setTimeout(() => playSound(800, 0.2, 'square', 0.08), 100);
                updateBassDrone(wave);
            }
        } else if (waveTimer >= waveDuration) {
            waveBreak = true; waveBreakTimer = 0;
            waveBreakStats = { wave, kills: waveKills, grazes: waveGrazes };
            waveAnnounce = 'CLEAR!'; waveAnnounceTimer = 1.5;
            flashColor = '#00ff88'; flashAlpha = 0.3;
            playWaveClearSound();
            // Expanding ring VFX
            rings.push({ x: player.x, y: player.y, radius: 20, maxRadius: Math.max(WIDTH, HEIGHT) * 0.6, speed: 600, life: 1, color: '#00ff88', width: 3 });
            rings.push({ x: player.x, y: player.y, radius: 10, maxRadius: Math.max(WIDTH, HEIGHT) * 0.4, speed: 450, life: 1, color: '#00ffcc', width: 2 });
            // Spawn bonus orb during wave break
            powerups.push({
                x: WIDTH/2 + (Math.random()-0.5)*200, y: HEIGHT/2 + (Math.random()-0.5)*200,
                type: 'shield', color: '#00ffcc', symbol: '‚≠ê',
                radius: 18, life: waveBreakDuration + 0.5, pulse: 0
            });
        }
        if (waveAnnounceTimer > 0) waveAnnounceTimer -= dt;

        difficulty = 1 + (wave - 1) * 0.3 + gameTime * 0.02;
        spawnInterval = waveBreak ? 99999 : Math.max(250, 900 - wave * 60);

        // Combo timer
        if (comboTimer > 0) { comboTimer -= dt; if (comboTimer <= 0) comboCount = 0; }
        // Kill streak timer
        if (killStreakTimer > 0) { killStreakTimer -= dt; if (killStreakTimer <= 0) killStreak = 0; }
        if (killStreakAnnounceTimer > 0) killStreakAnnounceTimer -= dt;

        // Beat pulse decay
        if (beatPulse > 0) beatPulse = Math.max(0, beatPulse - dt * 5);

        // Dash update
        if (dash.active) { dash.timer -= dt; if (dash.timer <= 0) { dash.active = false; dash.invincible = false; } }
        if (dash.cooldown > 0) dash.cooldown -= dt;

        // Power-up timers
        for (const k in activePowerups) { if (activePowerups[k] > 0) activePowerups[k] -= dt; }

        // Score
        const comboMult = Math.max(1, comboCount);
        score = gameTime * 10 + grazeCount * 50 * comboMult;
        // New high score detection
        if (!newHighScore && score > highScore && highScore > 0) {
            newHighScore = true;
            flashColor = '#ffff00'; flashAlpha = 0.4;
            shakeAmount = 8;
            playSound(880, 0.2, 'sine', 0.12);
            setTimeout(() => playSound(1100, 0.2, 'sine', 0.1), 100);
            setTimeout(() => playSound(1320, 0.3, 'sine', 0.1), 200);
            for (let i = 0; i < 20; i++) {
                const a = Math.random() * Math.PI * 2;
                particles.push({ x: player.x, y: player.y, vx: Math.cos(a)*200, vy: Math.sin(a)*200, life: 1.2, decay: 0.015, size: 3, color: '#ffff00' });
            }
            particles.push({ x: WIDTH/2, y: HEIGHT/3, vx: 0, vy: -30, life: 2, decay: 0.012, size: 0, color: '#ffff00', text: '‚òÖ NEW HIGH SCORE ‚òÖ' });
        }
        const comboMult2 = comboCount > 1 ? ` | x${comboCount} MULT` : '';
        const dashText = dash.cooldown > 0 ? ` | DASH: ${dash.cooldown.toFixed(1)}s` : ' | DASH: ‚úì';
        document.getElementById('scoreDisplay').textContent = `WAVE ${wave} | ${Math.floor(score)} pts | GRAZE: ${grazeCount}${comboMult2}${dashText}`;

        // Power-up HUD
        const pTexts = [];
        if (activePowerups.shield > 0) pTexts.push(`üõ° ${activePowerups.shield.toFixed(1)}s`);
        if (activePowerups.slowmo > 0) pTexts.push(`‚è≥ ${activePowerups.slowmo.toFixed(1)}s`);
        if (activePowerups.magnet > 0) pTexts.push(`üß≤ ${activePowerups.magnet.toFixed(1)}s`);
        document.getElementById('powerupHud').textContent = pTexts.join('  ');

        updatePlayer(dt);

        // Spawn enemies
        if (timestamp - lastSpawn > spawnInterval) { spawnEnemy(); lastSpawn = timestamp; }

        // Spawn power-ups (every 8-12 seconds)
        if (timestamp - lastPowerupSpawn > 8000 + Math.random() * 4000) {
            if (powerups.length < 3) spawnPowerup();
            lastPowerupSpawn = timestamp;
        }

        updateEnemies(eDt);
        updatePowerups(dt);
        updateParticles(dt);
        updateStars(dt);
        checkCollisions();

        // Edge warnings
        edgeWarnings.forEach(w => w.life -= dt * 2);
        edgeWarnings = edgeWarnings.filter(w => w.life > 0);

        // Speed lines update
        speedLines.forEach(l => l.life -= l.decay);
        speedLines = speedLines.filter(l => l.life > 0);
        if (dash.active) spawnSpeedLines();

        // Proximity heartbeat ‚Äî find closest enemy, beat faster when near
        let closestEnemyDist = Infinity;
        enemies.forEach(e => {
            const dx = player.x - e.x, dy = player.y - e.y;
            const d = Math.sqrt(dx*dx + dy*dy);
            if (d < closestEnemyDist) closestEnemyDist = d;
        });
        if (closestEnemyDist < 150 && enemies.length > 0) {
            const closeness = 1 - closestEnemyDist / 150; // 0-1, 1 = touching
            const beatRate = 0.6 - closeness * 0.45; // 0.6s to 0.15s between beats
            proximityBeatTimer += dt;
            if (proximityBeatTimer >= beatRate) {
                proximityBeatTimer = 0;
                playProximityBeat(closeness);
            }
        } else {
            proximityBeatTimer = 0;
        }

        // Dash afterimages ‚Äî capture player ghost every few frames during dash
        if (dash.active && Math.random() < 0.7) {
            dashAfterimages.push({
                x: player.x, y: player.y,
                angle: Math.atan2(player.vy, player.vx),
                life: 0.35, maxLife: 0.35
            });
        }
        dashAfterimages.forEach(a => a.life -= dt);
        dashAfterimages = dashAfterimages.filter(a => a.life > 0);

        // Danger border pulse ‚Äî intensifies with enemy count
        dangerPulse += dt * 3;

        if (shakeAmount > 0) { shakeAmount *= 0.9; if (shakeAmount < 0.1) shakeAmount = 0; }
    }

    function updateDying(dt) {
        deathSlowmo -= dt;
        const slowFactor = 0.05 + 0.15 * (1 - deathSlowmo / deathSlowmoDuration);
        // Still update particles slowly for dramatic effect
        particles.forEach(p => { p.x += p.vx * dt * slowFactor; p.y += p.vy * dt * slowFactor; p.life -= p.decay * slowFactor; });
        particles = particles.filter(p => p.life > 0);
        // Enemies slow to crawl
        enemies.forEach(e => { e.x += e.vx * dt * slowFactor; e.y += e.vy * dt * slowFactor; });
        updateStars(dt * slowFactor);
        if (shakeAmount > 0) { shakeAmount *= 0.95; if (shakeAmount < 0.1) shakeAmount = 0; }
        if (deathSlowmo <= 0) finalizeDeath();
    }

    function updatePlayer(dt) {
        const accel = 800, maxSpeed = dash.active ? dash.speed : 400, friction = 0.85;
        if (keys['w'] || keys['arrowup']) player.vy -= accel * dt;
        if (keys['s'] || keys['arrowdown']) player.vy += accel * dt;
        if (keys['a'] || keys['arrowleft']) player.vx -= accel * dt;
        if (keys['d'] || keys['arrowright']) player.vx += accel * dt;

        if (mouse.active && gameState === 'playing') {
            const dx = mouse.x - player.x, dy = mouse.y - player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 5) { player.vx += (dx/dist)*accel*dt*0.5; player.vy += (dy/dist)*accel*dt*0.5; }
        }
        if (touch.active) {
            const dx = touch.x - player.x, dy = touch.y - player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 5) { player.vx += (dx/dist)*accel*dt; player.vy += (dy/dist)*accel*dt; }
        }

        player.vx *= friction; player.vy *= friction;
        const speed = Math.sqrt(player.vx*player.vx + player.vy*player.vy);
        if (speed > maxSpeed) { player.vx = (player.vx/speed)*maxSpeed; player.vy = (player.vy/speed)*maxSpeed; }

        player.x += player.vx * dt;
        player.y += player.vy * dt;
        player.x = Math.max(player.radius, Math.min(WIDTH - player.radius, player.x));
        player.y = Math.max(player.radius, Math.min(HEIGHT - player.radius, player.y));

        player.trail.push({ x: player.x, y: player.y, life: 1 });
        if (player.trail.length > (dash.active ? 25 : 15)) player.trail.shift();
        player.trail.forEach(t => t.life -= 0.05);
    }

    function spawnEnemy() {
        const r = Math.random();
        // Sniper spawns from wave 3+, 12% chance
        const type = (wave >= 3 && r < 0.12) ? 'sniper' : r < 0.5 ? 'basic' : r < 0.8 ? 'homing' : 'burst';
        const side = Math.floor(Math.random() * 4);
        let x, y;
        if (side === 0) { x = Math.random() * WIDTH; y = -20; }
        else if (side === 1) { x = WIDTH + 20; y = Math.random() * HEIGHT; }
        else if (side === 2) { x = Math.random() * WIDTH; y = HEIGHT + 20; }
        else { x = -20; y = Math.random() * HEIGHT; }

        const dx = player.x - x, dy = player.y - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const speed = type === 'sniper' ? 20 * difficulty : (50 + Math.random() * 50) * difficulty;

        const colors = { basic: '#ff0044', homing: '#ffaa00', burst: '#ff00ff', sniper: '#ff4444' };
        const radii = { basic: 8, homing: 10, burst: 12, sniper: 9 };

        enemies.push({
            x, y, vx: (dx/dist)*speed, vy: (dy/dist)*speed,
            type, radius: radii[type], color: colors[type], grazed: false,
            burstTimer: type === 'burst' ? 2 + Math.random() : 0,
            // Sniper: locks position, charges laser sight, then fires fast projectile
            sniperPhase: type === 'sniper' ? 'approach' : null,
            sniperTimer: type === 'sniper' ? 1.5 : 0, // approach time
            sniperAimX: 0, sniperAimY: 0, sniperChargeTime: 1.2,
            trail: []
        });
        playSound(type === 'sniper' ? 200 : 400, 0.05, 'sine', 0.02);
        // Edge warning
        edgeWarnings.push({ x, y, life: 0.5, color: colors[type] || '#ff0044' });
    }

    function updateEnemies(dt) {
        const toAdd = [];
        enemies.forEach(e => {
            if (e.type === 'homing') {
                const dx = player.x - e.x, dy = player.y - e.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const turnSpeed = 100 * difficulty;
                e.vx += (dx/dist)*turnSpeed*dt; e.vy += (dy/dist)*turnSpeed*dt;
                const sp = Math.sqrt(e.vx*e.vx + e.vy*e.vy);
                const ms = 200 * difficulty;
                if (sp > ms) { e.vx = (e.vx/sp)*ms; e.vy = (e.vy/sp)*ms; }
            }
            if (e.type === 'burst') {
                e.burstTimer -= dt;
                if (e.burstTimer <= 0) {
                    for (let i = 0; i < 4; i++) {
                        const a = (Math.PI * 2 / 4) * i;
                        toAdd.push({
                            x: e.x, y: e.y,
                            vx: Math.cos(a) * 150 * difficulty, vy: Math.sin(a) * 150 * difficulty,
                            type: 'basic', radius: 5, color: '#ff66ff', grazed: false, burstTimer: 0, trail: []
                        });
                    }
                    for (let i = 0; i < 8; i++) {
                        const a = Math.random() * Math.PI * 2;
                        particles.push({ x: e.x, y: e.y, vx: Math.cos(a)*120, vy: Math.sin(a)*120, life: 0.5, decay: 0.03, size: 2, color: '#ff00ff' });
                    }
                    playSound(300, 0.15, 'square', 0.08);
                    e.life = 0;
                }
            }
            // Sniper enemy: approach ‚Üí lock ‚Üí charge (laser sight) ‚Üí fire fast bullet
            if (e.type === 'sniper' && e.sniperPhase) {
                if (e.sniperPhase === 'approach') {
                    e.sniperTimer -= dt;
                    if (e.sniperTimer <= 0) {
                        e.sniperPhase = 'charge';
                        e.sniperTimer = e.sniperChargeTime;
                        e.vx = 0; e.vy = 0; // Stop moving
                        // Lock aim at player's current position
                        e.sniperAimX = player.x; e.sniperAimY = player.y;
                        playSound(150, 0.3, 'sawtooth', 0.04); // Charging sound
                    }
                } else if (e.sniperPhase === 'charge') {
                    e.sniperTimer -= dt;
                    // Update aim to track player slowly during charge (slight tracking)
                    const aimDx = player.x - e.sniperAimX, aimDy = player.y - e.sniperAimY;
                    e.sniperAimX += aimDx * dt * 0.8;
                    e.sniperAimY += aimDy * dt * 0.8;
                    if (e.sniperTimer <= 0) {
                        // Fire!
                        const fdx = e.sniperAimX - e.x, fdy = e.sniperAimY - e.y;
                        const fd = Math.sqrt(fdx*fdx + fdy*fdy) || 1;
                        const bulletSpeed = 500 * difficulty;
                        toAdd.push({
                            x: e.x, y: e.y,
                            vx: (fdx/fd)*bulletSpeed, vy: (fdy/fd)*bulletSpeed,
                            type: 'basic', radius: 5, color: '#ff6666', grazed: false, burstTimer: 0, trail: []
                        });
                        // Fire VFX
                        playSound(800, 0.08, 'square', 0.15);
                        shakeAmount = Math.max(shakeAmount, 4);
                        for (let i = 0; i < 6; i++) {
                            const a = Math.atan2(fdy, fdx) + (Math.random()-0.5)*0.5;
                            const sp = 100 + Math.random()*100;
                            particles.push({ x: e.x, y: e.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.3, decay: 0.04, size: 2, color: '#ff4444' });
                        }
                        e.life = 0; // Sniper disappears after firing
                    }
                }
            }
            e.x += e.vx * dt; e.y += e.vy * dt;
            // Enemy trail
            e.trail.push({ x: e.x, y: e.y, life: 1 });
            if (e.trail.length > 8) e.trail.shift();
            e.trail.forEach(t => t.life -= 0.12);
        });
        enemies = enemies.filter(e => e.life !== 0 && e.x > -100 && e.x < WIDTH+100 && e.y > -100 && e.y < HEIGHT+100);
        enemies.push(...toAdd);
    }

    function updatePowerups(dt) {
        powerups.forEach(p => {
            p.life -= dt; p.pulse += dt * 3;
            // Magnet effect ‚Äî pull toward player
            if (activePowerups.magnet > 0) {
                const dx = player.x - p.x, dy = player.y - p.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 10 && dist < 300) {
                    p.x += (dx/dist) * 200 * dt;
                    p.y += (dy/dist) * 200 * dt;
                }
            }
        });
        powerups = powerups.filter(p => p.life > 0);
    }

    function updateParticles(dt) {
        particles.forEach(p => { p.x += p.vx*dt; p.y += p.vy*dt; p.vx *= 0.98; p.vy *= 0.98; p.life -= p.decay; });
        particles = particles.filter(p => p.life > 0);
        // Cap particles to prevent memory issues during intense gameplay
        if (particles.length > 200) particles.splice(0, particles.length - 200);
    }

    function updateStars(dt) {
        stars.forEach(s => {
            s.y += s.speed;
            // Parallax: deeper layers react slightly to player movement
            if (gameState === 'playing' && s.layer > 0) {
                s.x -= player.vx * dt * s.layer * 0.015;
            }
            if (s.y > HEIGHT) { s.y = 0; s.x = Math.random() * WIDTH; }
            if (s.x < 0) s.x = WIDTH;
            if (s.x > WIDTH) s.x = 0;
        });
    }

    function checkCollisions() {
        // Enemy collisions
        enemies.forEach(e => {
            const dx = player.x - e.x, dy = player.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < player.radius + e.radius) {
                if (dash.invincible || activePowerups.shield > 0) {
                    // Destroy enemy ‚Äî satisfying explosion
                    e.life = 0; killCount++; waveKills++;
                    killStreak++; killStreakTimer = 1.5;
                    if (killStreak === 3) { killStreakAnnounce = 'TRIPLE KILL!'; killStreakAnnounceTimer = 1.2; playSound(1000, 0.15, 'square', 0.1); }
                    else if (killStreak === 5) { killStreakAnnounce = 'RAMPAGE!'; killStreakAnnounceTimer = 1.2; playSound(1200, 0.2, 'square', 0.12); }
                    else if (killStreak >= 8) { killStreakAnnounce = 'UNSTOPPABLE!'; killStreakAnnounceTimer = 1.5; playSound(1500, 0.25, 'square', 0.15); }
                    shakeAmount = 10;
                    // Ring burst
                    for (let i = 0; i < 16; i++) {
                        const a = (Math.PI * 2 / 16) * i;
                        const sp = 180 + Math.random() * 80;
                        particles.push({ x: e.x, y: e.y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.7, decay: 0.02, size: 2 + Math.random()*3, color: e.color });
                    }
                    // Center flash
                    particles.push({ x: e.x, y: e.y, vx: 0, vy: 0, life: 0.4, decay: 0.04, size: e.radius * 3, color: '#fff' });
                    // Score popup
                    particles.push({ x: e.x, y: e.y - 15, vx: 0, vy: -70, life: 1, decay: 0.02, size: 0, color: '#ffff00', text: '+100' });
                    playSound(500, 0.1, 'square', 0.12);
                    setTimeout(() => playSound(700, 0.08, 'sine', 0.08), 50);
                    score += 100;
                } else {
                    endGame();
                }
            }
            // Graze
            const grazeDist = player.radius + e.radius + 25;
            if (!e.grazed && dist < grazeDist && dist > player.radius + e.radius) {
                e.grazed = true; grazeCount++; waveGrazes++; comboCount++; comboTimer = 2;
                if (comboCount > comboBest) comboBest = comboCount;
                playGrazeStreakSound(comboCount);
                // Near-death bullet time ‚Äî very close grazes trigger micro slow-mo
                const closeness = dist - (player.radius + e.radius);
                if (closeness < 8) {
                    bulletTime = bulletTimeDuration;
                    flashColor = '#ffffff'; flashAlpha = 0.25;
                    shakeAmount = Math.max(shakeAmount, 6);
                    // Extra dramatic particles for near-death
                    for (let nd = 0; nd < 10; nd++) {
                        const na = Math.random()*Math.PI*2, ns = Math.random()*200+80;
                        particles.push({ x: player.x, y: player.y, vx: Math.cos(na)*ns, vy: Math.sin(na)*ns, life: 0.5, decay: 0.03, size: 1+Math.random()*2, color: '#ffffff' });
                    }
                    playSound(1400, 0.08, 'sine', 0.12);
                } else {
                    flashColor = '#00ffff'; flashAlpha = 0.1 + comboCount * 0.02;
                }
                const mx = (player.x+e.x)/2, my = (player.y+e.y)/2;
                for (let p = 0; p < 6; p++) {
                    const a = Math.random()*Math.PI*2, sp = Math.random()*120+40;
                    particles.push({ x: mx, y: my, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0.6, decay: 0.025, size: Math.random()*3+1, color: comboCount>3?'#ffff00':'#00ffff' });
                }
                particles.push({ x: mx, y: my-10, vx: 0, vy: -80, life: 0.8, decay: 0.025, size: 0, color: comboCount>3?'#ffff00':'#00ffff', text: comboCount>1?`x${comboCount}`:'+50' });
            }
        });
        enemies = enemies.filter(e => e.life !== 0);

        // Power-up collisions (iterate backwards for safe splice)
        for (let i = powerups.length - 1; i >= 0; i--) {
            const p = powerups[i];
            const dx = player.x - p.x, dy = player.y - p.y;
            if (Math.sqrt(dx*dx + dy*dy) < player.radius + p.radius) {
                collectPowerup(p);
                powerups.splice(i, 1);
            }
        }
    }

    // ============================================
    // RENDERING
    // ============================================
    function render() {
        // Dynamic background ‚Äî shifts hue with wave
        const isActive = (gameState === 'playing' || gameState === 'dying') && !paused;
        if (isActive) {
            const isDying = gameState === 'dying';
            if (!cachedBgGrad || bgGradWave !== wave || bgGradW !== WIDTH || bgGradH !== HEIGHT || bgGradDying !== isDying) {
                const waveHue = isDying ? 0 : ((wave - 1) * 30) % 360;
                const sat = isDying ? '60%' : '40%';
                cachedBgGrad = ctx.createRadialGradient(WIDTH/2, HEIGHT/2, 0, WIDTH/2, HEIGHT/2, HEIGHT * 0.9);
                cachedBgGrad.addColorStop(0, `hsla(${waveHue}, ${sat}, 4%, 1)`);
                cachedBgGrad.addColorStop(0.5, `hsla(${waveHue + 20}, 50%, 2%, 1)`);
                cachedBgGrad.addColorStop(1, '#000');
                bgGradWave = wave; bgGradW = WIDTH; bgGradH = HEIGHT; bgGradDying = isDying;
            }
            ctx.fillStyle = cachedBgGrad;
        } else {
            ctx.fillStyle = '#000';
        }
        ctx.fillRect(0, 0, WIDTH, HEIGHT);
        if (shakeAmount > 0) { ctx.save(); ctx.translate((Math.random()-0.5)*shakeAmount, (Math.random()-0.5)*shakeAmount); }

        // Beat pulse overlay (subtle background throb)
        if (isActive && beatPulse > 0 && !muted) {
            ctx.fillStyle = `rgba(0,255,136,${beatPulse * 0.04})`;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
        }

        // Grid
        if (isActive) {
            ctx.strokeStyle = 'rgba(0,255,136,0.05)'; ctx.lineWidth = 1;
            for (let x = 0; x < WIDTH; x += 50) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,HEIGHT); ctx.stroke(); }
            for (let y = 0; y < HEIGHT; y += 50) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(WIDTH,y); ctx.stroke(); }
        }

        // Stars (parallax layers)
        stars.forEach(s => {
            const alpha = s.layer === 0 ? 0.3 : s.layer === 1 ? 0.5 : 0.8;
            ctx.fillStyle = `rgba(255,255,255,${alpha})`;
            ctx.fillRect(s.x, s.y, s.size, s.size);
        });

        // Attract mode enemies (menu/gameover background)
        if (gameState === 'menu' || gameState === 'gameover') renderAttractMode();

        if (isActive) {
            // Player trail
            player.trail.forEach(t => {
                if (t.life > 0) {
                    ctx.globalAlpha = t.life * (dash.active ? 0.8 : 0.5);
                    ctx.fillStyle = dash.active ? '#88ffcc' : '#00ff88';
                    ctx.beginPath(); ctx.arc(t.x, t.y, player.radius * t.life * (dash.active ? 0.7 : 0.5), 0, Math.PI*2); ctx.fill();
                }
            });
            ctx.globalAlpha = 1;

            // Dash afterimages
            dashAfterimages.forEach(a => {
                const alpha = (a.life / a.maxLife) * 0.4;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(a.x, a.y);
                ctx.rotate(a.angle);
                ctx.fillStyle = '#00ff88';
                ctx.shadowBlur = 15; ctx.shadowColor = '#00ff88';
                const r = player.radius;
                ctx.beginPath();
                ctx.moveTo(r * 1.3, 0);
                ctx.lineTo(-r * 0.8, -r * 0.9);
                ctx.lineTo(-r * 0.4, 0);
                ctx.lineTo(-r * 0.8, r * 0.9);
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.restore();
            });
            ctx.globalAlpha = 1;

            // Shield visual
            if (activePowerups.shield > 0) {
                ctx.strokeStyle = '#00aaff';
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.4 + Math.sin(gameTime * 6) * 0.2;
                ctx.shadowBlur = 15; ctx.shadowColor = '#00aaff';
                ctx.beginPath(); ctx.arc(player.x, player.y, player.radius + 10, 0, Math.PI*2); ctx.stroke();
                ctx.globalAlpha = 1; ctx.shadowBlur = 0;
            }

            // Dash invincibility glow
            if (dash.invincible) {
                ctx.strokeStyle = '#88ffcc'; ctx.lineWidth = 3; ctx.globalAlpha = 0.6;
                ctx.beginPath(); ctx.arc(player.x, player.y, player.radius + 6, 0, Math.PI*2); ctx.stroke();
                ctx.globalAlpha = 1;
            }

            // Player (rotating triangle)
            ctx.save();
            ctx.translate(player.x, player.y);
            const angle = Math.atan2(player.vy, player.vx) || 0;
            ctx.rotate(angle);
            const comboGlow = Math.min(comboCount, 10);
            const playerHue = comboGlow > 5 ? `hsl(${160 - comboGlow * 8}, 100%, 60%)` : (activePowerups.shield > 0 ? '#44ccff' : '#00ff88');
            ctx.shadowBlur = 25 + comboGlow * 3; ctx.shadowColor = playerHue;
            ctx.fillStyle = playerHue;
            const r = player.radius;
            ctx.beginPath();
            ctx.moveTo(r * 1.3, 0);
            ctx.lineTo(-r * 0.8, -r * 0.9);
            ctx.lineTo(-r * 0.4, 0);
            ctx.lineTo(-r * 0.8, r * 0.9);
            ctx.closePath();
            ctx.fill();
            // Core glow
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(0, 0, r * 0.3, 0, Math.PI*2); ctx.fill();
            // Engine glow
            ctx.fillStyle = dash.active ? '#88ffcc' : 'rgba(0,255,136,0.5)';
            ctx.beginPath(); ctx.arc(-r * 0.5, 0, r * 0.25 + Math.random() * 2, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
            ctx.restore();

            // Speed lines
            speedLines.forEach(l => {
                ctx.globalAlpha = l.life * 0.6;
                ctx.strokeStyle = '#88ffcc'; ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(l.x, l.y);
                ctx.lineTo(l.x + Math.cos(l.angle)*l.length, l.y + Math.sin(l.angle)*l.length);
                ctx.stroke();
            });
            ctx.globalAlpha = 1;

            // Enemies (trails first, then bodies)
            let enemyIdx = 0;
            enemies.forEach(e => {
                const useShadow = enemyIdx < 10; // Limit shadowBlur to first 10 enemies for perf
                enemyIdx++;
                // Enemy trail
                e.trail.forEach(t => {
                    if (t.life > 0) {
                        ctx.globalAlpha = t.life * 0.3;
                        ctx.fillStyle = e.color;
                        ctx.beginPath(); ctx.arc(t.x, t.y, e.radius * t.life * 0.6, 0, Math.PI*2); ctx.fill();
                    }
                });
                ctx.globalAlpha = 1;
                if (useShadow) { ctx.shadowBlur = 15; ctx.shadowColor = e.color; }
                ctx.fillStyle = e.color;
                if (e.type === 'homing') {
                    // Diamond shape for homing
                    ctx.save(); ctx.translate(e.x, e.y);
                    ctx.rotate(Math.atan2(e.vy, e.vx));
                    ctx.beginPath();
                    ctx.moveTo(e.radius * 1.3, 0);
                    ctx.lineTo(0, -e.radius * 0.8);
                    ctx.lineTo(-e.radius * 0.8, 0);
                    ctx.lineTo(0, e.radius * 0.8);
                    ctx.closePath(); ctx.fill();
                    ctx.restore();
                } else if (e.type === 'burst') {
                    // Star shape for burst
                    ctx.save(); ctx.translate(e.x, e.y);
                    ctx.rotate(gameTime * 2);
                    ctx.beginPath();
                    for (let i = 0; i < 5; i++) {
                        const a1 = (Math.PI * 2 / 5) * i - Math.PI / 2;
                        const a2 = a1 + Math.PI / 5;
                        ctx.lineTo(Math.cos(a1) * e.radius * 1.2, Math.sin(a1) * e.radius * 1.2);
                        ctx.lineTo(Math.cos(a2) * e.radius * 0.5, Math.sin(a2) * e.radius * 0.5);
                    }
                    ctx.closePath(); ctx.fill();
                    ctx.restore();
                } else {
                    // Circle for basic
                    ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2); ctx.fill();
                }
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.beginPath(); ctx.arc(e.x, e.y, e.radius * 0.4, 0, Math.PI*2); ctx.fill();
                // Burst timer visual
                if (e.type === 'burst' && e.burstTimer < 1) {
                    ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.5 + Math.sin(gameTime * 15) * 0.5;
                    ctx.beginPath(); ctx.arc(e.x, e.y, e.radius + 5 + Math.sin(gameTime*10)*3, 0, Math.PI*2); ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                // Sniper laser sight ‚Äî red dashed line from sniper to aim point during charge
                if (e.type === 'sniper' && e.sniperPhase === 'charge') {
                    const chargeProgress = 1 - (e.sniperTimer / e.sniperChargeTime);
                    const laserAlpha = 0.15 + chargeProgress * 0.6;
                    const laserWidth = 1 + chargeProgress * 2;
                    ctx.save();
                    ctx.globalAlpha = laserAlpha;
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = laserWidth;
                    ctx.shadowBlur = 8 + chargeProgress * 15;
                    ctx.shadowColor = '#ff0000';
                    ctx.setLineDash([8, 6]);
                    ctx.lineDashOffset = -gameTime * 80;
                    ctx.beginPath();
                    ctx.moveTo(e.x, e.y);
                    ctx.lineTo(e.sniperAimX, e.sniperAimY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.shadowBlur = 0;
                    // Crosshair at aim point
                    if (chargeProgress > 0.3) {
                        const chSize = 8 + chargeProgress * 6;
                        ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 1.5;
                        ctx.globalAlpha = laserAlpha * 0.8;
                        ctx.beginPath(); ctx.arc(e.sniperAimX, e.sniperAimY, chSize, 0, Math.PI*2); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(e.sniperAimX - chSize - 4, e.sniperAimY); ctx.lineTo(e.sniperAimX + chSize + 4, e.sniperAimY); ctx.stroke();
                        ctx.beginPath(); ctx.moveTo(e.sniperAimX, e.sniperAimY - chSize - 4); ctx.lineTo(e.sniperAimX, e.sniperAimY + chSize + 4); ctx.stroke();
                    }
                    ctx.restore();
                }
                // Sniper body ‚Äî crosshair/scope shape
                if (e.type === 'sniper') {
                    ctx.save(); ctx.translate(e.x, e.y);
                    ctx.strokeStyle = '#ff4444'; ctx.lineWidth = 2;
                    if (useShadow) { ctx.shadowBlur = 12; ctx.shadowColor = '#ff4444'; }
                    ctx.beginPath(); ctx.arc(0, 0, e.radius, 0, Math.PI*2); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(-e.radius*1.4, 0); ctx.lineTo(e.radius*1.4, 0); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(0, -e.radius*1.4); ctx.lineTo(0, e.radius*1.4); ctx.stroke();
                    ctx.fillStyle = '#ff4444'; ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();
                    ctx.shadowBlur = 0; ctx.restore();
                }
            });
            ctx.shadowBlur = 0;

            // Power-ups
            powerups.forEach(p => {
                const s = Math.sin(p.pulse) * 3;
                ctx.globalAlpha = p.life < 3 ? 0.3 + Math.sin(gameTime*10)*0.3 : 0.9;
                ctx.shadowBlur = 12; ctx.shadowColor = p.color;
                ctx.strokeStyle = p.color; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.radius + s, 0, Math.PI*2); ctx.stroke();
                ctx.font = '16px serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.fillText(p.symbol, p.x, p.y);
                ctx.shadowBlur = 0;
            });
            ctx.globalAlpha = 1;

            // Dash cooldown indicator (ring around player)
            if (dash.cooldown > 0) {
                const pct = 1 - dash.cooldown / dash.cooldownTime;
                ctx.strokeStyle = 'rgba(0,255,136,0.3)'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(player.x, player.y, player.radius + 18, -Math.PI/2, -Math.PI/2 + Math.PI*2*pct); ctx.stroke();
            }

            // Combo timer bar ‚Äî drains urgently below player
            if (comboCount > 0 && comboTimer > 0) {
                const barW = 40 + comboCount * 4, barH = 3;
                const barX = player.x - barW/2, barY = player.y + player.radius + 22;
                const pct = comboTimer / 2;
                const barColor = pct > 0.5 ? '#00ffff' : pct > 0.25 ? '#ffaa00' : '#ff0044';
                ctx.globalAlpha = 0.7;
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(barX, barY, barW, barH);
                ctx.fillStyle = barColor;
                ctx.shadowBlur = 6; ctx.shadowColor = barColor;
                ctx.fillRect(barX, barY, barW * pct, barH);
                ctx.shadowBlur = 0; ctx.globalAlpha = 1;
            }

            // Combo streak ring ‚Äî grows and glows with combo count
            if (comboCount > 1 && comboTimer > 0) {
                const comboRing = player.radius + 24 + comboCount * 2;
                const comboAlpha = Math.min(0.6, 0.15 + comboCount * 0.05) * (comboTimer / 2);
                const hue = comboCount > 5 ? `hsl(${60 - comboCount * 3}, 100%, 60%)` : '#00ffff';
                ctx.strokeStyle = hue;
                ctx.lineWidth = 1 + comboCount * 0.3;
                ctx.globalAlpha = comboAlpha;
                ctx.shadowBlur = 10 + comboCount * 2; ctx.shadowColor = hue;
                ctx.beginPath(); ctx.arc(player.x, player.y, comboRing, 0, Math.PI*2); ctx.stroke();
                // Combo text above player
                if (comboCount >= 3) {
                    ctx.font = `bold ${14 + comboCount}px Courier New`; ctx.textAlign = 'center';
                    ctx.fillStyle = hue;
                    ctx.fillText(`x${comboCount}`, player.x, player.y - comboRing - 8);
                }
                ctx.globalAlpha = 1; ctx.shadowBlur = 0;
            }
        }

        // Particles
        particles.forEach(p => {
            ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
            if (p.text) {
                ctx.font = 'bold 16px Courier New'; ctx.textAlign = 'center';
                ctx.shadowBlur = 8; ctx.shadowColor = p.color;
                ctx.fillText(p.text, p.x, p.y); ctx.shadowBlur = 0;
            } else {
                ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
            }
        });
        ctx.globalAlpha = 1;

        // Screen flash
        if (flashAlpha > 0) {
            ctx.fillStyle = flashColor || '#fff'; ctx.globalAlpha = flashAlpha;
            ctx.fillRect(0, 0, WIDTH, HEIGHT); ctx.globalAlpha = 1; flashAlpha -= 0.015;
        }

        // Slow-mo tint
        if (activePowerups.slowmo > 0) {
            ctx.fillStyle = '#ff00ff'; ctx.globalAlpha = 0.06;
            ctx.fillRect(0, 0, WIDTH, HEIGHT); ctx.globalAlpha = 1;
        }

        // Bullet time tint ‚Äî white-blue pulse for near-death moments
        if (bulletTime > 0) {
            const btIntensity = bulletTime / bulletTimeDuration;
            ctx.fillStyle = '#aaddff'; ctx.globalAlpha = btIntensity * 0.12;
            ctx.fillRect(0, 0, WIDTH, HEIGHT); ctx.globalAlpha = 1;
            // Radial lines from player for dramatic effect
            if (gameState === 'playing') {
                ctx.globalAlpha = btIntensity * 0.3;
                ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 1;
                for (let i = 0; i < 12; i++) {
                    const a = (Math.PI*2/12)*i + gameTime;
                    ctx.beginPath();
                    ctx.moveTo(player.x + Math.cos(a)*30, player.y + Math.sin(a)*30);
                    ctx.lineTo(player.x + Math.cos(a)*80, player.y + Math.sin(a)*80);
                    ctx.stroke();
                }
                ctx.globalAlpha = 1;
            }
        }

        // Edge warnings
        if (isActive) {
            edgeWarnings.forEach(w => {
                // Clamp to screen edge
                let wx = Math.max(30, Math.min(WIDTH - 30, w.x));
                let wy = Math.max(30, Math.min(HEIGHT - 30, w.y));
                ctx.globalAlpha = w.life * 0.8;
                ctx.fillStyle = w.color;
                ctx.shadowBlur = 15; ctx.shadowColor = w.color;
                // Draw warning triangle
                ctx.save(); ctx.translate(wx, wy);
                const a = Math.atan2(HEIGHT/2 - wy, WIDTH/2 - wx);
                ctx.rotate(a);
                ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-6, -7); ctx.lineTo(-6, 7); ctx.closePath(); ctx.fill();
                ctx.restore();
                ctx.shadowBlur = 0;
            });
            ctx.globalAlpha = 1;

            // Danger border ‚Äî red glow intensifies with enemy count (cached gradients)
            if (enemies.length > 3) {
                buildDangerGradients();
                const intensity = Math.min(0.4, (enemies.length - 3) * 0.03) * (0.6 + Math.sin(dangerPulse) * 0.4);
                ctx.globalAlpha = intensity;
                ctx.fillStyle = cachedDanger.left; ctx.fillRect(0, 0, 40, HEIGHT);
                ctx.fillStyle = cachedDanger.right; ctx.fillRect(WIDTH-40, 0, 40, HEIGHT);
                ctx.fillStyle = cachedDanger.top; ctx.fillRect(0, 0, WIDTH, 40);
                ctx.fillStyle = cachedDanger.bottom; ctx.fillRect(0, HEIGHT-40, WIDTH, 40);
                ctx.globalAlpha = 1;
            }

            // Vignette (cached)
            if (!cachedVignette || vignetteW !== WIDTH || vignetteH !== HEIGHT) {
                cachedVignette = ctx.createRadialGradient(WIDTH/2, HEIGHT/2, HEIGHT*0.3, WIDTH/2, HEIGHT/2, HEIGHT*0.8);
                cachedVignette.addColorStop(0, 'transparent');
                cachedVignette.addColorStop(1, 'rgba(0,0,0,0.5)');
                vignetteW = WIDTH; vignetteH = HEIGHT;
            }
            ctx.fillStyle = cachedVignette;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
        }

        // Expanding rings
        rings.forEach(r => {
            ctx.globalAlpha = r.life * 0.7;
            ctx.strokeStyle = r.color;
            ctx.lineWidth = r.width * r.life;
            ctx.shadowBlur = 15; ctx.shadowColor = r.color;
            ctx.beginPath(); ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2); ctx.stroke();
            ctx.shadowBlur = 0;
        });
        ctx.globalAlpha = 1;

        // Wave announcement
        if (waveAnnounceTimer > 0 && gameState === 'playing') {
            ctx.save(); ctx.globalAlpha = Math.min(1, waveAnnounceTimer);
            ctx.font = 'bold 64px Courier New'; ctx.textAlign = 'center';
            ctx.fillStyle = '#00ff88'; ctx.shadowBlur = 30; ctx.shadowColor = '#00ff88';
            ctx.fillText(waveAnnounce, WIDTH/2, HEIGHT/2); ctx.restore();
        }

        // Wave break stats + countdown bar
        if (waveBreak && waveBreakStats && gameState === 'playing') {
            ctx.save();
            const breakAlpha = Math.min(1, waveBreakTimer * 3); // fade in
            ctx.globalAlpha = breakAlpha * 0.9;
            ctx.font = '18px Courier New'; ctx.textAlign = 'center';
            ctx.fillStyle = '#88ffcc'; ctx.shadowBlur = 10; ctx.shadowColor = '#00ff88';
            ctx.fillText(`Kills: ${waveBreakStats.kills}  |  Grazes: ${waveBreakStats.grazes}`, WIDTH/2, HEIGHT/2 + 40);
            // Countdown bar
            const barW = 200, barH = 4;
            const pct = waveBreakTimer / waveBreakDuration;
            ctx.globalAlpha = breakAlpha * 0.6;
            ctx.fillStyle = 'rgba(255,255,255,0.15)';
            ctx.fillRect(WIDTH/2 - barW/2, HEIGHT/2 + 55, barW, barH);
            ctx.fillStyle = '#00ff88';
            ctx.fillRect(WIDTH/2 - barW/2, HEIGHT/2 + 55, barW * pct, barH);
            ctx.restore();
        }

        // Kill streak announcement
        if (killStreakAnnounceTimer > 0 && gameState === 'playing') {
            ctx.save(); ctx.globalAlpha = Math.min(1, killStreakAnnounceTimer);
            const scale = 1 + (1 - Math.min(1, killStreakAnnounceTimer)) * 0.3;
            ctx.font = `bold ${Math.floor(36 * scale)}px Courier New`; ctx.textAlign = 'center';
            ctx.fillStyle = '#ff8800'; ctx.shadowBlur = 20; ctx.shadowColor = '#ff8800';
            ctx.fillText(killStreakAnnounce, WIDTH/2, HEIGHT/2 + 60); ctx.restore();
        }

        // CRT scanline overlay (cached offscreen canvas)
        if (isActive) {
            buildScanlines();
            ctx.drawImage(cachedScanlines, 0, 0);
        }

        if (shakeAmount > 0) ctx.restore();
    }

    init();
    </script>
</body>
</html>
